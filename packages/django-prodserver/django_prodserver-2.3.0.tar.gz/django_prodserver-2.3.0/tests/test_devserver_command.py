import os
import re
import shutil
import socket
import subprocess
import sys
import tempfile
import unittest
from io import StringIO
from unittest import mock

from django import conf
from django.conf import settings
from django.core.checks import Error, Tags, register
from django.core.checks.registry import registry
from django.core.management import call_command
from django.core.management.base import SystemCheckError
from django.db import ConnectionHandler
from django.db.migrations.recorder import MigrationRecorder
from django.test import SimpleTestCase
from django.utils.version import get_docs_version

from django_prodserver.management.commands.devserver import Command as RunserverCommand


class AdminScriptTestCase(SimpleTestCase):
    def setUp(self):
        tmpdir = tempfile.TemporaryDirectory()
        self.addCleanup(tmpdir.cleanup)
        # os.path.realpath() is required for temporary directories on macOS,
        # where `/var` is a symlink to `/private/var`.
        self.test_dir = os.path.realpath(os.path.join(tmpdir.name, "test_project"))
        os.mkdir(self.test_dir)

    def write_settings(self, filename, apps=None, is_dir=False, sdict=None, extra=None):
        if is_dir:
            settings_dir = os.path.join(self.test_dir, filename)
            os.mkdir(settings_dir)
            settings_file_path = os.path.join(settings_dir, "__init__.py")
        else:
            settings_file_path = os.path.join(self.test_dir, filename)

        with open(settings_file_path, "w") as settings_file:
            settings_file.write(
                "# Settings file automatically generated by admin_scripts test case\n"
            )
            if extra:
                settings_file.write(f"{extra}\n")
            exports = [
                "DATABASES",
                "DEFAULT_AUTO_FIELD",
                "ROOT_URLCONF",
                "SECRET_KEY",
                "USE_TZ",
            ]
            for s in exports:
                if hasattr(settings, s):
                    o = getattr(settings, s)
                    if not isinstance(o, (dict, tuple, list)):
                        o = f"'{o}'"
                    settings_file.write(f"{s} = {o}\n")

            if apps is None:
                apps = [
                    "django.contrib.auth",
                    "django.contrib.contenttypes",
                    "admin_scripts",
                ]

            settings_file.write(f"INSTALLED_APPS = {apps}\n")

            if sdict:
                for k, v in sdict.items():
                    settings_file.write(f"{k} = {v}\n")

    def _ext_backend_paths(self):
        """Returns the paths for any external backend packages."""
        paths = []
        for backend in settings.DATABASES.values():
            package = backend["ENGINE"].split(".")[0]
            if package != "django":
                backend_pkg = __import__(package)
                backend_dir = os.path.dirname(str(backend_pkg.__file__))
                paths.append(os.path.dirname(backend_dir))
        return paths

    def run_test(self, args, settings_file=None, apps=None, umask=-1):
        base_dir = os.path.dirname(self.test_dir)
        # The base dir for Django's tests is one level up.
        tests_dir = os.path.dirname(os.path.dirname(__file__))
        # The base dir for Django is one level above the test dir. We don't use
        # `import django` to figure that out, so we don't pick up a Django
        # from site-packages or similar.
        django_dir = os.path.dirname(tests_dir)
        ext_backend_base_dirs = self._ext_backend_paths()

        # Define a temporary environment for the subprocess
        test_environ = os.environ.copy()

        # Set the test environment
        if settings_file:
            test_environ["DJANGO_SETTINGS_MODULE"] = settings_file
        elif "DJANGO_SETTINGS_MODULE" in test_environ:
            del test_environ["DJANGO_SETTINGS_MODULE"]
        python_path = [base_dir, django_dir, tests_dir]
        python_path.extend(ext_backend_base_dirs)
        test_environ["PYTHONPATH"] = os.pathsep.join(python_path)
        test_environ["PYTHONWARNINGS"] = ""

        p = subprocess.run(  # NOQA: S603
            [sys.executable, *args],
            capture_output=True,
            cwd=self.test_dir,
            env=test_environ,
            text=True,
            umask=umask,
        )
        return p.stdout, p.stderr

    def run_django_admin(self, args, settings_file=None, umask=-1):
        return self.run_test(["-m", "django", *args], settings_file, umask=umask)

    def run_manage(self, args, settings_file=None, manage_py=None):
        template_manage_py = (
            os.path.join(os.path.dirname(__file__), manage_py)
            if manage_py
            else os.path.join(
                os.path.dirname(conf.__file__), "project_template", "manage.py-tpl"
            )
        )
        test_manage_py = os.path.join(self.test_dir, "manage.py")
        shutil.copyfile(template_manage_py, test_manage_py)

        with open(test_manage_py) as fp:
            manage_py_contents = fp.read()
        manage_py_contents = manage_py_contents.replace(
            "{{ project_name }}", "test_project"
        )
        with open(test_manage_py, "w") as fp:
            fp.write(manage_py_contents)

        return self.run_test(["./manage.py", *args], settings_file)

    def assertNoOutput(self, stream):
        """Utility assertion: assert that the given stream is empty."""
        self.assertEqual(
            len(stream), 0, f"Stream should be empty: actually contains '{stream}'"
        )

    def assertOutput(self, stream, msg, regex=False):
        """Utility assertion: assert that the given message exists in the output."""
        if regex:
            self.assertIsNotNone(
                re.search(msg, stream),
                f"'{msg}' does not match actual output text '{stream}'",
            )
        else:
            self.assertIn(
                msg,
                stream,
                f"'{msg}' does not match actual output text '{stream}'",
            )

    def assertNotInOutput(self, stream, msg):
        """Assert that the given message doesn't exist in the output."""
        self.assertNotIn(msg, stream, f"'{msg}' matches actual output text '{stream}'")


class ManageRunserver(SimpleTestCase):
    """We have these copied from Django's tests as of 16th May 2025 (approximately)."""

    def setUp(self):
        def monkey_run(*args, **options):
            return

        self.output = StringIO()
        self.cmd = RunserverCommand(stdout=self.output)
        self.cmd.run = monkey_run

    def assertServerSettings(self, addr, port, ipv6=False, raw_ipv6=False):
        self.assertEqual(self.cmd.addr, addr)
        self.assertEqual(self.cmd.port, port)
        self.assertEqual(self.cmd.use_ipv6, ipv6)
        self.assertEqual(self.cmd._raw_ipv6, raw_ipv6)

    def test_runserver_addrport(self):
        call_command(self.cmd)
        self.assertServerSettings("127.0.0.1", "8000")

        call_command(self.cmd, addrport="1.2.3.4:8000")
        self.assertServerSettings("1.2.3.4", "8000")

        call_command(self.cmd, addrport="7000")
        self.assertServerSettings("127.0.0.1", "7000")

    def test_zero_ip_addr(self):
        self.cmd.addr = "0"
        self.cmd._raw_ipv6 = False
        self.cmd.on_bind("8000")
        self.assertIn(
            "Starting development server at http://0.0.0.0:8000/",
            self.output.getvalue(),
        )
        docs_version = get_docs_version()
        self.assertIn(
            "WARNING: This is a development server. Do not use it in a "
            "production setting. Use a production WSGI or ASGI server instead."
            "\nFor more information on production servers see: "
            f"https://docs.djangoproject.com/en/{docs_version}/howto/"
            "deployment/",
            self.output.getvalue(),
        )

    def test_on_bind(self):
        self.cmd.addr = "127.0.0.1"
        self.cmd._raw_ipv6 = False
        self.cmd.on_bind("14437")
        self.assertIn(
            "Starting development server at http://127.0.0.1:14437/",
            self.output.getvalue(),
        )
        docs_version = get_docs_version()
        self.assertIn(
            "WARNING: This is a development server. Do not use it in a "
            "production setting. Use a production WSGI or ASGI server instead."
            "\nFor more information on production servers see: "
            f"https://docs.djangoproject.com/en/{docs_version}/howto/"
            "deployment/",
            self.output.getvalue(),
        )

    # @mock.patch.dict(os.environ, {"HIDE_PRODUCTION_WARNING": "true"})
    # def test_hide_production_warning_with_environment_variable(self):
    #     self.cmd.addr = "0"
    #     self.cmd._raw_ipv6 = False
    #     self.cmd.on_bind("8000")
    #     self.assertIn(
    #         "Starting development server at http://0.0.0.0:8000/",
    #         self.output.getvalue(),
    #     )
    #     docs_version = get_docs_version()
    #     self.assertNotIn(
    #         "WARNING: This is a development server. Do not use it in a "
    #         "production setting. Use a production WSGI or ASGI server instead."
    #         "\nFor more information on production servers see: "
    #         f"https://docs.djangoproject.com/en/{docs_version}/howto/"
    #         "deployment/",
    #         self.output.getvalue(),
    #     )

    @unittest.skipUnless(socket.has_ipv6, "platform doesn't support IPv6")
    def test_runner_addrport_ipv6(self):
        call_command(self.cmd, addrport="", use_ipv6=True)
        self.assertServerSettings("::1", "8000", ipv6=True, raw_ipv6=True)

        call_command(self.cmd, addrport="7000", use_ipv6=True)
        self.assertServerSettings("::1", "7000", ipv6=True, raw_ipv6=True)

        call_command(self.cmd, addrport="[2001:0db8:1234:5678::9]:7000")
        self.assertServerSettings(
            "2001:0db8:1234:5678::9", "7000", ipv6=True, raw_ipv6=True
        )

    def test_runner_hostname(self):
        call_command(self.cmd, addrport="localhost:8000")
        self.assertServerSettings("localhost", "8000")

        call_command(self.cmd, addrport="test.domain.local:7000")
        self.assertServerSettings("test.domain.local", "7000")

    @unittest.skipUnless(socket.has_ipv6, "platform doesn't support IPv6")
    def test_runner_hostname_ipv6(self):
        call_command(self.cmd, addrport="test.domain.local:7000", use_ipv6=True)
        self.assertServerSettings("test.domain.local", "7000", ipv6=True)

    def test_runner_custom_defaults(self):
        self.cmd.default_addr = "192.168.1.45"
        self.cmd.default_port = "5000"
        call_command(self.cmd)
        self.assertServerSettings("192.168.1.45", "5000")

    @unittest.skipUnless(socket.has_ipv6, "platform doesn't support IPv6")
    def test_runner_custom_defaults_ipv6(self):
        self.cmd.default_addr_ipv6 = "::"
        call_command(self.cmd, use_ipv6=True)
        self.assertServerSettings("::", "8000", ipv6=True, raw_ipv6=True)

    def test_runner_ambiguous(self):
        # Only 4 characters, all of which could be in an ipv6 address
        call_command(self.cmd, addrport="beef:7654")
        self.assertServerSettings("beef", "7654")

        # Uses only characters that could be in an ipv6 address
        call_command(self.cmd, addrport="deadbeef:7654")
        self.assertServerSettings("deadbeef", "7654")

    def test_no_database(self):
        """Ensure runserver.check_migrations doesn't choke on empty DATABASES."""
        tested_connections = ConnectionHandler({})
        with mock.patch(
            "django.core.management.base.connections", new=tested_connections
        ):
            self.cmd.check_migrations()

    def test_readonly_database(self):
        """runserver.check_migrations() doesn't choke when a database is read-only."""
        with mock.patch.object(MigrationRecorder, "has_table", return_value=False):
            self.cmd.check_migrations()
        # You have # ...
        self.assertIn("unapplied migration(s)", self.output.getvalue())

    @mock.patch("django.core.management.commands.runserver.run")
    @mock.patch("django.core.management.base.BaseCommand.check_migrations")
    @mock.patch("django.core.management.base.BaseCommand.check")
    def test_skip_checks(self, mocked_check, *mocked_objects):
        call_command(
            "runserver",
            use_reloader=False,
            skip_checks=True,
            stdout=self.output,
        )
        self.assertNotIn("Performing system checks...", self.output.getvalue())
        mocked_check.assert_not_called()

        self.output.truncate(0)
        call_command(
            "runserver",
            use_reloader=False,
            skip_checks=False,
            stdout=self.output,
        )
        self.assertIn("Performing system checks...", self.output.getvalue())
        mocked_check.assert_has_calls(
            [mock.call(tags=set()), mock.call(display_num_errors=True)]
        )

    def test_custom_system_checks(self):
        original_checks = registry.registered_checks.copy()

        @register(Tags.signals)
        def my_check(app_configs, **kwargs):
            return [Error("my error")]

        class CustomException(Exception):
            pass

        self.addCleanup(setattr, registry, "registered_checks", original_checks)

        class CustomRunserverCommand(RunserverCommand):
            """Rather than mock run(), raise immediately after system checks run."""

            def check_migrations(self, *args, **kwargs):
                raise CustomException

        class CustomRunserverCommandWithSignalsChecks(CustomRunserverCommand):
            requires_system_checks = [Tags.signals]  # NOQA: RUF012

        command = CustomRunserverCommandWithSignalsChecks()
        with self.assertRaises(SystemCheckError):
            call_command(
                command,
                use_reloader=False,
                skip_checks=False,
                stdout=StringIO(),
                stderr=StringIO(),
            )

        class CustomMigrateCommandWithSecurityChecks(CustomRunserverCommand):
            requires_system_checks = [Tags.security]  # NOQA: RUF012

        command = CustomMigrateCommandWithSecurityChecks()
        with self.assertRaises(CustomException):
            call_command(
                command,
                use_reloader=False,
                skip_checks=False,
                stdout=StringIO(),
                stderr=StringIO(),
            )


# class ManageRunserverMigrationWarning(TestCase):
#     def setUp(self):
#         self.stdout = StringIO()
#         self.runserver_command = RunserverCommand(stdout=self.stdout)

#     @override_settings(INSTALLED_APPS=["admin_scripts.app_waiting_migration"])
#     def test_migration_warning_one_app(self):
#         self.runserver_command.check_migrations()
#         output = self.stdout.getvalue()
#         self.assertIn("You have 1 unapplied migration(s)", output)
#         self.assertIn("apply the migrations for app(s): app_waiting_migration.",
#                       output)

#     @override_settings(
#         INSTALLED_APPS=[
#             "admin_scripts.app_waiting_migration",
#             "admin_scripts.another_app_waiting_migration",
#         ],
#     )
#     def test_migration_warning_multiple_apps(self):
#         self.runserver_command.check_migrations()
#         output = self.stdout.getvalue()
#         self.assertIn("You have 2 unapplied migration(s)", output)
#         self.assertIn(
#             "apply the migrations for app(s): another_app_waiting_migration, "
#             "app_waiting_migration.",
#             output,
#         )


class ManageRunserverEmptyAllowedHosts(AdminScriptTestCase):
    def setUp(self):
        super().setUp()
        self.write_settings(
            "settings.py",
            sdict={
                "ALLOWED_HOSTS": [],
                "DEBUG": False,
            },
        )

    def test_empty_allowed_hosts_error(self):
        out, err = self.run_manage(["runserver"])
        self.assertNoOutput(out)
        self.assertOutput(
            err, "CommandError: You must set settings.ALLOWED_HOSTS if DEBUG is False."
        )


class ManageRunserverHelpOutput(AdminScriptTestCase):
    def test_suppressed_options(self):
        """Runserver doesn't support --verbosity and --trackback options."""
        out, err = self.run_manage(["runserver", "--help"])
        self.assertNotInOutput(out, "--verbosity")
        self.assertNotInOutput(out, "--trackback")
        self.assertOutput(out, "--settings")
