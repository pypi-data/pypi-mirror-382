5) NÃ¤chster Schritt: was als NÃ¤chstes testen/bauen?

Abdeckung messen (make coverage-html) und gezielt LÃ¼cken schlieÃŸen.

Kleine ErgÃ¤nzungs-Tests (nur wenn dir noch was fehlt):

CSV + Excel Pfade gleich behandelt (flattenâ†’lift) â€“ ein Cross-check Test.

Helper-Spalten droppen bei unpack (haben wir indirekt, aber ein direkter Test ist nett).


FehlerfÃ¤lle: FK zeigt auf nicht existierendes Blatt (derzeit ignorieren wir; fÃ¼r 2b Validation relevant).

Dann Phase 2b: Validation & Flags
Wir fÃ¼hren ein zentrales validate.py ein, plus CLI-Flags:

--fail-on-missing-fk / --warn-on-missing-fk

Report pro Blatt (Counts + kleine Stichprobe)

Tests fÃ¼r Fehlersituationen

Das alles hÃ¤ngt jetzt sauber an der Engine und bleibt von Excel/CSV entkoppelt â€“ guter Schritt Richtung wartbarer Architektur.


0000000000000000000000000000000

[200~Roadmap-Reminder (wo wir im Plan stehen)

âœ… Phase 1: Multi-Sheet Orchestrierung, flattenâ†”lift, Pack/Unpack.

âœ… Phase 2a: FKs + statische Helper-Spalten; Klammer-Konvention; Typ-Normalisierung.

â­ Phase 2b: Validierung & Optionen

--fail-on-missing-fk / --warn-on-missing-fk

saubere Fehlermeldungen, evtl. Report pro Sheet.

â­ Phase 2c: Pro-Sheet Overrides im YAML (id_field, label_field, detect_fk, helper_prefix, etc.)

â­ Phase 3: Excel-Komfort

VLOOKUP/XLOOKUP statt statischem Text (damit Name â€liveâ€œ folgt)

Dropdown/Data Validation fÃ¼r FK-Spalten

dezentes Styling/Color Coding (Header, FK, Helper readonly).

â­ Phase 4: Echte mehrzeilige Header (â€splitâ€œ-Modus).

â­ Phase 5: Doku & Beispiele, carve-out in eigenes Repo, Releases.

Wenn du die Tests einspielst und alles grÃ¼n bleibt, gehen wir direkt in Phase 2b (Validierung & Flags) Ã¼ber.

-----------------------------------

Zwei Abbildungen im Spreadsheet (pro Liste konfigurierbar)

inline-delimited (eine Zelle, Trennzeichen)

tags â†’ Spalte tags mit Inhalt rot | blau (Delimiter konfigurierbar, Escape \).

FÃ¼r FK-Listen: id_(Kategorien) mit mehreren IDs in einer Zelle (z. B. A | B | C). Helper: _Kategorien_names mit BÃ¼cher | Filme | â€¦.

Pro: schnell editierbar, wenig BlÃ¤tter; Contra: Formeln/Validierung komplizierter.

child-sheet (normiert, eigenes Blatt)

Blattname: Bestellungen.positionen (oder Bestellungen__positionen), Spalten: parent_id, pos (Reihenfolge), Felder der List-Objekte.

FÃ¼r FK-Listen: eine Spalte id_(Kategorien) + Helper _Kategorien_name.

Pro: sauber, gut validierbar, gut filterbar; Contra: mehr BlÃ¤tter.

Default: inline-delimited fÃ¼r Primitives & FK-Listen, child-sheet fÃ¼r Objekt-Listen.

---------------------------------------------


6ff

[200~Das passt super zu unserem bisherigen Design â€“ deine Zusammenfassung baut logisch drauf auf. ğŸ’¯
Kurz: Wir kÃ¶nnen das als Phase 6ff Ã¼bernehmen, und es beiÃŸt sich nicht mit 2bâ€“5. Im Gegenteil: 2b (Validierung) & 2c (YAML-Overrides) sind perfekte Vorarbeit. Excel-Goodies (Phase 3), split-Header (Phase 4) und Doku (Phase 5) bleiben unabhÃ¤ngig.

Hier ist, wie ichâ€™s mit unseren bestehenden Konventionen zusammenfÃ¼hre und was wir minimal anpassen sollten.

Wo es andockt (und 2 kleine, notwendige Anpassungen)

FK-Klammerkonvention weiterverwenden â€“ Ã¼berall
Alle Referenzen bleiben im Format
"<key_field>_(<SheetKey>)"
â€“ also auch fÃ¼r Eltern, Junctions, und tiefe Ebenen.

Eltern-FK in Kind-Sheet: id_(Kunden) (oder Schluessel_(Kunden)).

Junction: id_(Kunden), id_(Tags).

Enkel (Kind-Kind): line_id_(Kunden_adressen).

Regex anpassen, damit line_id erlaubt ist
Unser aktuelles FK_PATTERN schlieÃŸt _ in <key_field> aus (Autsch).
Ã„ndern auf: ^(?P<id_field>[A-Za-z0-9_]+)_\((?P<sheet_key>[^)]+)\)$
â†’ dann matcht auch line_id_(...).

SheetKey-Normalisierung erweitern
Bisher: Leerzeichen â†’ _.
Neu: auch . â†’ _ (fÃ¼r Kunden.adressen â†’ Kunden_adressen).
So bleiben SchlÃ¼ssel stabil und kollisionsarm.

Kanonische Tabellenformen (leichtgewichtiges ORM)
Eltern

Sheet: Kunden

Pflichtspalten: id (oder konfigurierbar), name (Label)

Alles andere: normale Felder.

1:n (Kind-Tabellen)

Sheet: Kunden.adressen

Pflicht:

line_id (stabil, eindeutig je Kindzeile)

id_(Kunden) (Eltern-FK; per YAML auch Schluessel_(Kunden))

idx (Integer; Reihenfolge innerhalb des Elterns)

Optionale Felder: type (Enum), weitere Felder.

Helper: _Kunden_name (auto, nur Anzeige)

n:m (Junction)

Vokabular: Tags (id, name, â€¦)

Junction-Sheet: Kunden_tags (oder Kunden.tags â€“ ich wÃ¼rde Kunden_tags nehmen)

id_(Kunden), id_(Tags), optional idx

Helper: _Kunden_name, _Tags_name (auto)

Liste-in-Liste (Enkel)

Sheet: Kunden.adressen.addons

Pflicht:

line_id (eigene ID der Enkelzeile)

line_id_(Kunden_adressen) (FK auf die Kind-Zeile)

idx

Optional type etc.

Helper: _Kunden_adressen_<etwas> mÃ¶glich, wenn sinnvoll.

Reihenfolge: immer Ã¼ber idx (deterministisch, stabil).
Typisierung/Varianten: Ã¼ber type (Enum), gern via Excel-Dropdowns validierbar (Phase 3).

JSON-â†”-Spreadsheet Roundtrip (Implementationsskizze)
Pack (JSON â†’ Sheets)

Kind-Listen: erzeugen Kunden.adressen mit Spalten line_id, id_(Kunden), idx, â€¦

Falls line_id im JSON fehlt: deterministisch erzeugen (z. B. "{parent_id}:{idx}" oder UUID v4 â€“ konfigurierbar; deterministisch ist angenehmer fÃ¼r Diffs).

Enkel: analog mit line_id_(Kunden_adressen).

n:m: aus customer.tags (IDs) Junction-Zeilen erzeugen.

Helper-Spalten: fÃ¼r jede FK-Spalte _â€¦_name auffÃ¼llen (wie wirâ€™s jetzt schon tun).

Unpack (Sheets â†’ JSON)

Kind: pro id_(Kunden) gruppieren, nach idx sortieren, Liste bauen; line_id mitnehmen.

Enkel: pro line_id_(Kunden_adressen) gruppieren, nach idx sortieren, als Nested-Liste unter die richtige Kind-Zeile einhÃ¤ngen.

n:m: pro id_(Kunden) sammeln â†’ wahlweise als ID-Liste oder expandierte Objekte (YAML-Flag).

Helper-Spalten: wie gehabt droppen (Prefix _).

Validierung (Phase 2b): fehlende Ziel-IDs, verwaiste line_id_(â€¦), doppelte line_id/idx â†’ warn/fail je Flag.

YAML-Erweiterung (nur Skizze)
defaults:
  id_field: id
  label_field: name
  helper_prefix: "_"
  detect_fk: true
  list_defaults:
    mode: child-sheet        # child-sheet | inline-delimited
    delimiter: " | "
    generate_line_id: "deterministic"  # deterministic | uuid
sheets:
  - name: Kunden
    json: data/kunden.json
    lists:
      - path: adressen[]             # Objekt-Liste
        mode: child-sheet
        child_sheet: Kunden.adressen
        parent_fk: "id_(Kunden)"     # Standard; erlaubt auch Alias "parent_id"
        order_field: idx
        line_id_field: line_id
      - path: tags[]                 # n:m Ã¼ber Junction
        mode: junction
        vocab_sheet: Tags
        junction_sheet: Kunden_tags
        parent_fk: "id_(Kunden)"
        vocab_fk: "id_(Tags)"
        as: ids                      # ids | objects

Was mÃ¼ssen wir im Code anpassen/ergÃ¤nzen?

FK-Engine

Regex wie oben anpassen.

normalize_sheet_key: auch . â†’ _.

Eltern-FKs funktionieren sofort (wir behandeln sie wie jede FK-Spalte).

List-Compiler (neu)

json_lists -> child sheets: erzeugt Frames fÃ¼r Parent.field/junction.

child sheets -> json_lists: gruppiert zurÃ¼ck.

FÃ¼r Enkel die Kette via line_id_(Parent_field) auflÃ¶sen.

Validierung (Phase 2b)

Fehlende FK-Ziele: warn/fail.

Doppelte line_id in denselben Sheet(s): fail.

idx-LÃ¼cken sind ok, aber idx doppelt im selben Parent â†’ warn/fail.

Junction ohne Vokabular-ID â†’ warn/fail.

Orphan-Enkel (ohne existierende Kind-line_id) â†’ fail.

Tests (mindestens)

1:n Roundtrip mit line_id, idx.

Liste-in-Liste Roundtrip mit line_id_(â€¦).

n:m Roundtrip; wahlweise als ID-Liste oder expandiert.

Mischtyp-IDs (str/int) â€“ unsere Normalisierung deckt das schon.

YAML-Overrides (andere id_field, line_id_field).

Wechselwirkungen mit 2bâ€“5

2b Validierung: direkte Grundlage â€“ bauen wir jetzt und nutzenâ€™s fÃ¼r Listen (fehlende Eltern, Orphans, Duplikate).

2c YAML: Listen brauchen Pfad-Konfigs â†’ 2c zuerst.

3 Excel: XLOOKUP/TextJoin & Dropdowns werden bei Listen hÃ¼bsch, sind aber optional.

4 split-Header: unabhÃ¤ngig. Child-Sheets haben klare Spaltennamen, inline-delimited bleibt 1-zeilig.

5 Doku: Listen werden ein eigenes Kapitel.

Mini-Delta, das wir sofort ziehen sollten

FK_PATTERN â†’ ^(?P<id_field>[A-Za-z0-9_]+)_\((?P<sheet_key>[^)]+)\)$

normalize_sheet_key â†’ Leerzeichen und Punkte zu _

Wenn du mÃ¶chtest, mache ich als NÃ¤chstes 2b (Validierung & Flags) startklar (kleiner, fokussierter PR):

--fail-on-missing-fk/--warn-on-missing-fk

Report je Blatt (Counts/Beispiele)

Tests fÃ¼r die wichtigsten FehlerfÃ¤lle.

Danach 2c (YAML Pfad-Overrides) und dann Phase 6 (Listen) â€“ damit bleiben wir sauber inkrementell.















