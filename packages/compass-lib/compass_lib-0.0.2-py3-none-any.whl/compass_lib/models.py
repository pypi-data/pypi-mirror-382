from __future__ import annotations

import datetime  # noqa: TC003
import json
from pathlib import Path
from typing import Annotated
from typing import Any

from pydantic import BaseModel
from pydantic import ConfigDict
from pydantic import Field
from pydantic import field_validator

from compass_lib.encoding import EnhancedJSONEncoder

# from compass_lib.errors import DuplicateValueError


class SurveyShot(BaseModel):
    from_id: str
    to_id: str

    azimuth: Annotated[float, Field(ge=0, lt=360)]

    inclination: Annotated[float, Field(ge=-90, le=90)]
    length: Annotated[float, Field(ge=0)]

    # Optional Values
    comment: str | None = None
    flags: Any | None = None

    azimuth2: Annotated[float, Field(ge=0, lt=360)] | None = None
    inclination2: Annotated[float, Field(ge=-90, le=90)] | None = None

    # LRUD
    left: Annotated[float, Field(ge=0)] = 0.0
    right: Annotated[float, Field(ge=0)] = 0.0
    up: Annotated[float, Field(ge=0)] = 0.0
    down: Annotated[float, Field(ge=0)] = 0.0

    model_config = ConfigDict(extra="forbid")

    @field_validator("left", "right", "up", "down", mode="before")
    @classmethod
    def validate_lrud(cls, value: float) -> float:
        return value if value > 0 else 0.0

    @field_validator("azimuth", "azimuth2", mode="before")
    @classmethod
    def validate_azimuth(cls, value: float) -> float:
        return value if value > 0 else 0.0

    @field_validator("inclination2", mode="before")
    @classmethod
    def validate_inclination2(cls, value: float) -> float:
        return value if -90 <= value <= 90 else 0.0

    # ======================== VALIDATOR UTILS ======================== #

    # @classmethod
    # def validate_unique(cls, field: str, values: list) -> list:
    #     vals2check = [getattr(val, field) for val in values]
    #     dupl_vals = list(duplicates(vals2check))
    #     if dupl_vals:
    #         raise DuplicateValueError(
    #             f"[{cls.__name__}] Duplicate value found for `{field}`: "
    #             f"{dupl_vals}"
    #         )
    #     return values

    # @field_validator("to_id", mode="before")
    # @classmethod
    # def validate_unique_to_id(cls, value: str | None) -> str:
    #     """Note: Validators are only ran with custom fed values.
    #     Not autogenerated ones. Hence we need to register the name."""

    #     if value is None or value == "":
    #         return cls.to_id.default_factory()

    #     # 1. Verify the name is only composed of valid chars.
    #     for char in value:
    #         if char.upper() not in [
    #             *UniqueNameGenerator.VOCAB,
    #             *list("_-~:!?.'()[]{}@*&#%|$")
    #         ]:
    #             raise ValueError(f"The character `{char}` is not allowed as `name`.")

    #     if len(value) > COMPASS_MAX_NAME_LENGTH:
    #         raise ValueError(f"Name {value} is too long, maximum allowed: "
    #                          f"{COMPASS_MAX_NAME_LENGTH}")

    #     UniqueNameGenerator.register(value=value)
    #     return value


class SurveySection(BaseModel):
    name: str
    comment: str
    correction: list[float]
    correction2: list[float]
    survey_date: datetime.date | None = None
    discovery_date: datetime.date | None = None
    declination: float
    format: str = "DDDDUDLRLADN"
    shots: list[SurveyShot]
    surveyors: str | None = None

    model_config = ConfigDict(extra="forbid")


class Survey(BaseModel):
    cave_name: str
    description: str = ""

    sections: list[SurveySection] = []

    model_config = ConfigDict(extra="forbid")

    def to_json(self, filepath: str | Path | None = None) -> str:
        filepath = Path(filepath) if filepath else None
        data = self.model_dump()

        json_str = json.dumps(data, indent=4, sort_keys=True, cls=EnhancedJSONEncoder)

        if filepath is not None:
            with filepath.open(mode="w") as file:
                file.write(json_str)

        return json_str
