#!/usr/bin/env python3

"""
Small parts of this code has been taken by https://github.com/DestructiveVoice/DestructiveFarm/blob/master/client/start_sploit.py
And that's one of the reasons why this attacker/submitter is called "exploitfarm"
"""

import dateutil.parser
import os
import re
import orjson
import math
import subprocess
import time
import threading
import traceback
import random
from concurrent.futures import ThreadPoolExecutor
from exploitfarm.utils.config import ExploitConfig
from datetime import datetime as dt, timedelta
import datetime
import io
from exploitfarm.models.enums import AttackExecutionStatus, AttackMode
from rich import print
from copy import deepcopy
from rich.markup import escape
from queue import Empty
from exploitfarm import nicenessify
from exploitfarm.utils import dumpstacks
from exploitfarm.utils.config import AttackStartConfig, TeamInfo, TeamAttackInfo
from exploitfarm.utils.windows_close_fix import CtrlCWinManager
from exploitfarm.models.groups import JoinRequestClient, JoinRequestResponse
from exploitfarm.models.response import MessageResponse
from exploitfarm.models.enums import ResponseStatus
from exploitfarm.utils import json_like
from exploitfarm.models.groups import GroupRequestEvent, GroupEventRequestType
from exploitfarm.models.groups import GroupResponseEventClient, GroupEventResponseType
from pydantic import ValidationError, BaseModel
from exploitfarm.utils import clear_exploit_folder
from exploitfarm.utils.reqs import get_url as get_url_from_config


def dt_now():
    return dt.now(datetime.timezone.utc)


os_windows = os.name == "nt"
os_unix = os.name == "posix"


class g:
    exec: AttackStartConfig
    exploit_config: ExploitConfig = None
    attack_storage: "AttackStorage" = None
    instance_storage: "InstanceStorage" = None
    server_id = None
    thread_pool: ThreadPoolExecutor = None
    tot_teams: int = 0
    flag_cache: set = set()
    attack_round_deadline = dt_now()
    _shutdown = False
    exploit_hash: str | None = None
    virtual_time_available = 0
    ctrl_c_win: CtrlCWinManager = None
    old_config: dict = {}
    dynamic_attack_timeout = 0  # Used only on shared attacks


def init_xploit_actions(xploit_path: str):
    import exploitfarm.utils.reqs

    g.ctrl_c_win = CtrlCWinManager(shutdown)
    exploitfarm.utils.reqs.HTTP_TIMEOUT = 30
    g.attack_storage = AttackStorage()
    g.instance_storage = InstanceStorage()
    os.chdir(xploit_path)
    g.exploit_config = ExploitConfig.read(".")
    g.exploit_hash = g.exploit_config.hash()


class InstanceStorage:
    """
    Storage comprised of a dictionary of all running sploit instances and some statistics.

    Always acquire instance_lock before using this class. Do not release the lock
    between actual spawning/killing a process and calling register_start()/register_stop().
    """

    def __init__(self):
        self._counter = 0
        self._instances = {}

        self.lock = threading.RLock()

    @property
    def instances(self):
        return self._instances

    def register_start(self, process, exit_event, target):
        with self.lock:
            instance_id = self._counter
            self._instances[instance_id] = {
                "proc": process,
                "exit_trigger": exit_event,
                "target": target,
            }
            self._counter += 1
            g.exec.info.running_workers = len(self._instances)
            return instance_id

    def __kill_action(self, instance):
        instance["exit_trigger"].set()
        try:
            instance["proc"].wait(timeout=1)
        except subprocess.TimeoutExpired:
            instance["proc"].kill()

    def kill_by_target(self, target):
        with self.lock:
            instances_to_delete = []
            for instance_id, instance in self._instances.items():
                if instance["target"] == target:
                    self.__kill_action(instance)
                    instances_to_delete.append(instance_id)
            for instance_id in instances_to_delete:
                self.register_stop_no_lock(instance_id)

    def killall(self):
        with self.lock:
            instances_to_delete = []
            for instance_id, instance in self._instances.items():
                self.__kill_action(instance)
                instances_to_delete.append(instance_id)
            for instance_id in instances_to_delete:
                self.register_stop_no_lock(instance_id)

    def register_stop_no_lock(self, instance_id):
        if instance_id in self._instances:
            del self._instances[instance_id]
            g.exec.info.running_workers = len(self._instances)

    def register_stop(self, instance_id):
        with self.lock:
            self.register_stop_no_lock(instance_id)


def get_team_info(team: int):
    return g.exec.info.teams.get(team, TeamInfo())


def set_attack_exec(team: int, status: bool):
    team_info = get_team_info(team)
    team_info.executing = status
    g.exec.info.teams[team] = team_info


class AttackStorage:
    """
    Thread-safe storage comprised of a set and a post queue.

    Any number of threads may call add(), but only one "consumer thread"
    may call pick_flags() and mark_as_sent().
    """

    def __init__(self):
        self._queue = []
        self._lock = threading.RLock()

    def add(
        self,
        flags: list[str],
        team: int,
        start_time: dt,
        end_time: dt,
        status: AttackExecutionStatus,
        output: bytes,
        stats: bool = True,
    ):
        with self._lock:
            flags = [flag for flag in flags if flag not in g.flag_cache]
            g.flag_cache.update(flags)
            execution_submit = {
                "start_time": start_time,
                "end_time": end_time,
                "status": status.value,
                "output": output,
                "executed_by": g.exec.config.client_id,
                "target": team,
                "flags": flags,
                "source_hash": g.exploit_hash,
            }
            # If it's a group attack, add the group ID
            if is_group_attack():
                execution_submit["executed_by_group"] = g.exec.group["id"]
            if stats:
                team_info = get_team_info(team)
                team_info.last = TeamAttackInfo(
                    start_time=start_time,
                    end_time=end_time,
                    status=status,
                    flags=len(flags),
                )
                team_info.flags += len(flags)
                g.exec.info.teams[team] = team_info

            self._queue.append(execution_submit)

    def pick_attacks(self):
        with self._lock:
            return self._queue[:]

    def mark_as_sent(self, count):
        with self._lock:
            self._queue = self._queue[count:]

    @property
    def queue_size(self):
        with self._lock:
            return len(self._queue)


WARNING_RUNTIME = 5


def qprint(*args, end="\n"):
    try:
        for arg in args:
            if isinstance(arg, str):
                g.exec.print_queue.put(escape(arg))
            else:
                g.exec.print_queue.put(arg)
        if end:
            g.exec.print_queue.put(end)
    except (KeyboardInterrupt, ValueError):
        traceback.print_exc()
        pass


class InvalidSploitError(Exception):
    pass


if os_unix:
    # Unlock the file descriptor limit
    import resource

    fdlimit = resource.getrlimit(resource.RLIMIT_NOFILE)
    resource.setrlimit(resource.RLIMIT_NOFILE, (fdlimit[1] // 2, fdlimit[1]))


class APIException(Exception):
    pass


def once_in_a_period(period):
    iter_no = 1
    while True:
        start_time = time.time()
        yield iter_no
        time_spent = time.time() - start_time
        if period > time_spent:
            if g.exec.exit_event.wait(timeout=period - time_spent):
                return
        iter_no += 1


def repush_flags():
    try:
        with open(".flag_queue.json", "rt") as f:
            old_queue_data = orjson.loads(f.read())
        if old_queue_data["server_id"] != g.server_id:
            raise Exception("Server ID mismatch")
        for ele in old_queue_data["queue"]:
            g.attack_storage.add(
                ele["flags"],
                ele["target"],
                ele["start_time"],
                ele["end_time"],
                AttackExecutionStatus(ele["status"]),
                ele["output"],
                stats=False,
            )
    except Exception:
        if os.path.exists(".flag_queue.json"):
            os.remove(".flag_queue.json")


def attack_group_updater(event):
    try:
        groups = g.exec.config.reqs.groups()
        for ele in groups:
            if ele["id"] == g.exec.group["id"]:
                g.exec.group = ele
                break
    except Exception as e:
        qprint(f"Can't get group info from the server: {repr(e)}")
        qprint(traceback.format_exc())


def refetch_config(send_update_config: bool):
    try:
        g.exec.config.fetch_status()
        if g.exec.config.status:
            if not g.exec.config.status["loggined"]:
                qprint("Not loggined, login first to get the config and run the exploit")
                print(
                    "[red]Not loggined, login first to get the config and run the exploit[/red]"
                )
                g.exec.info.config_update = False
                return shutdown()
            else:
                g.exec.info.config_update = True

            if not g.server_id:
                g.server_id = g.exec.config.status["server_id"]
                repush_flags()
            else:
                if g.server_id != g.exec.config.status["server_id"]:
                    qprint("Server ID changed, restart the exploit")
                    shutdown(restart=True)
                    return
            if send_update_config:
                g.exec.config_update_queue.put("update")
    except Exception as e:
        qprint(f"Can't get config from the server: {repr(e)}")
        qprint(traceback.format_exc())
        g.exec.info.config_update = False


def update_warnings(event):
    refetch_config(send_update_config=False)


def update_server_config(event):
    refetch_config(send_update_config=True)


def post_attacks(attacks):
    try:
        g.exec.config.reqs.submit_flags(attacks, exploit=g.exploit_config.uuid)
        g.attack_storage.mark_as_sent(len(attacks))
        g.exec.info.submitter_status = True
        return True
    except Exception as e:
        g.exec.info.submitter_status = False
        qprint(traceback.format_exc())
        qprint(f"Can't post flags to the server: {repr(e)}")
        return False


def __loop_post_flags():
    all_attack_to_post = g.attack_storage.pick_attacks()
    g.exec.info.submitter_flags_in_queue = len(all_attack_to_post)
    packet_dim = 50  # 50 is to avoid the backend goes in timeout
    for base_block in range(0, len(all_attack_to_post), packet_dim):
        end_block = base_block + packet_dim
        attack_to_post = all_attack_to_post[base_block:end_block]
        if attack_to_post and not post_attacks(attack_to_post):
            break


def run_post_loop():
    # Submit to explotfarm server the attack results
    try:
        for _ in once_in_a_period(g.exec.submit_pool_timeout):
            __loop_post_flags()
    except Exception as e:
        g.exec.info.submitter_status = False
        qprint(traceback.format_exc())
        qprint(f"Posting loop died: {repr(e)}")


def process_sploit_filter(
    proc: subprocess.Popen,
    team: dict,
    start_time: dt,
    killed: bool,
    read_data: callable,
    final_output: bool = True,
) -> int:
    # Filtering and processing the output of the exploit
    try:
        end_time = dt_now()
        output = read_data()

        if isinstance(output, bytes):
            output = output.decode("utf-8", errors="replace")

        if final_output:
            qprint(
                f"Output of the sploit of {team['host']} killed[{killed}] status[{proc.returncode}]: '{team.get('short_name') or team.get('name') or team.get('id')}' started: {start_time} ended: {end_time}\n{output}"
            )

        if not final_output and killed:
            qprint("☠️ xFarm killed the sploit due to timeout!")

        flag_format = re.compile(g.exec.config.status["config"]["FLAG_REGEX"])
        flags = list(map(str, set(flag_format.findall(output))))

        if killed or proc.returncode != 0:
            if killed:
                output = (
                    "THIS PROCESS HAS BEEN KILLED BY EXPLOITFARM DUE TO TIMEOUT\n-------- OUTPUT -------\n\n"
                    + output
                )
            g.attack_storage.add(
                flags,
                team["id"],
                start_time,
                end_time,
                AttackExecutionStatus.crashed,
                output,
            )
        elif flags:
            g.attack_storage.add(
                flags,
                team["id"],
                start_time,
                end_time,
                AttackExecutionStatus.done,
                output,
            )
        else:
            g.attack_storage.add(
                flags,
                team["id"],
                start_time,
                end_time,
                AttackExecutionStatus.noflags,
                output,
            )
    except Exception as e:
        traceback.print_exc()
        qprint(f"Failed to process sploit output: {repr(e)}")
        return 0
    return len(flags)


def read_and_print(stdout: io.BytesIO, buffer: io.BytesIO):
    # Read stdout line by line in a separate thread
    for line in iter(stdout.readline, b""):
        qprint(
            line.decode("utf-8", errors="replace"), end=""
        )  # Print to main stdout in real-time
        buffer.write(line)
        buffer.flush()
    buffer.write(stdout.read())
    stdout.close()


def launch_sploit(
    team: dict, stream_output: bool = False, exit_event: threading.Event | None = None
) -> tuple[subprocess.Popen, int, callable]:
    # Exploit execution process

    # For sploits written in Python, this env variable forces the interpreter to flush
    # stdout and stderr after each newline. Note that this is not default behavior
    # if the sploit's output is redirected to a pipe.
    env = os.environ.copy()
    env["PYTHONUNBUFFERED"] = "1"
    env["XFARM_HOST"] = team["host"]
    env["XFARM_TEAM"] = orjson.dumps(team).decode()
    env["XFARM_EXPLOIT_ID"] = str(g.exploit_config.uuid)
    env["XFARM_REMOTE_URL"] = get_url_from_config("", g.exec.config)
    if g.exec.config.server.auth_key:
        env["XFARM_LOGIN_TOKEN"] = g.exec.config.server.auth_key

    # Command to run the exploit
    command = f"{g.exploit_config.interpreter} {g.exploit_config.run}".strip()
    need_close_fds = not os_windows

    proc = None
    if os_windows:
        with g.ctrl_c_win.skip_ctrl_c_handling():
            proc = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                close_fds=need_close_fds,
                env=env,
                shell=True,
            )
            nicenessify(pid=proc.pid)
    else:
        proc = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            close_fds=need_close_fds,
            env=env,
            shell=True,
            preexec_fn=nicenessify,
        )

    read_function = None
    if stream_output:
        pipe = proc.stdout
        buffer = io.BytesIO()
        thr = threading.Thread(target=read_and_print, args=(pipe, buffer))
        thr.start()

        def func():
            thr.join()
            proc.stdout.close()
            value = buffer.getvalue()
            buffer.close()
            return value

        read_function = func

    if not read_function:

        def func():
            value = proc.stdout.read()
            proc.stdout.close()
            return value

        read_function = func

    return (
        proc,
        g.instance_storage.register_start(
            proc, exit_event=exit_event, target=team["host"]
        ),
        read_function,
    )


def run_sploit(
    team: dict,
    static_max_runtime: float | None = None,
    stream_output: bool = False,
    exit_event: threading.Event | None = None,
):
    if exit_event is None:
        exit_event = threading.Event()
    # Set the low priority of the process
    nicenessify()
    # Set the attack init time to send for stats
    start_declared_time = dt_now()
    # Quit if exit event is set
    if g.exec.exit_event.is_set():
        return

    # Set in shared memory execution status and running the exploit
    set_attack_exec(team["id"], True)
    try:
        proc, instance_id, read_data = launch_sploit(
            team, stream_output, exit_event=exit_event
        )
    except Exception as e:
        # Catching possible errors
        error_text = traceback.format_exc()
        qprint(error_text)
        if isinstance(e, FileNotFoundError):
            qprint(f"Sploit file or the interpreter for it not found: {repr(e)}")
        else:
            # Add failed attack (for stats and analysis)
            g.attack_storage.add(
                [],
                team["id"],
                start_declared_time,
                None,
                AttackExecutionStatus.crashed,
                error_text,
            )
            qprint(f"Failed to run sploit: {repr(e)}")
        return

    # Calculating initial timeout (useful if the exploit exists instantly to recalculate virtual time)
    dynamic_timeout = calc_exec_timeout()
    try:
        # Monitoring loop for the exploit
        need_kill = False
        try:
            start_time_exec = start_declared_time.timestamp()
            for _ in once_in_a_period(0.1):
                # If the process is not running, break the loop with no kill needed
                if proc.poll() is not None:
                    break
                # If the global or local exit event is set, kill the process
                if g.exec.exit_event.is_set() or exit_event.is_set():
                    need_kill = True
                    break
                # Time used by the process
                consumed_time = time.time() - start_time_exec
                # If a static timeout has been required, check if the time has passed
                if static_max_runtime:
                    if static_max_runtime - consumed_time <= 0:
                        need_kill = True
                        break
                else:
                    # Applying 2 timeouts independently:
                    # 1. The deadline timeout (the time until the end of the round)
                    # 2. The dynamic timeout (the time available for the exploit that changes dynamically and based on the consumed time)
                    deadline_timeout = calc_deadline_timeout()
                    dynamic_timeout = calc_exec_timeout()
                    if deadline_timeout <= 0 or dynamic_timeout - consumed_time <= 0:
                        need_kill = True
                        break
        except subprocess.TimeoutExpired:
            need_kill = True

        # If the process exited normally, add the time remaining to the virtual time
        if not need_kill:
            consumed_time = time.time() - start_time_exec
            g.virtual_time_available += dynamic_timeout - consumed_time

        # Kill the exploit
        with g.instance_storage.lock:
            proc.kill()

        set_attack_exec(team["id"], False)

        # Processing and filtering the output of the exploit
        n_flags = process_sploit_filter(
            proc, team, start_declared_time, need_kill, read_data, not stream_output
        )
        g.instance_storage.register_stop(instance_id)
        try:
            if is_group_attack():
                response: MessageResponse = skio_call(
                    "event-group",
                    GroupResponseEventClient(
                        client=str(g.exec.config.client_id),
                        group_id=g.exec.group["id"],
                        event=GroupEventResponseType.ATTACK_ENDED,
                        data={"target": team["host"], "n_flags": n_flags},
                    ),
                    MessageResponse,
                )

                if response.status != ResponseStatus.OK:
                    raise APIException(
                        f"Failed to send attack ended event: {response.message}"
                    )
        except Exception as e:
            qprint(traceback.format_exc())
            qprint(f"Failed to send attack ended event: {repr(e)}")
    except Exception as e:
        qprint(traceback.format_exc())
        qprint(f"Failed to finish sploit: {repr(e)}")


def current_tick_calc():
    this_time = dt_now()
    start_time = dateutil.parser.parse(g.exec.config.status["config"]["START_TIME"])
    if start_time > this_time:
        raise Exception("Attack not started yet")
    return math.floor((this_time - start_time).total_seconds() / g.exec.tick_duration)


def calc_wait_time_until_start():
    declared_start_time = g.exec.config.status["config"]["START_TIME"]
    if not declared_start_time:
        return 0
    start_time = dateutil.parser.parse(declared_start_time)
    if start_time > dt_now():
        return (start_time - dt_now()).total_seconds()
    else:
        return 0


def wait_until_start():
    # Recalculate timeout if contig changes
    while True:
        timeout = calc_wait_time_until_start()
        if timeout <= 0:
            return
        result = g.exec.config_update_queue.get(
            timeout=timeout
        )  # If the config is updated, all attacks will be "restarted"
        if result == "shutdown":
            return


def calc_round_time_available():
    # Needed to calculate the initial time based on attack schedule logic
    this_time = dt_now()
    match g.exec.attack_mode:
        case AttackMode.TICK_DELAY:
            return g.exec.tick_duration
        case AttackMode.WAIT_FOR_TIME_TICK:
            start_time = dateutil.parser.parse(
                g.exec.config.status["config"]["START_TIME"]
            )
            next_tick = current_tick_calc() + 1
            next_time = (
                start_time
                + timedelta(seconds=g.exec.tick_duration * next_tick)
                + timedelta(
                    seconds=g.exec.config.status["config"]["ATTACK_TIME_TICK_DELAY"]
                )
            )
            return (next_time - this_time).total_seconds()
        case AttackMode.LOOP_DELAY:
            return g.exec.config.status["config"]["LOOP_ATTACK_DELAY"]


def get_teams():
    try:
        return deepcopy(g.exec.config.status["teams"])
    except Exception as e:
        qprint(f"Can't get teams from the server: {repr(e)}")
        return []


def calc_exec_timeout() -> float | int:
    if is_group_attack():
        return g.dynamic_attack_timeout

    tick_duration = g.exec.tick_duration

    if g.tot_teams == 0:
        g.exec.info.runtime_timeout = tick_duration
        return tick_duration

    # virtual time / teams
    result = g.exec.info.runtime_timeout = min(
        math.ceil(g.virtual_time_available / g.tot_teams), tick_duration
    )
    return result


def calc_deadline_timeout():
    return (g.attack_round_deadline - dt_now()).total_seconds()


def is_group_attack():
    return g.exec.group is not None


def standalone_executor():
    while True:
        # Wait until the game starts
        wait_until_start()
        # Re-init virtual time available
        time_available = calc_round_time_available()
        # Set the round deadline
        g.attack_round_deadline = g.exec.info.next_attack_at = dt_now() + timedelta(
            seconds=time_available
        )
        # Set initial virtual time
        g.virtual_time_available = time_available * g.exec.pool_size
        # Collect the teams to attack
        teams = get_teams()
        random.shuffle(teams)
        g.tot_teams = len(teams)

        for team in teams:
            # Reset status
            set_attack_exec(team["id"], False)

        def teams_sorter(team):
            team_info = get_team_info(team["id"])
            return team_info.flags

        teams.sort(key=teams_sorter, reverse=True)
        # Full the pool with the attacks task
        for team in teams:
            g.thread_pool.submit(run_sploit, team)

        # Wait for next attack loop
        try:
            timeout = max((g.attack_round_deadline - dt_now()).total_seconds(), 0)
            result = g.exec.config_update_queue.get(
                timeout=timeout
            )  # If the config is updated, all attacks will be "restarted"
            if result == "shutdown":
                return
        except Empty:
            pass
        except Exception:
            qprint(traceback.format_exc())
        finally:
            qprint("Attack round finished, killing all remaining attacks")
            qprint(g.exec.info.teams)
            g.instance_storage.killall()


def skio_message_handler(event):
    try:
        if is_group_attack():
            event = GroupRequestEvent.model_validate(event)
            g.exec.shared_attack_queue.put(event)
    except ValidationError:
        qprint("Unhandled event from skio:", event)


def update_deadline_timeout(deadline: dt | str):
    if isinstance(deadline, str):
        deadline = dateutil.parser.parse(deadline)
    g.exec.info.next_attack_at = g.attack_round_deadline = deadline


def update_dynamic_timeout(timeout: int):
    g.exec.info.runtime_timeout = g.dynamic_attack_timeout = timeout


def update_group_running_status(running: bool):
    g.exec.info.group_running = running


def exploit_pull_latest():
    data = g.exec.config.reqs.exploit_source_log(g.exploit_config.uuid)
    if len(data) == 0:
        qprint("Can't find any commit for this exploit, stopping the attack")
        shutdown()
    commit_info = data[0][0]

    def callback(title, downloaded, total):
        if total is None or downloaded is None:
            g.exec.info.info_text = "[red]" + title
        elif downloaded == total:
            g.exec.info.info_text = "[yellow]Decompressing source"
        else:
            g.exec.info.info_text = "[red]" + title + f" {(downloaded/total)*100:.2f}%"

    sourcetar = g.exec.config.reqs.download_exploit_source(
        commit_info["hash"], loading_callback=callback
    )
    clear_exploit_folder(".")
    sourcetar.extractall(".")
    sourcetar.close()
    g.exec.info.info_text = None


def attack_group_executor():
    while True:
        action = g.exec.shared_attack_queue.get()
        if action == "shutdown":
            return
        elif action == "start_group" or action == "stop_group":
            response: MessageResponse = skio_call(
                "event-group",
                GroupResponseEventClient(
                    client=str(g.exec.config.client_id),
                    group_id=g.exec.group["id"],
                    event=GroupEventResponseType.SET_RUNNING_STATUS,
                    data={"running": action == "start_group"},
                ),
                MessageResponse,
            )

            if response.status != ResponseStatus.OK:
                print(response)
                raise APIException(
                    f"Failed to start/stop the attack: {response.message}"
                )
        elif isinstance(action, GroupRequestEvent):
            match action.event:
                case GroupEventRequestType.DEADLINE_TIMOEOUT:
                    update_deadline_timeout(action.data["deadline"])
                case GroupEventRequestType.DYNAMIC_TIMEOUT:
                    update_dynamic_timeout(action.data["timeout"])
                case GroupEventRequestType.KILLALL_ATTACKS:
                    g.instance_storage.killall()
                case GroupEventRequestType.ATTACK_REQUEST:
                    g.thread_pool.submit(run_sploit, action.data["target"])
                case GroupEventRequestType.ATTACK_KILL:
                    g.instance_storage.kill_by_target(action.data["target"])
                case GroupEventRequestType.RUNNING_STATUS:
                    update_group_running_status(action.data["running"])
                case GroupEventRequestType.EXPLOIT_PULL:
                    exploit_pull_latest()
                case _:
                    qprint(f"Unhandled event from skio: {action}")


def xploit(path: str):
    # Init xploit actions
    init_xploit_actions(path)
    # Bulk submitter to exploitfarm server
    threading.Thread(target=run_post_loop).start()
    # Create the pool of workers (threads are used only to manage the real processes that execute the exploits)
    g.thread_pool = ThreadPoolExecutor(
        max_workers=g.exec.pool_size, thread_name_prefix="sploit"
    )
    try:
        if is_group_attack():
            attack_group_executor()
        else:
            standalone_executor()
    except KeyboardInterrupt:
        qprint("Keyboard interrupt received!")
    except Exception:
        qprint(traceback.format_exc())
    except TimeoutError:
        qprint("Timeout error from server!")
    finally:
        shutdown()


def run_printer_queue():
    try:
        while True:
            # If the exit event is set, return
            if g.exec.exit_event.is_set():
                return
            print(g.exec.print_queue.get(), end="")
    except Exception:
        pass


def shutdown(restart: bool = False):
    "Shutdown the exploit execution"

    # Shutdown has already been called
    if g._shutdown:
        return
    # Set the shutdown flag
    g._shutdown = True

    # Stop the exploit execution
    g.exec.exit_event.set()
    # Disconnect from the socket io
    g.exec.config.skio.disconnect()

    # Send to all waiting queues the shutdown signal
    g.exec.shared_attack_queue.put("shutdown")
    g.exec.config_update_queue.put("shutdown")

    try:
        __loop_post_flags()
    except Exception:
        qprint("Failed to post remaining data to the server")

    # Trigger exploit stop on the server if possible (if not it will be setted as stoppped automatically later)
    # This is only usefull for an instant update of the status
    if not is_group_attack():
        try:
            g.exec.config.reqs.exploit_stop(g.exploit_config.uuid)
        except Exception:
            pass
    # Kill all child processes (so consume_sploit_ouput and run_sploit also will stop)
    if g.instance_storage:
        g.instance_storage.killall()

    # If a restart is requested, set the restart event
    if restart:
        g.exec.restart_event.set()

    # Wait for the pool to finish
    g.exec.print_queue.put("Stopping exploit execution..")
    if g.thread_pool:
        g.thread_pool.shutdown(wait=True, cancel_futures=True)

    # Try to save unsubmitted flags if possible (to send to the server later)
    try:
        attacks = g.attack_storage.pick_attacks()
        data = {"server_id": g.server_id, "queue": attacks}
        if attacks:
            with open(".flag_queue.json", "wb") as f:
                f.write(orjson.dumps(data))
        else:
            if os.path.exists(".flag_queue.json"):
                os.remove(".flag_queue.json")
    except Exception:
        pass

    dumpstacks()


def xploit_one(exec_info: AttackStartConfig, team: str, timeout: float = 30):
    # Start a single attack (test attack)
    g.exec = exec_info
    init_xploit_actions(exec_info.exploit_path)
    try:
        # Allow running the attack also without the configs
        try:
            g.exec.config.fetch_status()
        except Exception as e:
            qprint(f"[bold yellow]Can't get config from the server: {repr(e)}")

        threading.Thread(target=run_printer_queue).start()
        run_sploit({"id": 0, "host": team}, timeout, stream_output=True)

        # Try to filter and submit flags with latest config saved if that's possible
        try:
            while True:
                attacks = g.attack_storage.pick_attacks()
                if len(attacks) == 0:
                    break
                for attack in attacks:
                    if len(attack["flags"]) > 0:
                        g.exec.config.reqs.submit_flags({"flags": attack["flags"]})
                    g.attack_storage.mark_as_sent(1)
                    if len(attack["flags"]) > 0:
                        qprint(
                            f"Submitted {len(attack['flags'])} flags as manual submissions."
                        )
        except Exception:
            qprint("[bold yellow]Can't submit flags due missing config")
    except KeyboardInterrupt:
        pass
    finally:
        shutdown()


def disconnected_from_server():
    # Check if the exploit is disconnected from the server
    g.exec.info.config_update = False
    qprint("Disconnected from the server!")
    if is_group_attack():
        qprint("CRITICAL: Client missing connection with attack manager")
        shutdown()


def connected_to_server():
    # Check if the exploit is connected to the server
    g.exec.info.config_update = True
    qprint("Connected to the server!")


def skio_call(method: str, data, response_model: BaseModel) -> BaseModel:
    if isinstance(data, BaseModel):
        data = json_like(data, unset=True)
    response = g.exec.config.skio.call(method, data)
    return response_model.model_validate(response)


def start_xploit(exec_info: AttackStartConfig) -> threading.Thread:
    g.exec = exec_info

    # socket io update stream connection
    g.exec.config.skio.on("config", update_server_config)
    g.exec.config.skio.on("error_warning", update_warnings)
    g.exec.config.skio.on("disconnect", disconnected_from_server)
    g.exec.config.skio.on("connect", connected_to_server)
    g.exec.config.skio.on("message", skio_message_handler)
    if not is_group_attack():
        g.exec.config.skio.on("team", update_server_config)
    else:
        g.exec.config.skio.on("attack_group", attack_group_updater)

    g.exec.config.skio_connect()

    if is_group_attack():
        try:
            join_response: MessageResponse[JoinRequestResponse] = skio_call(
                "join-group",
                JoinRequestClient(
                    client=str(g.exec.config.client_id),
                    group_id=g.exec.group["id"],
                    queue_size=g.exec.pool_size,
                ),
                MessageResponse[JoinRequestResponse],
            )

            if join_response.status != ResponseStatus.OK:
                if join_response.status == ResponseStatus.ERROR:
                    qprint(f"Can't join the group: {join_response.message}")
                    shutdown()
                    return
                else:
                    raise APIException(
                        f"Can't join the group due to {join_response.message}"
                    )
            update_deadline_timeout(join_response.response.deadline)
            update_dynamic_timeout(join_response.response.timeout)
            update_group_running_status(join_response.response.running)
        except Exception:
            qprint(traceback.format_exc())
            qprint("Can't connect to the server! for join")
            shutdown()
            return

    thr = threading.Thread(target=xploit, args=(exec_info.exploit_path,))
    thr.start()
    return thr
