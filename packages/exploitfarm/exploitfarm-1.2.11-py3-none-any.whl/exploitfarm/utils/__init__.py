import os
import socket
from fasteners import InterProcessLock
import sys
import psutil
import tarfile
import dirhash
import threading
import traceback
from exploitfarm import __version__
from typing import List
from pydantic import BaseModel

DEFAULT_SERVER_PORT = 5050
DEV_MODE = __version__ == "0.0.0"
EXCLUDE_FILE_EXPLOIT_TAR = [".flag_queue.json"]
XPLOIT_DEBUG = os.getenv("XPLOIT_DEBUG", "0") in ["1", "true", "True"]


class ExploitFarmClientError(Exception):
    pass


def parse_address(address: str, default_port: int | None = None) -> tuple[str, int]:
    parts = address.split(":")
    address = parts[0].strip()
    port = int(parts[1]) if len(parts) > 1 else default_port
    if port is None:
        raise ValueError("Port is required")
    return address, port


def mem_usage() -> float:
    mem_stats = psutil.virtual_memory()
    return round((mem_stats.used / mem_stats.total) * 100, 1)


def try_tcp_connection(
    address: str, timeout: float | None = 3
) -> tuple[bool, str | None]:
    address, port = parse_address(address, default_port=DEFAULT_SERVER_PORT)
    s = socket.socket()
    try:
        s.settimeout(timeout)
        s.connect((address, port))
    except Exception as e:
        return False, f"Connection to {address}:{port} Failed: {e}"
    finally:
        s.close()
    return True, None


def create_lock(name: str) -> InterProcessLock:
    file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), name)
    base_path = os.path.dirname(file_path)
    if not os.path.exists(base_path):
        os.makedirs(base_path)
    return InterProcessLock(file_path)


def restart_program():
    """Restarts the current program, with file objects and descriptors
    cleanup
    """

    try:
        p = psutil.Process(os.getpid())
        for handler in p.get_open_files() + p.connections():
            os.close(handler.fd)
    except Exception:
        pass

    python = sys.executable
    os.execl(python, python, *sys.argv)


def make_tarfile(output_filename, source_dir):
    with tarfile.open(output_filename, "w:gz") as tar:
        tar.add(source_dir, arcname=os.path.basename(source_dir))


def calc_hash(path) -> str:
    return dirhash.dirhash(path, "sha256", ignore=EXCLUDE_FILE_EXPLOIT_TAR)


def exploit_tar_filter(tarinfo):
    if os.path.basename(tarinfo.name) in EXCLUDE_FILE_EXPLOIT_TAR:
        return None
    else:
        return tarinfo


def clear_exploit_folder(path: str):
    for root, dirs, files in os.walk(path):
        for file in files:
            if file not in EXCLUDE_FILE_EXPLOIT_TAR:
                os.remove(os.path.join(root, file))
        for dir in dirs:
            os.rmdir(os.path.join(root, dir))


def dumpstacks():
    if not XPLOIT_DEBUG:
        return
    id2name = dict([(th.ident, th.name) for th in threading.enumerate()])
    code = []
    for threadId, stack in sys._current_frames().items():
        code.append("\n# Thread: %s(%d)" % (id2name.get(threadId, ""), threadId))
        for filename, lineno, name, line in traceback.extract_stack(stack):
            code.append('File: "%s", line %d, in %s' % (filename, lineno, name))
            if line:
                code.append("  %s" % (line.strip()))
    with open("stacktrace.log", "w") as f:
        f.write("\n".join(code))


def _json_like(
    obj: BaseModel,
    unset=False,
    convert_keys: dict[str, str] | None = None,
    exclude: list[str] | None = None,
    mode: str = "json",
):
    res = obj.model_dump(mode=mode, exclude_unset=not unset)
    if convert_keys:
        for from_k, to_k in convert_keys.items():
            if from_k in res:
                res[to_k] = res.pop(from_k)
    if exclude:
        for ele in exclude:
            if ele in res:
                del res[ele]
    return res


def json_like(
    obj: BaseModel | List[BaseModel],
    unset=False,
    convert_keys: dict[str, str] = None,
    exclude: list[str] = None,
    mode: str = "json",
) -> dict:
    if isinstance(obj, list):
        return [
            _json_like(
                ele, unset=unset, convert_keys=convert_keys, exclude=exclude, mode=mode
            )
            for ele in obj
        ]
    return _json_like(
        obj, unset=unset, convert_keys=convert_keys, exclude=exclude, mode=mode
    )
