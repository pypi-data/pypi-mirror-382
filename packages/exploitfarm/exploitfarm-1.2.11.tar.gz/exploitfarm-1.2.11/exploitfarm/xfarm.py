#!/usr/bin/env python3

import typer
from rich import print
from rich.markup import escape
from rich.console import Console


from typer import Exit
from enum import Enum
from exploitfarm.utils.reqs import get_url
from exploitfarm.tui.config import (
    InitialConfiguration,
    inital_config_setup,
    ClientConfig,
)
from exploitfarm.tui.login import login_required, try_authenticate
from exploitfarm.tui.exploitinit import ExploitConf
from exploitfarm.tui.exploitdownload import ExploitDownload
from exploitfarm.utils.config import (
    ExploitConfig,
    check_exploit_config_exists,
    generate_exploit_folder_name,
)
import getpass
import re
import os
import orjson
from pydantic import PositiveInt
from typing import Optional
from uuid import UUID
from exploitfarm.models.enums import Language
from exploitfarm.utils import restart_program, ExploitFarmClientError
from exploitfarm.tui.startxploit import start_exploit_tui
from exploitfarm.utils.reqs import ReqsError
from requests.exceptions import Timeout as RequestsTimeout
from exploitfarm.utils import DEV_MODE, clear_exploit_folder
import multiprocessing
from exploitfarm import __version__
import traceback
from rich.progress import Progress
from dateutil import parser as dtparser
from rich.rule import Rule
from exploitfarm.utils.cmd import create_new_attack_group
from exploitfarm.tui.group_prejoin import GroupPreJoin
from exploitfarm.utils.config import AttackStartConfig

app = typer.Typer(
    no_args_is_help=True, context_settings={"help_option_names": ["-h", "--help"]}
)
exploit = typer.Typer(
    no_args_is_help=True,
    context_settings={"help_option_names": ["-h", "--help"]},
    help="Exploit Managment commands",
)
config = typer.Typer(
    no_args_is_help=True,
    context_settings={"help_option_names": ["-h", "--help"]},
    help="Configuration commands",
)

group = typer.Typer(
    no_args_is_help=True,
    context_settings={"help_option_names": ["-h", "--help"]},
    help="Attack group commands",
)

app.add_typer(exploit, name="exploit")
app.add_typer(config, name="config")
app.add_typer(group, name="group")
console = Console()


def close_cli(code: int = 1):
    raise Exit(code)


class g:
    interactive = True
    config: ClientConfig = ClientConfig.read()
    initial_setup_executed = False


def tuple_version(version):
    return tuple(map(int, version.split(".")))


def handle_service_not_found(exploit_config: ExploitConfig):
    if not g.interactive:
        print(f"[bold red]Service {escape(str(exploit_config.service))} not found[/]")
        close_cli()
    print(
        f"[bold red]Service {escape(str(exploit_config.service))} not found "
        "use 'xfarm init --edit'[/]"
    )
    decision = typer.confirm(
        "Do you want to continue run 'xfarm init --edit' ?", default=True
    )
    if decision:
        init(edit=True)
        restart_program()


def fast_check_exploit_conf_service(exploit_config: ExploitConf) -> ExploitConf:
    if exploit_config.service not in [
        UUID(ele["id"]) for ele in g.config.status["services"]
    ]:
        handle_service_not_found(exploit_config)
        close_cli()
    return exploit_config


def auto_push_is_safe(exploit_config: ExploitConfig):
    no_latest_groups = (
        len(
            [
                g
                for g in g.config.reqs.groups()
                if g["exploit"] == str(exploit_config.uuid) and g["commit"] == "latest"
            ]
        )
        == 0
    )
    if no_latest_groups:
        return True
    else:
        current_hash = exploit_config.hash()
        if current_hash in [
            ele["hash"] for ele in g.config.reqs.exploit_source_log(exploit_config.uuid)
        ]:  # If the current commit is pushed
            return True
        if g.interactive:
            return typer.confirm(
                "There are attack groups that are using the latest commit, "
                "this command is trying to push a new version of the exploit. "
                "Do you want to continue?",
                default=False,
            )
        return False


def initial_setup(login=True, require_running=False):
    if g.initial_setup_executed:
        return True
    connection = inital_config_setup(g.config, interactive=g.interactive)
    if g.config.status["version"] != __version__ and __version__ != "0.0.0":
        print(
            "[bold yellow]The server version is different from the client version! "
            "This may cause problems![/]"
        )
        print(
            f"[bold yellow]Server version: {g.config.status['version']}, Client version: {__version__}[/]"
        )
        if not typer.confirm("Do you want to continue?", default=False):
            close_cli()
    if require_running and g.config.status["status"] == "setup":
        print(
            "[bold red]The server is in setup mode, "
            "you need to configure it before using this command![/]"
        )
        close_cli()
    if DEV_MODE:
        print("[bold yellow]Development mode detected!")
    if login and connection:
        login_required(g.config, interactive=g.interactive)
    g.initial_setup_executed = True
    return connection


@config.command(help="Edit the client settings")
def edit(
    address: str = typer.Option(None, help="The address of the server"),
    port: int = typer.Option(None, help="The port of the server"),
    nickname: str = typer.Option(None, help="The nickname of this client"),
    https: bool = typer.Option(False, help="Use HTTPS for the connection"),
):
    if g.interactive:
        init_config = InitialConfiguration(g.config)
        if init_config.run() == 0:
            print("[bold green]Configuration saved![/]")
        else:
            print("[bold red]Configuration cancelled[/]")
    else:
        if address:
            g.config.server.address = address
        if port:
            g.config.server.port = port
        if nickname:
            g.config.client_name = nickname
        if https:
            g.config.server.https = https
        elif not g.config.test_server():
            print(
                f"[bold red]Connection test failed to {escape(get_url('//', g.config))}[/]"
            )
            close_cli()
        g.config.write()
        print("[bold green]Config updated[/]")


@config.command(help="Reset the client settings")
def reset():
    print(
        "[bold yellow]Are you sure you want to reset configs?\n[bold red]"
        "This operation may break some exploits running on the client.",
        end="",
    )
    delete = typer.confirm("")
    if delete:
        ClientConfig().write()
        print("[bold green]Client resetted successful[/]")
    else:
        print("[bold]Reset cancelled[/]")


@app.command(help="Start the exploit")
@exploit.command(help="Start the exploit")
def start(
    path: str = typer.Argument(".", help="The path of the exploit"),
    pool_size: PositiveInt = typer.Option(
        multiprocessing.cpu_count() * 10,
        "--pool-size",
        "-p",
        help="Use fixed thread pool size for the exploit",
    ),
    submit_pool_timeout: PositiveInt = typer.Option(
        3,
        help="The timeout for the submit pool to wait "
        "for new attack results and send flags",
    ),
    test: Optional[str] = typer.Option(None, "--test", "-t", help="Test the exploit"),
    test_timeout: PositiveInt = typer.Option(30, help="The timeout for the test"),
    no_auto_push: bool = typer.Option(
        False,
        "--no-auto-push",
        "-n",
        help="Don't push the exploit source before starting the exploit",
    ),
    push_message: Optional[str] = typer.Option(
        None, "--push-message", "-m", help="The message of the push"
    ),
):
    path = os.path.abspath(path)
    from exploitfarm.xploit import start_xploit, shutdown, xploit_one

    if not os.path.isdir(path):
        print(f"[bold red]Path {escape(path)} not found[/]")
        close_cli()

    if not check_exploit_config_exists(path):
        print(
            f"[bold red]Exploit configuration not found in {escape(path)} | "
            "Tip: use 'xfarm exploit init' to inizialize an exploit source project![/]"
        )
        close_cli()

    exec_config = AttackStartConfig(
        config=g.config,
        pool_size=pool_size,
        exploit_path=path,
        submit_pool_timeout=submit_pool_timeout,
    )

    if test:
        xploit_one(exec_config, test, test_timeout)
        close_cli()

    if not initial_setup(require_running=True):
        print(
            "[bold red]Can't connect to the server! "
            "The server is needed to start the exploit! Configure with 'xfarm config'[/]"
        )
        close_cli()

    try:
        exploit_config = ExploitConfig.read(exec_config.exploit_path)
    except Exception as e:
        traceback.print_exc()
        print(f"[bold red]Error reading exploit configuration from {path}: {e}[/]")
        close_cli()
    # Auto push exploit (if not in test mode)
    if not no_auto_push and not test:
        try:
            if auto_push_is_safe(exploit_config):
                push(push_message, force=False)
            else:
                print("[bold yellow]Skipping the auto-push of the source[/]")
        except Exception:
            pass

    try:
        fast_check_exploit_conf_service(exploit_config)
        exploit_config.publish_exploit(g.config)
    except Exception as e:
        traceback.print_exc()
        print(f"[bold red]Error reading exploit configuration from {path}: {e}[/]")
        close_cli()

    if not exploit_config.lock_exploit():
        print(
            "[bold yellow]⚠️ Exploit is already running, do you want to continue? "
            "(This process will not be tracked)[/]",
            end="",
        )
        cont = typer.confirm("", default=False)
        if not cont:
            print("[bold red]Operation cancelled[/]")
            close_cli()

    start_xploit(exec_config)

    if g.interactive:
        start_exploit_tui(exec_info=exec_config, exploit_config=exploit_config)
    else:
        try:
            while True:
                print(exec_config.print_queue.get())
        except KeyboardInterrupt:
            print("[bold yellow]Shutting down the exploit[/]")
            shutdown()
    if exec_config.restart_event.is_set():
        print("[bold yellow]Restarting the exploit[/]")
        restart_program()


@config.command(help="Login to the server")
def login(
    password: str = typer.Option(None, help="The password of the user"),
    stdin: bool = typer.Option(False, help="Read the password from stdin"),
):
    initial_setup(login=False, require_running=True)

    if g.config.status["status"] == "setup":
        print("[bold red]Please configure the server first[/]")
        close_cli()
    if (
        g.config.status["loggined"]
        and not g.config.status["config"]["AUTHENTICATION_REQUIRED"]
    ):
        print("[bold green]Authentication is not required[/]")
        close_cli()
    if g.config.status["loggined"]:
        print("[bold green]Already logged in![/]")
        close_cli()

    if stdin or (not password and not g.interactive):
        if g.interactive:
            password = getpass.getpass("Password: ")
        else:
            password = input("Password: ")
        status, error = try_authenticate(password, g.config)
        if status:
            print("[bold green]Logged in![/]")
        else:
            print(f"[bold red]Error: {escape(error)}[/]")
        close_cli()

    if password:
        status, error = try_authenticate(password, g.config)
        if status:
            print("[bold green]Logged in![/]")
        else:
            print(f"[bold red]Error: {escape(error)}[/]")
        close_cli()

    login_required(g.config, interactive=g.interactive)


@config.command(help="Logout from the server")
def logout():
    g.config.server.auth_key = None
    g.config.write()
    print("[bold red]Logged out[/]")


@group.command(help="Create a new attack group")
def create(
    name: str = typer.Option(None, help="The name of the group"),
    current_commit: bool = typer.Option(
        False, help="Use the current commit of the exploit"
    ),
    submit_pool_timeout: PositiveInt = typer.Option(
        3,
        help="The timeout for the submit pool to "
        "wait for new attack results and send flags",
    ),
):
    from exploitfarm.tui.shared_attack_group import SharedAttackCreateGroup

    initial_setup(require_running=True)
    if not check_exploit_config_exists("."):
        print(
            "[bold red]You must be in an exploit folder! | "
            "Tip: use 'xfarm exploit init' to inizialize an exploit source project![/]"
        )
        close_cli()

    exploit_config = ExploitConfig.read(".")
    fast_check_exploit_conf_service(exploit_config)

    try:
        if auto_push_is_safe(exploit_config):
            push("[Automatic Push]: Group creation process", force=False)
        else:
            print(
                "[bold yellow]The source code must be pushed to start a shared attack![/]"
            )
            close_cli()
    except Exception:
        pass
    if g.interactive:
        result = SharedAttackCreateGroup(
            g.config, exploit_config, name=name, use_latest=not current_commit
        ).run()
    else:
        if name is None:
            print("[bold red]Please provide a group name![/]")
            close_cli()
        result = create_new_attack_group(
            name, exploit_config, not current_commit, g.config
        )
    if not result:
        print("[bold red]Operation cancelled[/]")
    else:
        print("[bold green]Attack group created![/]")
        if g.interactive:
            return join(
                group=result["id"],
                submit_pool_timeout=submit_pool_timeout,
                queue=None,
                trigger_start=False,
            )


@group.command(help="Join an attack group")
def join(
    group: str = typer.Option(None, help="The group id to join"),
    queue: int = typer.Option(None, help="The queue number to use int the group"),
    submit_pool_timeout: PositiveInt = typer.Option(
        3,
        help="The timeout for the submit pool to wait for new attack results and send flags",
    ),
    trigger_start: bool = typer.Option(False, help="Start the attack group after join"),
):
    from exploitfarm.tui.group_select import GroupSelect

    initial_setup(require_running=True)
    if check_exploit_config_exists("."):
        expl_config = ExploitConfig.read(".")
        expl_config.publish_exploit(g.config)  # Just to update the exploit on the server
        sources = g.config.reqs.exploit_source_log(expl_config.uuid)

        if len(sources) == 0:
            print(
                "[bold red]No commits found for this exploit! | Tip: use 'xfarm exploit push' to upload your exploit source[/]"
            )

        groups = [
            selected_group
            for selected_group in g.config.reqs.groups()
            if selected_group["exploit"] == str(expl_config.uuid)
        ]

        if len(groups) == 0:
            print(
                "[bold red]No groups found for this exploit! | Tip: create a new group with 'xfarm group create'[/]"
            )
            close_cli()

        expl_hash = expl_config.hash()
        related_sources = [source for source in sources if source["hash"] == expl_hash]
        if len(related_sources) == 0:
            print(
                "[bold red]No groups found for this commit! | Tip: create a new group with 'xfarm group create' or change commit with 'xfarm exploit move'[/]"
            )
            close_cli()

        expl_source_id = related_sources[0]["id"]

        def group_commit_correlated(selected_group):
            if selected_group["commit"] == "latest":
                return expl_source_id == sources[0]["id"]
            return expl_source_id == selected_group["commit"]

        groups = [
            selected_group
            for selected_group in groups
            if group_commit_correlated(selected_group)
        ]

        if len(groups) == 0:
            print(
                "[bold red]No groups found for this commit! | Tip: create a new group with 'xfarm group create' or change commit with 'xfarm exploit move'[/]"
            )
            close_cli()

        if group:
            selected_group = [ele for ele in groups if ele["id"] == group]
            if len(selected_group) == 0:
                print("[bold red]Group not found![/]")
                close_cli()

        if len(groups) == 1:
            selected_group = groups[0]
        else:
            if g.interactive:
                selected_group = GroupSelect(g.config, groups).run()
                if not selected_group:
                    print("[bold red]Operation cancelled[/]")
                    close_cli()
            else:
                print(
                    "[bold red]Multiple groups found, please select one with --group![/]"
                )
                close_cli()
    else:
        if g.interactive:
            # If the exploit configuration is not found, the user can select the exploit and this will be automatically downloaded
            selected_group = GroupSelect(g.config).run()
            if selected_group is None:
                print("[bold red]Operation cancelled[/]")
                close_cli()
            download_folder = generate_exploit_folder_name(selected_group["exploit"])
            download(
                exploit_id=selected_group["exploit"],
                commit_uuid=selected_group["commit"],
                folder=download_folder,
            )
            os.chdir(download_folder)
            expl_config = ExploitConfig.read(".")
            expl_config.publish_exploit(
                g.config
            )  # Just to update the exploit on the server
        else:
            print(
                "[bold red]Exploit configuration not found! | Tip: use 'xfarm exploit init' to inizialize an exploit source project![/]"
            )
            close_cli()

    if g.config.hashed_client_id in selected_group["members"]:
        print("[bold yellow]You are already joinned in this group![/]")
        close_cli()

    if g.interactive:
        queue = GroupPreJoin(g.config, selected_group, queue).run()

    if queue is None:
        print("[bold red]Please provide a queue number![/]")
        close_cli()

    from exploitfarm.xploit import start_xploit, shutdown

    exec_config = AttackStartConfig(
        config=g.config,
        pool_size=queue,
        exploit_path=".",
        submit_pool_timeout=submit_pool_timeout,
        group=selected_group,
    )

    if not expl_config.lock_exploit():
        print(
            "[bold yellow]⚠️ Exploit is already running, do you want to continue? (This process will not be tracked)[/]",
            end="",
        )
        cont = typer.confirm("", default=False)
        if not cont:
            print("[bold red]Operation cancelled[/]")
            close_cli()

    start_xploit(exec_config)

    if trigger_start:
        exec_config.shared_attack_queue.put("start_group")

    if g.interactive:
        start_exploit_tui(exec_info=exec_config, exploit_config=expl_config)
    else:
        try:
            while True:
                print(exec_config.print_queue.get())
        except KeyboardInterrupt:
            print("[bold yellow]Shutting down the exploit[/]")
            shutdown()
    if exec_config.restart_event.is_set():
        print("[bold yellow]Restarting the exploit[/]")
        restart_program()


@app.command(help="Test a submitter")
def submitter_test(
    path: str = typer.Argument(help="Submitter python script"),
    kwargs: str = typer.Option("{}", help="Submitter key-words args (json)"),
    output: str = typer.Argument(help="Text containing flags according to server REGEX"),
):
    initial_setup()
    try:
        kwargs = orjson.loads(kwargs)
    except Exception as e:
        print(f"[bold red]Invalid kwargs json: {e}")
        close_cli()

    try:
        with open(path, "rt") as f:
            submitter_code = f.read()
    except Exception as e:
        print(f"[bold red]File {escape(path)} not found: {e}")
        close_cli()

    if not output:
        print("[bold red]Output can't be empty")

    flags = [output]
    if g.config.status["config"]["FLAG_REGEX"]:
        flags = re.findall(g.config.status["config"]["FLAG_REGEX"], output)

    if len(flags) == 0:
        print(
            f"[bold red]No flags extracted from output! REGEX: {escape(g.config.status['config']['FLAG_REGEX'])}"
        )
        close_cli()
    submitter_id = None
    try:
        submitter_id: int = g.config.reqs.new_submitter(
            {
                "name": "TEST_SUBMITTER (Will be deleted soon)",
                "kargs": kwargs,
                "code": submitter_code,
            }
        )["id"]
        print("[bold yellow]----- TEST RESULTS -----")
        print("[bold yellow]Flags to submit:[/]", flags)
        print("[bold yellow]Output:[/]")
        print(g.config.reqs.test_submitter(submitter_id, flags))
        print("[bold yellow]----- TEST RESULTS -----")
    finally:
        if submitter_id:
            g.config.reqs.delete_submitter(submitter_id)


class StatusWhat(Enum):
    status = "status"
    submiters = "submitters"
    services = "services"
    exploits = "exploits"
    flags = "flags"
    teams = "teams"
    clients = "clients"


@app.command(help="Get status of the server")
def status(
    what: StatusWhat = typer.Argument(
        StatusWhat.status.value, help="Server informations type"
    ),
):
    initial_setup()
    match what:
        case StatusWhat.status:
            print(g.config.status)
        case StatusWhat.submiters:
            print(g.config.reqs.submitters())
        case StatusWhat.services:
            print(g.config.reqs.services())
        case StatusWhat.exploits:
            print(g.config.reqs.exploits())
        case StatusWhat.flags:
            print(g.config.reqs.flags())
        case StatusWhat.teams:
            print(g.config.reqs.teams())
        case StatusWhat.clients:
            print(g.config.reqs.clients())


@exploit.command(help="Edit an exploit (same of init -e)")
def edit(  # noqa: F811
    name: Optional[str] = typer.Option(None, help="The name of the exploit"),
    service: Optional[UUID] = typer.Option(None, help="The service of the exploit"),
    language: Optional[Language] = typer.Option(
        None, help="The language of the exploit"
    ),
):
    init(edit=True, name=name, service=service, language=language)


@exploit.command(help="Pushes the exploit source code to the server")
def push(
    message: Optional[str] = typer.Option(
        None, "--message", "-m", help="The message of the push"
    ),
    force: bool = typer.Option(False, "--force", "-f", help="Force the push"),
):
    initial_setup(require_running=True)

    if check_exploit_config_exists("."):
        fast_check_exploit_conf_service(ExploitConfig.read(".")).publish_exploit(
            g.config
        )  # Just to update the exploit on the server
        with Progress() as progress:
            upload_task = progress.add_task(
                "[red]Exploit Source", total=None, start=False
            )
            loading_task = None

            def callback(title, uploaded, total):
                nonlocal loading_task, upload_task
                if total is None or uploaded is None:
                    progress.update(
                        upload_task,
                        description="[red]" + title,
                        start=False,
                        total=None,
                        completed=None,
                    )
                elif uploaded == total:
                    if not loading_task:
                        progress.remove_task(upload_task)
                        upload_task = None
                        loading_task = progress.add_task(
                            "[yellow]Waiting for a server response...", total=None
                        )
                else:
                    progress.start_task(upload_task)
                    progress.update(
                        upload_task,
                        completed=uploaded,
                        total=total,
                        description="[red]" + title,
                    )

            g.config.reqs.upload_exploit_source(
                ".", message=message, force=force, loading_callback=callback
            )
        print("[bold green]Exploit source uploaded![/]")
    else:
        print(
            "[bold red]Exploit configuration not found! | Tip: use 'xfarm exploit init' to inizialize an exploit source project![/]"
        )


@exploit.command(help="Get infomations about the exploit sources versions")
def info(
    raw: bool = typer.Option(False, "--raw", "-r", help="Print the raw json response"),
):
    initial_setup(require_running=True)
    if check_exploit_config_exists("."):
        expl_conf = ExploitConfig.read(".")
        fast_check_exploit_conf_service(expl_conf)
        data = g.config.reqs.exploit_source_log(expl_conf.uuid)
        clients = g.config.reqs.clients()
        if raw:
            print(data)
        else:
            this_hash = expl_conf.hash()
            you_are_here = False
            print(
                f"[bold]Exploit Source Log of [underline]{escape(expl_conf.name)}[/] ([grey62]{escape(str(expl_conf.uuid))}[/])[/]\n"
            )
            if len(data) == 0:
                print(
                    "[bold red]No commits found! | Tip: use 'xfarm exploit push' to upload your exploit source[/]"
                )
                close_cli()
            for ele in data:
                pushed_at = escape(
                    dtparser.parse(ele["pushed_at"])
                    .astimezone()
                    .strftime("%Y-%m-%d %H:%M:%S")
                )
                message = (
                    "[grey62]" + escape(ele["message"]) + "[/]"
                    if ele["message"]
                    else "[italic]No message[/]"
                )
                commit_id = escape(str(ele["id"]))
                source_hash = "[grey54]" + escape(ele["hash"]) + "[/]"
                here = ele["hash"] == this_hash
                if not you_are_here and here:
                    print(Rule("Current Commit"))
                search_committer = [
                    client["name"]
                    for client in clients
                    if client["id"] == ele["pushed_by"]
                ]
                if search_committer:
                    commited_by = "[underline]" + escape(search_committer[0]) + "[/]"
                else:
                    commited_by = escape("[italic]Deleted Client[/]")
                print(
                    f"➤ Commit {commit_id} by {commited_by}\nat {pushed_at} hash: {source_hash}\nMessage: {message}"
                )
                if not you_are_here and here:
                    print(Rule())
                    you_are_here = True
                print()
    else:
        print(
            "[bold red]Exploit configuration not found! | Tip: use 'xfarm exploit init' to inizialize an exploit source project![/]"
        )


@exploit.command(help="Update to latest commit")
def update(
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="Force the move even if the current commit is not pushed",
    ),
):
    return move("latest", force=force)


@exploit.command(
    help="Download the exploit source code commit and replace the current one"
)
def move(
    commit_uuid: str = typer.Argument(..., help="The commit uuid to move"),
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="Force the move even if the current commit is not pushed",
    ),
):
    initial_setup(require_running=True)
    if check_exploit_config_exists("."):
        expl_conf = ExploitConfig.read(".")
        fast_check_exploit_conf_service(expl_conf)
        data = g.config.reqs.exploit_source_log(expl_conf.uuid)
        if len(data) == 0:
            print(
                "[bold red]No commits found! | Tip: use 'xfarm exploit push' to upload your exploit source[/]"
            )
            close_cli()

        if commit_uuid == "latest":
            commit_uuid = data[0]["id"]
        commit_info = [ele for ele in data if ele["id"] == commit_uuid]
        if not commit_info:
            print(f"[bold red]Commit {escape(commit_uuid)} not found![/]")
            close_cli()
        commit_info = commit_info[0]

        current_hash = expl_conf.hash()
        if commit_info["hash"] == current_hash:
            print("[bold yellow]The current commit is the same as the requested one![/]")
            close_cli()
        this_is_commited = any([ele["hash"] == current_hash for ele in data])
        if not this_is_commited and not force:
            print(
                "[bold red]The current commit is not pushed! Use --force to move anyway or push it before using this command[/]"
            )
            close_cli()
        with Progress() as progress:
            upload_task = progress.add_task(
                "[red]Exploit Source", total=None, start=False
            )
            loading_task = None

            def callback(title, downloaded, total):
                nonlocal loading_task, upload_task
                if total is None or downloaded is None:
                    progress.update(
                        upload_task,
                        description="[red]" + title,
                        start=False,
                        total=None,
                        completed=None,
                    )
                elif downloaded == total:
                    if not loading_task:
                        progress.remove_task(upload_task)
                        upload_task = None
                        loading_task = progress.add_task(
                            "[yellow]Decompressing source", total=None
                        )
                else:
                    progress.start_task(upload_task)
                    progress.update(
                        upload_task,
                        completed=downloaded,
                        total=total,
                        description="[red]" + title,
                    )

            sourcetar = g.config.reqs.download_exploit_source(
                commit_info["hash"], loading_callback=callback
            )
            clear_exploit_folder(".")
            sourcetar.extractall(".")
            sourcetar.close()
        print("[bold green]Exploit source updated![/]")
    else:
        print(
            "[bold red]Exploit configuration not found! | Tip: use 'xfarm exploit init' to inizialize an exploit source project![/]"
        )


@exploit.command(help="Download the exploit source")
def download(
    exploit_id: str = typer.Argument(None, help="The exploit id to download"),
    commit_uuid: str = typer.Argument(
        "latest", help="The commit uuid to take the source from"
    ),
    folder: str = typer.Option(
        None,
        "--folder",
        "-f",
        help="Custom folder name of the downloaded exploit source",
    ),
):
    initial_setup(require_running=True)
    if check_exploit_config_exists("."):
        print(
            "[bold yellow]This command has to be used outside exploit folders, if you want to update to last uploaded source use 'xfarm exploit update'[/]"
        )
        close_cli()
    if not exploit_id:
        if not g.interactive:
            print("[bold red]Please provide an exploit id![/]")
            close_cli()
        results = ExploitDownload(g.config).run()
        if not results:
            print("[bold red]Operation cancelled[/]")
            close_cli()
        exploit_id, commit_uuid = results

    exploit_info = g.config.reqs.exploits()
    exploit_info = [ele for ele in exploit_info if ele["id"] == exploit_id]
    if len(exploit_info) == 0:
        print(f"[bold red]Exploit {exploit_id} not found![/]")
        close_cli()
    exploit_info = exploit_info[0]
    data = g.config.reqs.exploit_source_log(exploit_id)
    if len(data) == 0:
        print(
            "[bold red]No commits found! | Tip: use 'xfarm exploit push' to upload your exploit source[/]"
        )
        close_cli()
    if commit_uuid == "latest":
        commit_uuid = data[0]["id"]
    commit_info = [ele for ele in data if ele["id"] == commit_uuid]
    if not commit_info:
        print(f"[bold red]Commit {escape(commit_uuid)} not found![/]")
        close_cli()
    commit_info = commit_info[0]
    if not folder:
        folder = generate_exploit_folder_name(
            exploit_info["name"], fallback=exploit_info["id"]
        )

    if os.path.exists(folder):
        print(f"[bold red]Folder {escape(folder)} already exists![/]")
        close_cli()
    os.makedirs(folder)

    with Progress() as progress:
        upload_task = progress.add_task("[red]Exploit Source", total=None, start=False)
        loading_task = None

        def callback(title, downloaded, total):
            nonlocal loading_task, upload_task
            if total is None or downloaded is None:
                progress.update(
                    upload_task,
                    description="[red]" + title,
                    start=False,
                    total=None,
                    completed=None,
                )
            elif downloaded == total:
                if not loading_task:
                    progress.remove_task(upload_task)
                    upload_task = None
                    loading_task = progress.add_task(
                        "[yellow]Decompressing source", total=None
                    )
            else:
                progress.start_task(upload_task)
                progress.update(
                    upload_task,
                    completed=downloaded,
                    total=total,
                    description="[red]" + title,
                )

        sourcetar = g.config.reqs.download_exploit_source(
            commit_info["hash"], loading_callback=callback
        )
        sourcetar.extractall(folder)
        sourcetar.close()
    print("[bold green]Exploit source downloaded![/]")


@app.command(help="Initiate a new exploit project")
@exploit.command(help="Initiate a new exploit project")
def init(
    edit: bool = typer.Option(
        False, "--edit", "-e", help="Edit the exploit configuration"
    ),
    name: Optional[str] = typer.Option(None, help="The name of the exploit"),
    service: Optional[UUID] = typer.Option(None, help="The service of the exploit"),
    language: Optional[Language] = typer.Option(
        None, help="The language of the exploit"
    ),
):
    initial_setup()
    if g.interactive:
        if edit:
            if check_exploit_config_exists("."):
                expl_conf = ExploitConfig.read(".")
                name = expl_conf.name
                service = expl_conf.service
                language = expl_conf.language
            else:
                print(
                    "[bold red]Exploit configuration not found! | Tip: use 'xfarm exploit init' to inizialize an exploit source project![/]"
                )
                close_cli()
            init_config = ExploitConf(g.config, edit, name, service, language)
        else:
            init_config = ExploitConf(g.config, edit)
        final_status = init_config.run()
        if final_status == 0:
            print(
                f"[bold green]Exploit configuration {'created' if not edit else 'edited'}![/]"
            )
        elif final_status == 99:
            print(
                "[bold yellow]Exploit folder created, but not registered on the server![/]"
            )
        else:
            print("[bold red]Exploit configuration cancelled[/]")
    else:
        exists = check_exploit_config_exists(name if not edit else ".")

        if edit ^ exists:
            print(f"[bold red]Exploit '{escape(name)}' already exists!")
            close_cli()

        if not name or edit:
            print("[bold red]Please provide a valid name for the exploit[/]")
            close_cli()

        try:
            if service not in [UUID(ele["id"]) for ele in g.config.status["services"]]:
                service = None
                if not edit:
                    print("[bold red]Service not found, add a new on the server[/]")
                    close_cli()
        except Exception:
            print("[bold red]Service id not found[/]")
            close_cli()

        if not language or edit:
            print("[bold red]Language not found[/]")
            close_cli()

        if edit:
            expl_conf = ExploitConfig.read(name)
            if name:
                expl_conf.name = name
            if language:
                expl_conf.language = language
            if service:
                expl_conf.service = service
        else:
            expl_conf = ExploitConfig.new(name, language, service)
        expl_conf.write()
        expl_conf.publish_exploit(g.config)
        if edit:
            print("[bold green]Exploit configuration updated![/]")
        else:
            print("[bold green]Exploit configuration created![/]")


def version_callback(verison: bool):
    if verison:
        print(__version__, "Development Mode" if DEV_MODE else "Release")
        raise typer.Exit()


def help_callback(help: bool):
    if help:
        raise typer.Exit()


@app.callback()
def main(
    no_interactive: bool = typer.Option(
        False,
        "--no-interactive",
        "-I",
        help="Interactive configuration mode",
        envvar="XFARM_INTERACTIVE",
    ),
    verison: bool = typer.Option(
        False,
        "--version",
        "-v",
        help="Show the version of the client",
        callback=version_callback,
    ),
):
    g.interactive = not no_interactive


def run():
    try:
        app()
    except KeyboardInterrupt:
        print("[bold yellow]Operation cancelled[/]")
    except ReqsError as e:
        print(f"[bold red]The server returned an error: {e}[/]")
    except RequestsTimeout as e:
        print(f"[bold red]The server has timed out: {e}[/]")
    except ExploitFarmClientError as e:
        print(f"[bold red]Error: {e}[/]")


if __name__ == "__main__":
    run()
