import os
import toml
import string
import socketio
import traceback
from pydantic import BaseModel, Field, validate_call
from uuid import UUID, uuid4
from exploitfarm.utils import DEFAULT_SERVER_PORT, create_lock
from typing_extensions import Self
from exploitfarm.utils.exploit import (
    get_lang,
    get_interpreter,
    get_filename,
    get_default_file,
)
from exploitfarm.models.enums import ExploitStatus, Language
from datetime import datetime, timedelta
from exploitfarm.utils import calc_hash
from queue import Queue
import threading
from exploitfarm.models.enums import AttackExecutionStatus, AttackMode
from pydantic import ConfigDict
from dataclasses import dataclass, field
from exploitfarm.models.dbtypes import client_id_hashing
from typing import Annotated


class _ClientServerConfig(BaseModel):
    https: bool = False
    address: str | None = None
    port: int = DEFAULT_SERVER_PORT
    auth_key: str | None = None


class ClientConfig(BaseModel):
    client_id: UUID | None = None
    client_name: str | None = None
    server: _ClientServerConfig = _ClientServerConfig()
    last_status_api: dict | None = None

    __status_fetched = False
    _skio: socketio.Client | None = None

    @property
    def skio(self) -> socketio.Client:
        if self._skio is None:
            self._skio = socketio.Client()
        return self._skio

    @property
    def reqs(self):
        from exploitfarm.utils.reqs import Reqs

        return Reqs(self)

    def skio_connect(self) -> socketio.Client:
        from exploitfarm import DEV_MODE
        from exploitfarm.utils.reqs import get_url, ReqsError

        try:
            self.skio.connect(
                get_url("//", self),
                socketio_path="/sock/socket.io",
                transports=["websocket"],
                auth={"token": self.server.auth_key},
            )
        except Exception as e:
            if DEV_MODE:
                traceback.print_exc()
            raise ReqsError(f"Can't connect to server {e}") from e
        return self.skio

    @property
    def hashed_client_id(self) -> str:
        return client_id_hashing(self.client_id)

    @classmethod
    def read(cls) -> Self:
        return read_client_config()

    def write(self):
        write_client_config(self)

    def test_server(self) -> bool:
        try:
            self.fetch_status()
            return True
        except Exception:
            return False

    def fetch_status(self, save: bool = True) -> dict:
        self.last_status_api = self.reqs.status()
        if save:
            self.write()
            self.__status_fetched = True
        return self.last_status_api

    def delta_fetch_status(self) -> timedelta:
        init_request = datetime.now()
        self.fetch_status()
        return datetime.now() - init_request

    @property
    def fetched(self) -> bool:
        return self.__status_fetched

    @property
    def status(self) -> dict:
        if self.last_status_api is None:
            return self.fetch_status()
        return self.last_status_api


def _ensure_config_dir():
    config_dir = os.path.expanduser("~/.exploitfarm")
    if not os.path.exists(config_dir):
        os.makedirs(config_dir)


def write_client_config(config: ClientConfig):
    _ensure_config_dir()
    config_path = os.path.expanduser("~/.exploitfarm/client_config.json")
    with open(config_path, "w") as f:
        f.write(config.model_dump_json())


def read_client_config() -> ClientConfig:
    _ensure_config_dir()
    config_path = os.path.expanduser("~/.exploitfarm/client_config.json")
    if not os.path.isfile(config_path):
        return ClientConfig()
    with open(config_path, "r") as f:
        return ClientConfig.model_validate_json(f.read())


# Exploit config
def generate_exploit_folder_name(name: str, fallback: str = "exploit_source") -> str:
    result = ""
    name = name.strip()
    allowed_dictionary = string.ascii_letters + string.digits + "-_"
    for ele in name:
        if ele in allowed_dictionary:
            result += ele
        if ele == " ":
            result += "_"
    if len(result) == 0:
        return fallback
    return result.lower()


EXPLOIT_CONFIG_FILE_NAME = "config.toml"


class ExploitConfig(BaseModel):
    uuid: UUID
    name: str
    interpreter: str | None = None
    run: str
    language: Language
    service: UUID

    __exploit_lock = None
    __folder = "."

    @classmethod
    @validate_call()
    def new(
        cls,
        name: str,
        lang: Language | str,
        srv: UUID,
        generate_folder: bool = False,
        folder: str = ".",
    ) -> Self:
        if isinstance(lang, str):
            lang = get_lang(lang)
        obj = cls(
            uuid=uuid4(),
            name=name,
            language=lang,
            service=srv,
            interpreter=get_interpreter(lang),
            run=get_filename(lang),
        )
        if generate_folder:
            obj.__folder = generate_exploit_folder_name(name, obj.uuid)
        else:
            obj.__folder = folder
        return obj

    def model_dump_toml(self) -> str:
        return toml.dumps(self.model_dump(mode="json"))

    @classmethod
    def model_validate_toml(cls, data: str) -> Self:
        return cls(**toml.loads(data))

    def write(self, exists_ok: bool = False):
        # Autogenerated path
        pathexists = os.path.exists(self.__folder)
        if not pathexists and not exists_ok:
            raise FileExistsError(
                "Exploit folder already exists, can't write exploit config: "
                "Consider to change the exploit name"
            )

        if not pathexists:
            os.makedirs(self.__folder)
            with open(
                os.path.join(self.__folder, get_filename(self.language)), "wt"
            ) as f:
                f.write(get_default_file(self.language))

        with open(os.path.join(self.__folder, EXPLOIT_CONFIG_FILE_NAME), "w") as f:
            f.write(self.model_dump_toml())

    def publish_exploit(self, config: ClientConfig):
        config.reqs.new_exploit(
            {
                "id": self.uuid,
                "name": self.name,
                "language": self.language.value,
                "status": ExploitStatus.disabled.value,
                "service": self.service,
                "created_by": config.client_id,
            }
        )

    @property
    def lock(self):
        if self.__exploit_lock is None:
            self.__exploit_lock = create_lock(
                os.path.expanduser(f"~/.exploitfarm/exploit-{self.uuid}.lock")
            )
        return self.__exploit_lock

    def lock_exploit(self):
        return self.lock.acquire(blocking=False)

    def release_exploit(self):
        if self.lock.acquired:
            return self.lock.release()

    def hash(self):
        return calc_hash(self.__folder)

    @classmethod
    def read(cls, path: str) -> Self:
        with open(os.path.join(path, EXPLOIT_CONFIG_FILE_NAME), "r") as f:
            obj = cls.model_validate_toml(f.read())
            obj.__folder = path
            return obj


def check_exploit_config_exists(path: str) -> bool:
    path = os.path.join(os.getcwd(), path)
    if not os.path.exists(path):
        return False
    if not os.path.isdir(path):
        return False
    if not os.path.isfile(os.path.join(path, EXPLOIT_CONFIG_FILE_NAME)):
        return False
    return True


@dataclass
class TeamAttackInfo:
    start_time: datetime
    end_time: datetime
    status: AttackExecutionStatus
    flags: int


@dataclass
class TeamInfo:
    last: TeamAttackInfo | None = None
    flags: int = 0
    executing: bool = False


@dataclass
class Info:
    teams: dict[int, TeamInfo] = field(default_factory=dict)
    running_workers: int = 0
    config_update: bool | None = None
    submitter_status: bool = True
    runtime_timeout: int = 0
    submitter_flags_in_queue: int = 0
    next_attack_at: datetime | None = None
    group_running: bool = False
    info_text: str | None = None


@dataclass
class AttackStartConfig:
    model_config = ConfigDict(arbitrary_types_allowed=True)

    config: ClientConfig
    pool_size: int
    shared_dict: dict = field(default_factory=dict)
    print_queue: Queue = Queue()
    exploit_path: str | None = None
    submit_pool_timeout: int = 3
    exit_event: threading.Event = None
    restart_event: threading.Event = None
    group: dict | None = None
    shared_attack_queue = Queue()
    config_update_queue = Queue()

    info: Info = field(default_factory=Info)

    @property
    def tick_duration(self) -> int:
        return self.config.status["config"]["TICK_DURATION"]

    @property
    def attack_mode(self) -> AttackMode:
        return AttackMode(self.config.status["config"]["ATTACK_MODE"])

    def __post_init__(self):
        if self.exit_event is None:
            self.exit_event = threading.Event()
        if self.restart_event is None:
            self.restart_event = threading.Event()
        self.shared_dict["config"] = self.config.status
