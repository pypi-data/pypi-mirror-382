import os
from contextlib import contextmanager

os_windows = os.name == "nt"
os_unix = os.name == "posix"


class CtrlCWinManager:
    def __init__(self, trigger: callable):
        if os_windows:
            # By default, Ctrl+C does not work on Windows if we spawn subprocesses.
            # Here we fix that using WinApi. See https://stackoverflow.com/a/43095532

            import signal
            import ctypes
            from ctypes import wintypes

            self.kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)

            # BOOL WINAPI HandlerRoutine(
            #   _In_ DWORD dwCtrlType
            # );
            PHANDLER_ROUTINE = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.DWORD)

            self.win_ignore_ctrl_c = PHANDLER_ROUTINE()  # = NULL

            def _errcheck_bool(result, _, args):
                if not result:
                    raise ctypes.WinError(ctypes.get_last_error())
                return args

            # BOOL WINAPI SetConsoleCtrlHandler(
            #   _In_opt_ PHANDLER_ROUTINE HandlerRoutine,
            #   _In_     BOOL             Add
            # );
            self.kernel32.SetConsoleCtrlHandler.errcheck = _errcheck_bool
            self.kernel32.SetConsoleCtrlHandler.argtypes = (
                PHANDLER_ROUTINE,
                wintypes.BOOL,
            )

            @PHANDLER_ROUTINE
            def win_ctrl_handler(dwCtrlType):
                if dwCtrlType == signal.CTRL_C_EVENT:
                    self.kernel32.SetConsoleCtrlHandler(self.win_ignore_ctrl_c, True)
                    trigger()
                return False

            self.kernel32.SetConsoleCtrlHandler(win_ctrl_handler, True)

    @contextmanager
    def skip_ctrl_c_handling(self):
        try:
            if os_windows:
                self.kernel32.SetConsoleCtrlHandler(self.win_ignore_ctrl_c, True)
            yield
        finally:
            if os_windows:
                self.kernel32.SetConsoleCtrlHandler(self.win_ignore_ctrl_c, False)
