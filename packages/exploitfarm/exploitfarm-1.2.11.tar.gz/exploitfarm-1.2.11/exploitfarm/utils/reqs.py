import requests
import os
import platform
import tarfile
import tempfile
from uuid import UUID
from typing import Dict, Any
from exploitfarm.utils.config import ClientConfig, ExploitConfig
from exploitfarm.utils import ExploitFarmClientError
import orjson
from datetime import datetime as dt
from exploitfarm.models.enums import AttackMode, SetupStatus
from posixpath import join as urljoin
from . import exploit_tar_filter
from requests.models import Response
from requests_toolbelt import MultipartEncoder, MultipartEncoderMonitor

HTTP_TIMEOUT = float(os.getenv("XFARM_HTTP_TIMEOUT", 5))
PATH_OFFSET = os.getenv("XFARM_PATH_OFFSET", "/api")


def get_url(path: str, config: ClientConfig | None = None) -> str:
    protocol = "https" if config.server.https else "http"
    result = f"{protocol}://{config.server.address}:{config.server.port}" + urljoin(
        "/", PATH_OFFSET, path[1:] if path.startswith("/") else path
    )
    if result.endswith("/"):
        result = result[:-1]
    return result


def jsonify(data: Any) -> str:
    return orjson.loads(orjson.dumps(data))


def get_session(auth: str | None | ClientConfig = None) -> requests.Session:
    res = requests.Session()
    if auth is not None:
        if isinstance(auth, str):
            res.headers.update({"Authorization": "Bearer " + auth})
        elif isinstance(auth, ClientConfig) and auth.server.auth_key is not None:
            res.headers.update({"Authorization": "Bearer " + auth.server.auth_key})
    return res


class ReqsError(Exception):
    pass


class EMPTY:
    pass


def check_req(req: Response) -> Response:
    if str(req.status_code)[0] != "2":
        try:
            res = req.json()
        except Exception:
            raise ReqsError(f"HTTP error ({req.status_code})")
        msg = res.get("message", None)
        try:
            resp = str(res.get("response", None))
        except Exception:
            resp = None
        if isinstance(msg, str):
            raise ReqsError(f"{msg}{f' ({resp})' if resp else ''}")
        else:
            raise ReqsError(f"Unknown error ({req.status_code})")
    return req


def requests_check_json(req: Response, get_response=True) -> Any:
    res = check_req(req).json()
    if isinstance(res, dict) and "response" in res and get_response:
        return res["response"]
    return res


class Reqs:
    def __init__(self, config: ClientConfig):
        self.config = config
        self.session = get_session(config)

    def refresh_session(self, auth: str | ClientConfig | None = None):
        self.session = get_session(auth if auth else self.config)

    def status(self) -> Dict[str, Any]:
        res = requests_check_json(
            self.session.get(get_url("/status", self.config), timeout=HTTP_TIMEOUT)
        )
        try:
            if res["whoami"] != "exploitfarm":
                raise Exception()
        except Exception:
            raise ReqsError("Invalid server")
        return res

    def submitters(self) -> Any:
        return requests_check_json(
            self.session.get(get_url("/submitters", self.config), timeout=HTTP_TIMEOUT)
        )

    def teams(self) -> Any:
        return requests_check_json(
            self.session.get(get_url("/teams", self.config), timeout=HTTP_TIMEOUT)
        )

    def clients(self) -> Any:
        return requests_check_json(
            self.session.get(get_url("/clients", self.config), timeout=HTTP_TIMEOUT)
        )

    def flags(self) -> Any:
        return requests_check_json(
            self.session.get(get_url("/flags", self.config), timeout=HTTP_TIMEOUT)
        )

    def exploits(self) -> Any:
        return requests_check_json(
            self.session.get(get_url("/exploits", self.config), timeout=HTTP_TIMEOUT)
        )

    def services(self) -> Any:
        return requests_check_json(
            self.session.get(get_url("/services", self.config), timeout=HTTP_TIMEOUT)
        )

    def new_submitter(self, data: dict) -> Any:
        return requests_check_json(
            self.session.post(
                get_url("/submitters", self.config),
                json=jsonify(data),
                timeout=HTTP_TIMEOUT,
            )
        )

    def delete_submitter(self, submitter_id: int) -> Any:
        return requests_check_json(
            self.session.delete(
                get_url(f"/submitters/{submitter_id}", self.config), timeout=HTTP_TIMEOUT
            )
        )

    def test_submitter(self, submitter_id: int, flags: list[str]) -> Any:
        return requests_check_json(
            self.session.post(
                get_url(f"/submitters/{submitter_id}/test", self.config),
                json=flags,
                timeout=HTTP_TIMEOUT,
            )
        )

    def setup(self, data: dict) -> Any:
        return requests_check_json(
            self.session.post(
                get_url("/setup", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT
            )
        )

    def configure_server(
        self,
        flag_regex: str | EMPTY = EMPTY,
        tick_duration: int | EMPTY = EMPTY,
        submitter: int | EMPTY = EMPTY,
        start_time: dt | None | EMPTY = EMPTY,
        end_time: dt | None | EMPTY = EMPTY,
        attack_mode: AttackMode | EMPTY = EMPTY,
        loop_attack_delay: int | EMPTY = EMPTY,
        attack_time_tick_delay: int | EMPTY = EMPTY,
        flag_timeout: int | EMPTY = EMPTY,
        flag_submit_limit: int | None | EMPTY = EMPTY,
        submit_delay: float | EMPTY = EMPTY,
        submitter_timeout: int | EMPTY = EMPTY,
        authentication_required: bool | EMPTY = EMPTY,
        password_hash: str | None | EMPTY = EMPTY,
        setup_status: SetupStatus | EMPTY = EMPTY,
        set_running: bool = False,
    ) -> Any:
        request = {
            "FLAG_REGEX": flag_regex,
            "START_TIME": start_time,
            "END_TIME": end_time,
            "TICK_DURATION": tick_duration,
            "ATTACK_MODE": attack_mode,
            "LOOP_ATTACK_DELAY": loop_attack_delay,
            "ATTACK_TIME_TICK_DELAY": attack_time_tick_delay,
            "FLAG_TIMEOUT": flag_timeout,
            "FLAG_SUBMIT_LIMIT": flag_submit_limit,
            "SUBMIT_DELAY": submit_delay,
            "SUBMITTER": submitter,
            "SUBMITTER_TIMEOUT": submitter_timeout,
            "AUTHENTICATION_REQUIRED": authentication_required,
            "PASSWORD_HASH": password_hash,
            "SETUP_STATUS": setup_status
            if not set_running
            else SetupStatus.RUNNING.value,
        }
        request = {key: value for key, value in request.items() if value is not EMPTY}
        return self.setup(request)

    def login(self, password: str) -> str:
        try:
            return requests_check_json(
                self.session.post(
                    get_url("/login", self.config),
                    data={
                        "grant_type": "password",
                        "username": "user",
                        "password": password,
                    },
                    timeout=HTTP_TIMEOUT,
                )
            )["access_token"]
        except KeyError:
            raise ReqsError("Failed to login")

    def authenicate(self, password: str, save: bool = True) -> str | None:
        auth_key = self.login(password)
        self.refresh_session(auth_key)
        self.config.server.auth_key = auth_key
        if save:
            self.config.write()
        return auth_key

    def new_client(self, data: dict) -> Any:
        return requests_check_json(
            self.session.post(
                get_url("/clients", self.config),
                json=jsonify(data),
                timeout=HTTP_TIMEOUT,
            )
        )

    def self_subscribe_client(self) -> Any:
        return self.new_client(
            {"name": self.config.client_name, "id": self.config.client_id}
        )

    def new_teams(self, data: list) -> Any:
        return requests_check_json(
            self.session.post(
                get_url("/teams", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT
            )
        )

    def new_service(self, data: dict) -> Any:
        return requests_check_json(
            self.session.post(
                get_url("/services", self.config),
                json=jsonify(data),
                timeout=HTTP_TIMEOUT,
            )
        )

    def new_exploit(self, data: dict) -> Any:
        return requests_check_json(
            self.session.post(
                get_url("/exploits", self.config),
                json=jsonify(data),
                timeout=HTTP_TIMEOUT,
            )
        )

    def exploit_stop(self, exploit_id: UUID) -> Any:
        return requests_check_json(
            self.session.post(
                get_url(f"/exploits/{exploit_id}/stopped", self.config),
                timeout=HTTP_TIMEOUT,
            )
        )

    def submit_flags(self, data: list[dict], exploit: UUID | None = None) -> Any:
        if not exploit:
            return requests_check_json(
                self.session.post(
                    get_url("/exploits/submit", self.config),
                    json=jsonify(data),
                    timeout=HTTP_TIMEOUT,
                )
            )
        else:
            return requests_check_json(
                self.session.post(
                    get_url(f"/exploits/{exploit}/submit", self.config),
                    json=jsonify(data),
                    timeout=HTTP_TIMEOUT,
                )
            )

    def exploit_source_log(self, exploit_id: UUID) -> Any:
        return requests_check_json(
            self.session.get(
                get_url(f"/exploits/{exploit_id}/source", self.config),
                timeout=HTTP_TIMEOUT,
            )
        )

    def download_exploit_source(
        self, source_id: str, loading_callback: callable = None
    ) -> tarfile.TarFile:
        req = check_req(
            self.session.get(
                get_url(f"/exploits/source/{source_id}/download", self.config),
                timeout=HTTP_TIMEOUT,
                stream=True,
            )
        )
        total_size = int(req.headers.get("content-length", 0))
        block_size = 1024 * 128

        tfile = tempfile.SpooledTemporaryFile(1024 * 1024)
        downloaded = 0
        for data in req.iter_content(block_size):
            downloaded += len(data)
            tfile.write(data)
            if loading_callback:
                loading_callback("Downloading exploit source", downloaded, total_size)

        if total_size != 0 and downloaded != total_size:
            tfile.close()
            raise ReqsError("Could not download file")

        tfile.seek(0)
        return tarfile.open(fileobj=tfile, mode="r:gz")

    def upload_exploit_source(
        self,
        path: str,
        message: str | None = None,
        os_type: str | None = None,
        arch: str | None = None,
        distro: str | None = None,
        force: bool = False,
        loading_callback: callable = None,
    ):
        if os_type is None:
            os_type = platform.system()
        if distro is None:
            distro = platform.platform()
        if arch is None:
            arch = platform.machine()
        if message is None:
            message = ""

        expl_conf = ExploitConfig.read(path)
        if loading_callback:
            loading_callback("Downloading exploit history", None, None)
        logs = self.exploit_source_log(expl_conf.uuid)

        if not force:
            # Check hash not exists already
            calculated_hash = expl_conf.hash()
            for log in logs:
                if log["hash"] == calculated_hash:
                    raise ExploitFarmClientError(
                        f"Hash {calculated_hash} already exists"
                    )

        if loading_callback:
            loading_callback("Compressing exploit", None, None)
        with tempfile.SpooledTemporaryFile(1024 * 1024) as temp_file:
            with tarfile.open(fileobj=temp_file, mode="w:gz") as tar:
                tar.add(path, arcname=".", filter=exploit_tar_filter)
            temp_file.seek(0)

            encoder = MultipartEncoder(
                fields={
                    "file": ("explit_source.tar.gz", temp_file),
                    "os_type": os_type,
                    "arch": arch,
                    "distro": distro,
                    "message": message,
                    "pushed_by": str(self.config.client_id),
                }
            )

            def internal_callback(monitor):
                if loading_callback:
                    loading_callback("Uploading source", monitor.bytes_read, encoder.len)

            data_encoded = MultipartEncoderMonitor(encoder, internal_callback)

            return requests_check_json(
                self.session.post(
                    get_url("/exploits/source", self.config),
                    data=data_encoded,
                    headers={"Content-Type": data_encoded.content_type},
                )
            )

    def groups(self) -> Any:
        return requests_check_json(
            self.session.get(get_url("/groups", self.config), timeout=HTTP_TIMEOUT)
        )

    def new_group(self, data: dict) -> Any:
        return requests_check_json(
            self.session.post(
                get_url("/groups", self.config), json=jsonify(data), timeout=HTTP_TIMEOUT
            )
        )
