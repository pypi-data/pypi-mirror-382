from exploitfarm.models.dbtypes import ExploitID
from exploitfarm.models.enums import Language
from exploitfarm.models.dbtypes import ServiceID, ClientID, UnHashedClientID, TeamID, ExploitSourceID, AttackGroupID
from pydantic import BaseModel, AwareDatetime, Field, AliasChoices
from exploitfarm.models.enums import AttackExecutionStatus
from exploitfarm.utils import json_like
from exploitfarm.models.enums import ExploitStatus

###-- Exploit Models --###

class ExploitDTO(BaseModel):
    id: ExploitID
    name: str
    language: Language
    status: ExploitStatus|None = None
    last_update: AwareDatetime|None = None
    created_at: AwareDatetime
    service: ServiceID = Field(validation_alias=AliasChoices('service_id'))
    created_by: ClientID = Field(validation_alias=AliasChoices('created_by_id'))
    last_execution_by: ClientID|None = None
    last_execution_group_by: AttackGroupID|None = None
    last_source: ExploitSourceID|None = None
    
class ExploitSourceDTO(BaseModel):
    id:         ExploitSourceID
    hash:       str
    message:    str|None
    pushed_at:  AwareDatetime
    pushed_by:  ClientID = Field(validation_alias=AliasChoices('pushed_by_id'))
    os_type:    str|None
    distro:     str|None
    arch:       str|None
    exploit:    ExploitID = Field(validation_alias=AliasChoices('exploit_id'))
    
    def db_data(self):
        return json_like(self, convert_keys={
            "pushed_by": "pushed_by_id",
            "exploit": "exploit_id"
        })

class ExploitAddForm(BaseModel):
    id: ExploitID
    name: str
    language: Language = Language.other
    service: ServiceID
    created_by: UnHashedClientID #Only the real client can associate an exploit to it
    
    def db_data(self):
        return json_like(self, convert_keys={
            "created_by": "created_by_id",
            "service": "service_id"
        })

class ExploitNewForm(BaseModel):
    name: str|None = None
    language: Language|None = None
    service: ServiceID|None = None
    created_by: UnHashedClientID|None = None #Only the real client can associate an exploit to it

class ExploitEditForm(BaseModel):
    name: str|None = None
    language: Language|None = None
    service: ServiceID|None = None
    
    def db_data(self):
        return json_like(self, convert_keys={
            "service": "service_id"
        })
    
class ExploitSubmitForm(BaseModel):
    start_time: AwareDatetime|None = None
    end_time: AwareDatetime|None = None
    status: AttackExecutionStatus
    output: bytes|None = None
    executed_by: UnHashedClientID|None = None
    source_hash: str|None = None
    target: TeamID|None = None
    executed_by_group: AttackGroupID|None = None
    flags: list[str]
    
    def db_data(self):
        return json_like(self, convert_keys={
            "executed_by": "executed_by_id",
            "target": "target_id",
            "executed_by_group": "executed_by_group_id"
        }, mode="python")

class ExploitSourcePushForm(BaseModel):
    message: str|None

class ManualSubmitForm(BaseModel):
    flags: list[str]|None = None
    output: bytes|None = None