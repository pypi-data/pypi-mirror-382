from textual.app import App, ComposeResult
from textual.widgets import Footer, RichLog, Tab, Tabs, DataTable
from textual.widgets import Digits, Header, Label, Button
from textual.widgets.data_table import CellDoesNotExist
from exploitfarm.utils.config import ExploitConfig
from exploitfarm.models.enums import AttackExecutionStatus
from datetime import datetime as dt
import datetime
from rich.text import Text
from rich.table import Table
from rich.markup import escape
import traceback
import psutil
from textual import on
from copy import deepcopy
from exploitfarm.utils import mem_usage
from exploitfarm import Prio, nicenessify
from exploitfarm.xploit import shutdown
from exploitfarm.utils.config import AttackStartConfig, TeamInfo
from textual.containers import Container, Vertical, Horizontal

class g:
    exec: AttackStartConfig
    exploit_config: ExploitConfig

def stop_screen():
    g.exec.exit_event.set()
    shutdown()
    g.exec.print_queue.put("Stopping exploit execution..")

def start_exploit_tui(exec_info: AttackStartConfig, exploit_config: ExploitConfig):
    g.exec = exec_info
    g.exploit_config = exploit_config
    nicenessify(Prio.normal)
    XploitRun().run()
    stop_screen()

class XploitRun(App[int]):
    
    def __init__(self):
        super().__init__()
        if g.exec.group:
            self.TABS.insert(0, Tab("Info", id="Info"))
        self.title = f"xFarm - Exploit execution of {g.exploit_config.name}"          
    
    BINDINGS = [
        ("ctrl+c", "cancel()", "Close attack"),
        ("1", "show_tab('Teams')", "Show teams"),
        ("2", "show_tab('Log')", "Show logs"),
    ]
    
    CSS = """
        .hidden {
            display: none;
        }
        .tab {
            width: 100%;
        }
        .tab-Log {
            align: center middle;
        }
        .tab-Teams {
            align: center middle;
            height: 1fr;
        }
        .full-width {
            width: 100%;
        }
        #status_text{
            height: 5;
        }
        .num_box{
            margin: 0 8;
        }
        #info{
            margin: 3 8;
        }
        .mt-1{
            margin-top: 1;
        }
    """
    
    TABS = [
        Tab("Teams", id="Teams"),
        Tab("Log", id="Log")
    ]
    
    COLUMNS = [
        "Team üëæ",
        "Host üì°",
        "Flags üö©",
        "Last status üìä",
        "Last attack üï∞Ô∏è",
        "Time to exploit ‚è±Ô∏è",
        "Executing ‚ö†Ô∏è"
    ]

    def get_team_row(self, team:dict):
        team_id = team.get("id", None)
        name = team.get("name", None)
        short_name = team.get("short_name", None)
        host = team.get("host", None)
        team_info = g.exec.info.teams.get(team_id, TeamInfo())
        
        time_delta = last_execution_time = last_attack_status = None
        executing = team_info.executing
        if team_info.last:
            time_delta = str(dt.now(datetime.timezone.utc) - team_info.last.end_time).split(".")[0]
            last_execution_time = str(team_info.last.end_time - team_info.last.start_time).split(".")[0]
            last_attack_status = team_info.last.status

        match last_attack_status:
            case AttackExecutionStatus.crashed:
                last_attack_status = "‚ö†Ô∏è ‚ò†Ô∏è "
            case AttackExecutionStatus.done:
                last_attack_status = " ‚úÖ üö©"
            case AttackExecutionStatus.noflags:
                last_attack_status = " ‚ùå üö©"
            case _:
                last_attack_status = "‚ùì"
        return [
            f"{team_id}: {short_name if short_name else name if name else ''}",
            host if host else "",
            team_info.flags if team_info.flags > 0 else "‚ö†Ô∏è  0",
            last_attack_status,
            time_delta + " ago" if time_delta else "‚ö†Ô∏è   Never",
            last_execution_time if last_execution_time else "",
            "üî•" if executing else "üí§"
        ]
    
    def update_header_info(self):
        info = g.exec.info
        submitter_flag_queue = info.submitter_flags_in_queue if info.submitter_flags_in_queue is not None else "‚ùì"
        submitter_status = "üü¢" if info.submitter_status else "[bold red]‚ùå ( Can't submit flags )[/]" if info.submitter_status is not None else "‚ùì"
        if info.config_update is None:
            config_updater = "üü¢" if g.exec.config.status.get("status", None) == "running" else "[bold red]‚ö†Ô∏è  Server is not in running mode![/]"
        else:
            config_updater = "üü¢" if info.config_update else "[bold red]‚ùå (Check server is alive)[/]" if info.config_update is not None else "‚ùì"
        this_time = dt.now(datetime.timezone.utc)
        delta_next_attack = str(info.next_attack_at - this_time).split(".")[0]+" s" if info.next_attack_at and info.next_attack_at > this_time else "‚ùì"
        status_text = self.query_one("#status_text", Label)
        messages = deepcopy(g.exec.config.status.get("messages", []))
        messages = ", ".join([f"[bold red]{ele['level']}[/]: {escape(ele['title'])}" for ele in messages])
        escaped_flag_regex = escape(g.exec.config.status.get('config', {}).get('FLAG_REGEX', 'Unknown').replace('[', '\\['))
        table = Table(show_lines=False, box=None, show_header=False, expand=True, padding=0)
        table.add_row(
            f"[yellow]Exploit [bold]{escape(g.exploit_config.name)}[/] is running.. [/]",
            f"[bold]{messages}[/]",
        )
        table.add_row(
            f"Submitter status: [bold green]{escape(submitter_status)}[/] (queued: {submitter_flag_queue})",
            f"Exploit timeout: [bold yellow]{info.runtime_timeout if info.runtime_timeout else '?'} s[/]",
            f"Tick Duration: [bold green]{g.exec.tick_duration if g.exec.tick_duration else '?'} s[/]"
        )
        
        table.add_row(
            f"Server connection: [bold]{config_updater}[/]",
            f"Next Attacks: [bold green]{delta_next_attack}[/]",
            f"Flag Format: [bold green]{escaped_flag_regex}[/]",
        )
        table.add_row(
            f"System Memory: [bold green]{mem_usage()}%[/]",
            f"System CPU: [bold green]{psutil.cpu_percent()}%[/]",
            f"Running worker: [bold green]{info.running_workers} (max: {g.exec.pool_size})[/]",
        )
        table.add_row(
            f"{escape(info.info_text if info.info_text else '')}{'[red bold]The shared attack is not running![/]' if not info.group_running and g.exec.group else ''}",
        )
        status_text.update(table)
        status_text.refresh()
    
    
    def update_table_content(self):
        used_keys = set()
        teams = deepcopy(g.exec.config.status.get("teams", []))
        teams = [team for team in teams if team.get("id", None) in g.exec.info.teams.keys()]
        
        for team in teams:
            cols = [Text("\n"+str(cell), justify=("center" if i not in (0,1) else "default")) for i, cell in enumerate(self.get_team_row(team))]
            team_key = f"team-{team['id']}"
            used_keys.add(team_key)
            try:
                [self.table.update_cell(row_key=team_key, column_key=self.column_keys[i], value=cols[i]) for i in range(len(self.column_keys))]
            except CellDoesNotExist:
                self.table.add_row(*cols, height=3, key=team_key)
        for key in self.table.rows.keys():
            if key.value not in used_keys:
                self.table.remove_row(row_key=key.value)
    
    def update_info_content(self):
        if g.exec.group is None:
            return
        info_text = self.query_one("#info_text", Label)
        member_counuter = self.query_one("#group_members", Digits)
        current_attacks = self.query_one("#current_attacks", Digits)
        dynamic_timeout = self.query_one("#dynamic_timeout", Digits)
        queued_attacks = self.query_one("#queued_attacks", Digits)
        
        start_button = self.query_one("#start", Button)
        stop_button = self.query_one("#stop", Button)
        
        info_text.update(
            f"Group: [bold green]{escape(g.exec.group['name'])}[/][bold gray] ({g.exec.group['id']})[/]\n"
            f"Running: {'üü¢' if g.exec.info.group_running else '‚ùå'}\n"
            f"Exploit: [yellow bold]{escape(g.exploit_config.name)}[/] on commit: [gray bold]{g.exec.group['commit']}[/]\n"
        )
        
        start_button.disabled = g.exec.info.group_running
        stop_button.disabled = not g.exec.info.group_running
        
        member_counuter.update(f"{len(g.exec.group['members'])}")
        current_attacks.update(f"{g.exec.info.running_workers}")
        dynamic_timeout.update(f"{g.exec.info.runtime_timeout}s")
        queued_attacks.update(f"{g.exec.info.submitter_flags_in_queue}")
        
    
    def update_data(self):
        try:
            self.table = self.query_one(DataTable)
            self.table.rows.clear()
            self.column_keys = self.table.add_columns(*[Text(text="\n\n"+ele, justify="center") for ele in self.COLUMNS])
            while True:
                #Wait for configurations
                if g.exec.config.status is None:
                    if g.exec.exit_event.wait(timeout=1):
                        return
                    continue
                
                self.update_header_info()
                self.update_table_content()
                if g.exec.group:
                    self.update_info_content()

                if g.exec.exit_event.wait(timeout=1):
                    return
        except Exception as e:
            g.exec.print_queue.put(f"[bold red]Error on update_data: {e}[/]")
            g.exec.print_queue.put(traceback.format_exc())
    
    def update_log(self):
        logger = self.query_one("#log", RichLog)
        while True:
            if g.exec.exit_event.is_set():
                return
            log = g.exec.print_queue.get()
            if isinstance(log, str):
                logger.write(escape(log), scroll_end=False)
            else:
                logger.write(log, scroll_end=False)
    
    def exit_listener(self):
        if g.exec.exit_event.wait():
            stop_screen()
            self.exit(0)
    
    def on_ready(self) -> None:
        """Called when the DOM is ready."""
        self.run_worker(self.update_data, thread=True)
        self.run_worker(self.update_log, thread=True)
        self.run_worker(self.exit_listener, thread=True)

    def compose(self) -> ComposeResult:    
        yield Header(self.title)
        yield Label(id="status_text", classes="full-width")
        yield Tabs(*self.TABS, id="tabs")
        if g.exec.group:
            yield Container(
                Horizontal(
                    Label("Loading...", id="info_text"),
                    Vertical(
                        Label("Members", classes="full-width"),
                        Digits("", id="group_members", classes="mt-1"),
                        classes="num_box"
                    ),
                    Vertical(
                        Label("Worker threads", classes="full-width"),
                        Digits(str(g.exec.pool_size), id="worker_threads", classes="mt-1")
                    )
                ),
                Horizontal(
                    Vertical(
                        Label("Currently attaccking", classes="full-width"),
                        Digits("", id="current_attacks", classes="mt-1"),
                    ),
                    Vertical(
                        Label("Timeout", classes="full-width"),
                        Digits("0s", id="dynamic_timeout", classes="mt-1"),
                        classes="num_box"
                    ),
                    Vertical(
                        Label("Queued submission", classes="full-width"),
                        Digits("", id="queued_attacks", classes="mt-1"),
                    )
                ),
                Horizontal(
                    Button("Start", id="start", variant="success"),
                    Button("Stop", id="stop", variant="error", classes="num_box"),
                    Button("Leave group", id="leave", variant="warning"),
                ),
            id="info", classes="tab tab-Info")
        yield DataTable(id="teams", classes="tab tab-Teams hidden", cell_padding=3, header_height=5, cursor_type="none" )
        yield RichLog(highlight=True, id="log", classes="tab tab-Log hidden", wrap=True, auto_scroll=True, max_lines=5000)
        yield Footer()
    
    
    @on(Button.Pressed, "#start")
    def start_attack(self):
        g.exec.shared_attack_queue.put("start_group")
        g.exec.info.group_running = True

    @on(Button.Pressed, "#stop")
    def stop_attack(self):
        g.exec.shared_attack_queue.put("stop_group")
        g.exec.info.group_running = False
    
    @on(Button.Pressed, "#leave")
    def leave_group(self):
        self.action_cancel()
    
    
    def show_tab(self, tab_name:str):
        self.query(".tab").add_class("hidden")
        self.query(f".tab-{tab_name}").remove_class("hidden")

    def action_show_tab(self, tab_name:str):
        self.query_one("#tabs", Tabs)._activate_tab(self.query_one(f"#{tab_name}", Tab))

    def on_tabs_tab_activated(self, event: Tabs.TabActivated) -> None:
        """Handle TabActivated message sent by Tabs."""
        self.show_tab(event.tab.label_text)

    def action_cancel(self):
        with self.suspend(): # Needed to avoid the app to hang, and terminal to be unusable
            self.exit(0)
            stop_screen()
    
