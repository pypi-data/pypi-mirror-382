from textual.app import App, ComposeResult
from textual.widgets import Button, Header, Label
from textual import on
from textual.widgets import Footer, Input
from textual.containers import Horizontal
from exploitfarm.utils.config import ClientConfig
from rich.markup import escape
import multiprocessing
from textual.validation import Number

class GroupPreJoin(App[None|int]):
    
    def __init__(self, config: ClientConfig, group: dict, queue_num: int|None = None):
        super().__init__()
        self.queue_num = None if queue_num is None else str(queue_num)
        self.group = group
        self.config = config
        self.options = [
            multiprocessing.cpu_count(),
            multiprocessing.cpu_count() * 3,
            multiprocessing.cpu_count() * 6,
            multiprocessing.cpu_count() * 10,
        ]
    
    BINDINGS = [
        ("ctrl+c", "cancel()", "Cancel")
    ]
    
    CSS = """
    .queue-tab-button{
        margin: 0 4;
    }
    .queue-tab{
        margin: 0 2;
        width: auto;
    }
    .name-label{
        margin: 2;
        margin-left: 4;
    }
    #queue-input{
        margin: 1 4;
    }
    """

    def compose(self) -> ComposeResult:
        yield Header("xFarm - Pre join attack group")
        
        yield Label(f"[bold]Group[/bold]: [yellow bold]{escape(self.group['name'])}[/]", classes="name-label")

        
        yield Label("[bold]Thread to use in the attack group:[/]", classes="name-label")
        yield Input(
            placeholder="20",
            value=self.queue_num,
            validators=[Number(minimum=1)],
            type="integer",
            id="queue-input",
            
        )
        yield Horizontal(
            *[Button(str(option), id=f"option-{i}", variant="default", classes="queue-tab-button") for i, option in enumerate(self.options)],
            classes="queue-tab"
        )
        yield Label("", classes="name-label", id="error-label")
        yield Horizontal(
            Button("Join", id="join", variant="success", classes="queue-tab"),
            Button("Cancel", id="cancel", variant="error", classes="queue-tab"),
            classes="queue-tab"
        )
        yield Footer()
    
    @on(Button.Pressed, "#option-0")
    def option_0(self):
        self.queue_num = str(self.options[0])
        self.reset_value_queue()
    
    @on(Button.Pressed, "#option-1")
    def option_1(self):
        self.queue_num = str(self.options[1])
        self.reset_value_queue()
    
    @on(Button.Pressed, "#option-2")
    def option_2(self):
        self.queue_num = str(self.options[2])
        self.reset_value_queue()
    
    @on(Button.Pressed, "#option-3")
    def option_3(self):
        self.queue_num = str(self.options[3])
        self.reset_value_queue()
    
    @on(Input.Changed, "#queue-input")
    def queue_input(self, inchg: Input.Changed):
        self.queue_num = inchg.value
    
    def reset_value_queue(self):
        self.query_one("#queue-input", Input).value = self.queue_num
    
    def action_cancel(self):
        self.cancel()

    @on(Button.Pressed, "#join")
    def join(self):
        try:
            res = int(self.queue_num)
            if res < 1:
                raise ValueError("The number of threads must be greater than 0")
            self.exit(res)
        except (ValueError, TypeError):
            self.query_one("#error-label", Label).update("[bold red]The number of threads must be greater than 0[/]")
            
    @on(Button.Pressed, "#cancel")
    def cancel(self):
        self.exit(None)

