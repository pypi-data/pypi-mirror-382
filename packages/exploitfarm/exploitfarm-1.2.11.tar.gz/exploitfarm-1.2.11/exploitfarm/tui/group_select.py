from textual.app import App, ComposeResult
from textual.widgets import Button, Header, Label
from textual import on
from textual.widgets import Footer, OptionList
from textual.containers import Horizontal
from exploitfarm.utils.config import ClientConfig
from rich.markup import escape

class GroupSelect(App[None|dict]):
    
    def __init__(self, config: ClientConfig, groups: list[dict]|None = None):
        super().__init__()
        self.config = config
        self.exploits = [exp for exp in self.config.reqs.exploits()]
        if not groups:
            self.groups = [group for group in self.config.reqs.groups()]
        else:
            self.groups = groups
        self.services = self.config.status["services"]
    
    BINDINGS = [
        ("ctrl+c", "cancel()", "Cancel")
    ]
    
    CSS = """
    #selector {
        margin: 2 5 0 5;
    }
    .button-box {
        margin-top: 1;
        min-height: 4;
        align: center middle;
    }
    #selector {
        height: 80%;
        align: center middle;
    }
    .max-width {
        width: 90%;
    }
    .center {
        align: center middle;
    }
    .buttons{
        margin: 0 2;
    }
    #info_text {
        text-align: center;
    }
    """

    def compose(self) -> ComposeResult:
        yield Header("xFarm - Group Select")
        yield OptionList(
            id="selector",
            classes="max-height"
        )
        yield Horizontal(
            Label("Loading groups...", id="info_text", classes="max-width center"),
            classes="max-width center"
        )
        yield Horizontal(
            Button("Select", id="select", variant="success", classes="buttons"),
            Button("Cancel", id="cancel", variant="error", classes="buttons"),
            classes="max-width button-box"
        )
        yield Footer()
    
    def service_name(self, service_id: str) -> str:
        for service in self.services:
            if service["id"] == service_id:
                return service["name"]
        return "Unknown"
    
    def exploit_name(self, exploit_id: str) -> str:
        for exploit in self.exploits:
            if exploit["id"] == exploit_id:
                return exploit["name"]
        return "Unknown"
    
    def explploit_solver(self, exploit_id: str) -> dict:
        for exploit in self.exploits:
            if exploit["id"] == exploit_id:
                return exploit
    
    def on_mount(self) -> None:
        option_list = self.query_one("#selector", OptionList)
        info_text = self.query_one("#info_text", Label)
        option_list.clear_options()
        if len(self.groups) == 0:
            info_text.update("No groups found.")
        else:
            info_text.update("Select a group to join")
        option_list.add_options([
            f"\n  [bold][undeline][blue]{escape(grp['name'])}[/][/][/] "
            f"\\[[bold yellow]{escape(self.exploit_name(grp['exploit']))}[/], service: [bold]{escape(self.service_name(self.explploit_solver(grp['exploit'])['service']))}[/]] (Commit: [gray62]{escape(grp['commit'])}[/])\n"
            f"  [bold]members:[/] [gray62]{len(grp['members'])} members[/]"
            f" [bold]status:[/] [gray62]{escape(grp['status'])}[/]\n"
            for grp in self.groups
        ])
    
    def action_cancel(self):
        self.cancel()

    @on(Button.Pressed, "#select")
    def select(self):
        self.query_one("#selector", OptionList).action_select()
        
    @on(OptionList.OptionSelected, "#selector")
    def group_selected_event(self, message: OptionList.OptionSelected) -> None:
        self.exit(self.groups[message.option_index])
            
            
    @on(Button.Pressed, "#cancel")
    def cancel(self):
        self.exit(None)

