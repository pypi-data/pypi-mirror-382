"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Code generated by boomtown. DO NOT EDIT.
"""

import arista.studio.v1.studio_pb2
import arista.subscriptions.subscriptions_pb2
import arista.time.time_pb2
import builtins
import collections.abc
import fmp.deletes_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class MetaResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    COUNT_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of the last item included in the metadata calculation."""

    @property
    def count(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Count is the number of items present under the conditions of the request."""

    def __init__(
        self,
        *,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
        count: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["count", b"count", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["count", b"count", "time", b"time", "type", b"type"]) -> None: ...

global___MetaResponse = MetaResponse

@typing.final
class AssignedTagsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """Key uniquely identifies a AssignedTags instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___AssignedTagsRequest = AssignedTagsRequest

@typing.final
class AssignedTagsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AssignedTags:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        AssignedTags instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AssignedTags | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___AssignedTagsResponse = AssignedTagsResponse

@typing.final
class AssignedTagsSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___AssignedTagsSomeRequest = AssignedTagsSomeRequest

@typing.final
class AssignedTagsSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AssignedTags:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        AssignedTags instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AssignedTags | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___AssignedTagsSomeResponse = AssignedTagsSomeResponse

@typing.final
class AssignedTagsStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AssignedTags]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each AssignedTags at end.
            * Each AssignedTags response is fully-specified (all fields set).
          * start: Returns the state of each AssignedTags at start, followed by updates until now.
            * Each AssignedTags response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each AssignedTags at start, followed by updates
            until end.
            * Each AssignedTags response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AssignedTags] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___AssignedTagsStreamRequest = AssignedTagsStreamRequest

@typing.final
class AssignedTagsStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the AssignedTags value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AssignedTags:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this AssignedTags's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AssignedTags | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___AssignedTagsStreamResponse = AssignedTagsStreamResponse

@typing.final
class AssignedTagsBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AssignedTags]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each AssignedTags at end.
            * Each AssignedTags response is fully-specified (all fields set).
          * start: Returns the state of each AssignedTags at start, followed by updates until now.
            * Each AssignedTags response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each AssignedTags at start, followed by updates
            until end.
            * Each AssignedTags response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AssignedTags] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___AssignedTagsBatchedStreamRequest = AssignedTagsBatchedStreamRequest

@typing.final
class AssignedTagsBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AssignedTagsStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___AssignedTagsStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___AssignedTagsBatchedStreamResponse = AssignedTagsBatchedStreamResponse

@typing.final
class AssignedTagsConfigRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """Key uniquely identifies a AssignedTagsConfig instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___AssignedTagsConfigRequest = AssignedTagsConfigRequest

@typing.final
class AssignedTagsConfigResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AssignedTagsConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        AssignedTagsConfig instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AssignedTagsConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___AssignedTagsConfigResponse = AssignedTagsConfigResponse

@typing.final
class AssignedTagsConfigSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___AssignedTagsConfigSomeRequest = AssignedTagsConfigSomeRequest

@typing.final
class AssignedTagsConfigSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AssignedTagsConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        AssignedTagsConfig instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AssignedTagsConfig | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___AssignedTagsConfigSomeResponse = AssignedTagsConfigSomeResponse

@typing.final
class AssignedTagsConfigStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AssignedTagsConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each AssignedTagsConfig at end.
            * Each AssignedTagsConfig response is fully-specified (all fields set).
          * start: Returns the state of each AssignedTagsConfig at start, followed by updates until now.
            * Each AssignedTagsConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each AssignedTagsConfig at start, followed by updates
            until end.
            * Each AssignedTagsConfig response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AssignedTagsConfig] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___AssignedTagsConfigStreamRequest = AssignedTagsConfigStreamRequest

@typing.final
class AssignedTagsConfigStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the AssignedTagsConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AssignedTagsConfig:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this AssignedTagsConfig's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AssignedTagsConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___AssignedTagsConfigStreamResponse = AssignedTagsConfigStreamResponse

@typing.final
class AssignedTagsConfigBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AssignedTagsConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each AssignedTagsConfig at end.
            * Each AssignedTagsConfig response is fully-specified (all fields set).
          * start: Returns the state of each AssignedTagsConfig at start, followed by updates until now.
            * Each AssignedTagsConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each AssignedTagsConfig at start, followed by updates
            until end.
            * Each AssignedTagsConfig response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AssignedTagsConfig] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___AssignedTagsConfigBatchedStreamRequest = AssignedTagsConfigBatchedStreamRequest

@typing.final
class AssignedTagsConfigBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AssignedTagsConfigStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___AssignedTagsConfigStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___AssignedTagsConfigBatchedStreamResponse = AssignedTagsConfigBatchedStreamResponse

@typing.final
class AssignedTagsConfigSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AssignedTagsConfig:
        """AssignedTagsConfig carries the value to set into the datastore.
        See the documentation on the AssignedTagsConfig struct for which fields are required.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AssignedTagsConfig | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["value", b"value"]) -> None: ...

global___AssignedTagsConfigSetRequest = AssignedTagsConfigSetRequest

@typing.final
class AssignedTagsConfigSetResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AssignedTagsConfig:
        """Value carries all the values given in the AssignedTagsConfigSetRequest as well
        as any server-generated values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        creation. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==CreatedAt will include this instance.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AssignedTagsConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___AssignedTagsConfigSetResponse = AssignedTagsConfigSetResponse

@typing.final
class AssignedTagsConfigSetSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AssignedTagsConfig]:
        """value contains a list of AssignedTagsConfig values to write.
        It is possible to provide more values than can fit within either:
            - the maxiumum send size of the client
            - the maximum receive size of the server
        If this error occurs you must reduce the number of values sent.
        See gRPC "maximum message size" documentation for more information.
        """

    def __init__(
        self,
        *,
        values: collections.abc.Iterable[arista.studio.v1.studio_pb2.AssignedTagsConfig] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

global___AssignedTagsConfigSetSomeRequest = AssignedTagsConfigSetSomeRequest

@typing.final
class AssignedTagsConfigSetSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    error: builtins.str
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey: ...
    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        error: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key"]) -> None: ...

global___AssignedTagsConfigSetSomeResponse = AssignedTagsConfigSetSomeResponse

@typing.final
class AssignedTagsConfigDeleteRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """Key indicates which AssignedTagsConfig instance to remove.
        This field must always be set.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key"]) -> None: ...

global___AssignedTagsConfigDeleteRequest = AssignedTagsConfigDeleteRequest

@typing.final
class AssignedTagsConfigDeleteResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """Key echoes back the key of the deleted AssignedTagsConfig instance."""

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        deletion. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==DeletedAt will not include this instance.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___AssignedTagsConfigDeleteResponse = AssignedTagsConfigDeleteResponse

@typing.final
class AssignedTagsConfigDeleteSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioKey]:
        """key contains a list of AssignedTagsConfig keys to delete"""

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioKey] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys"]) -> None: ...

global___AssignedTagsConfigDeleteSomeRequest = AssignedTagsConfigDeleteSomeRequest

@typing.final
class AssignedTagsConfigDeleteSomeResponse(google.protobuf.message.Message):
    """AssignedTagsConfigDeleteSomeResponse is only sent when there is an error."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    error: builtins.str
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey: ...
    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        error: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key"]) -> None: ...

global___AssignedTagsConfigDeleteSomeResponse = AssignedTagsConfigDeleteSomeResponse

@typing.final
class AssignedTagsConfigDeleteAllRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AssignedTagsConfig]:
        """PartialEqFilter provides a way to server-side filter a DeleteAll.
        This requires all provided fields to be equal to the response.
        A filtered DeleteAll will use GetAll with filter to find things to delete.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AssignedTagsConfig] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter"]) -> None: ...

global___AssignedTagsConfigDeleteAllRequest = AssignedTagsConfigDeleteAllRequest

@typing.final
class AssignedTagsConfigDeleteAllResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    type: fmp.deletes_pb2.DeleteError.ValueType
    """This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """
    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """This indicates the error message from the delete failure."""

    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """This is the key of the AssignedTagsConfig instance that failed to be deleted."""

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp when the key was being deleted."""

    def __init__(
        self,
        *,
        type: fmp.deletes_pb2.DeleteError.ValueType = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key", "time", b"time", "type", b"type"]) -> None: ...

global___AssignedTagsConfigDeleteAllResponse = AssignedTagsConfigDeleteAllResponse

@typing.final
class AutofillActionRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.AutofillActionKey:
        """Key uniquely identifies a AutofillAction instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.AutofillActionKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___AutofillActionRequest = AutofillActionRequest

@typing.final
class AutofillActionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AutofillAction:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        AutofillAction instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AutofillAction | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___AutofillActionResponse = AutofillActionResponse

@typing.final
class AutofillActionSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AutofillActionKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.AutofillActionKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___AutofillActionSomeRequest = AutofillActionSomeRequest

@typing.final
class AutofillActionSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AutofillAction:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        AutofillAction instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AutofillAction | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___AutofillActionSomeResponse = AutofillActionSomeResponse

@typing.final
class AutofillActionStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AutofillAction]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each AutofillAction at end.
            * Each AutofillAction response is fully-specified (all fields set).
          * start: Returns the state of each AutofillAction at start, followed by updates until now.
            * Each AutofillAction response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each AutofillAction at start, followed by updates
            until end.
            * Each AutofillAction response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AutofillAction] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___AutofillActionStreamRequest = AutofillActionStreamRequest

@typing.final
class AutofillActionStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the AutofillAction value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AutofillAction:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this AutofillAction's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AutofillAction | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___AutofillActionStreamResponse = AutofillActionStreamResponse

@typing.final
class AutofillActionBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AutofillAction]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each AutofillAction at end.
            * Each AutofillAction response is fully-specified (all fields set).
          * start: Returns the state of each AutofillAction at start, followed by updates until now.
            * Each AutofillAction response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each AutofillAction at start, followed by updates
            until end.
            * Each AutofillAction response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AutofillAction] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___AutofillActionBatchedStreamRequest = AutofillActionBatchedStreamRequest

@typing.final
class AutofillActionBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AutofillActionStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___AutofillActionStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___AutofillActionBatchedStreamResponse = AutofillActionBatchedStreamResponse

@typing.final
class AutofillActionConfigRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.AutofillActionKey:
        """Key uniquely identifies a AutofillActionConfig instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.AutofillActionKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___AutofillActionConfigRequest = AutofillActionConfigRequest

@typing.final
class AutofillActionConfigResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AutofillActionConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        AutofillActionConfig instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AutofillActionConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___AutofillActionConfigResponse = AutofillActionConfigResponse

@typing.final
class AutofillActionConfigSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AutofillActionKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.AutofillActionKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___AutofillActionConfigSomeRequest = AutofillActionConfigSomeRequest

@typing.final
class AutofillActionConfigSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AutofillActionConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        AutofillActionConfig instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AutofillActionConfig | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___AutofillActionConfigSomeResponse = AutofillActionConfigSomeResponse

@typing.final
class AutofillActionConfigStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AutofillActionConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each AutofillActionConfig at end.
            * Each AutofillActionConfig response is fully-specified (all fields set).
          * start: Returns the state of each AutofillActionConfig at start, followed by updates until now.
            * Each AutofillActionConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each AutofillActionConfig at start, followed by updates
            until end.
            * Each AutofillActionConfig response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AutofillActionConfig] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___AutofillActionConfigStreamRequest = AutofillActionConfigStreamRequest

@typing.final
class AutofillActionConfigStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the AutofillActionConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AutofillActionConfig:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this AutofillActionConfig's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AutofillActionConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___AutofillActionConfigStreamResponse = AutofillActionConfigStreamResponse

@typing.final
class AutofillActionConfigBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AutofillActionConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each AutofillActionConfig at end.
            * Each AutofillActionConfig response is fully-specified (all fields set).
          * start: Returns the state of each AutofillActionConfig at start, followed by updates until now.
            * Each AutofillActionConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each AutofillActionConfig at start, followed by updates
            until end.
            * Each AutofillActionConfig response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AutofillActionConfig] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___AutofillActionConfigBatchedStreamRequest = AutofillActionConfigBatchedStreamRequest

@typing.final
class AutofillActionConfigBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AutofillActionConfigStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___AutofillActionConfigStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___AutofillActionConfigBatchedStreamResponse = AutofillActionConfigBatchedStreamResponse

@typing.final
class AutofillActionConfigSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AutofillActionConfig:
        """AutofillActionConfig carries the value to set into the datastore.
        See the documentation on the AutofillActionConfig struct for which fields are required.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AutofillActionConfig | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["value", b"value"]) -> None: ...

global___AutofillActionConfigSetRequest = AutofillActionConfigSetRequest

@typing.final
class AutofillActionConfigSetResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.AutofillActionConfig:
        """Value carries all the values given in the AutofillActionConfigSetRequest as well
        as any server-generated values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        creation. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==CreatedAt will include this instance.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.AutofillActionConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___AutofillActionConfigSetResponse = AutofillActionConfigSetResponse

@typing.final
class AutofillActionConfigSetSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AutofillActionConfig]:
        """value contains a list of AutofillActionConfig values to write.
        It is possible to provide more values than can fit within either:
            - the maxiumum send size of the client
            - the maximum receive size of the server
        If this error occurs you must reduce the number of values sent.
        See gRPC "maximum message size" documentation for more information.
        """

    def __init__(
        self,
        *,
        values: collections.abc.Iterable[arista.studio.v1.studio_pb2.AutofillActionConfig] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

global___AutofillActionConfigSetSomeRequest = AutofillActionConfigSetSomeRequest

@typing.final
class AutofillActionConfigSetSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    error: builtins.str
    @property
    def key(self) -> arista.studio.v1.studio_pb2.AutofillActionKey: ...
    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.AutofillActionKey | None = ...,
        error: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key"]) -> None: ...

global___AutofillActionConfigSetSomeResponse = AutofillActionConfigSetSomeResponse

@typing.final
class AutofillActionConfigDeleteRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.AutofillActionKey:
        """Key indicates which AutofillActionConfig instance to remove.
        This field must always be set.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.AutofillActionKey | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key"]) -> None: ...

global___AutofillActionConfigDeleteRequest = AutofillActionConfigDeleteRequest

@typing.final
class AutofillActionConfigDeleteResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.AutofillActionKey:
        """Key echoes back the key of the deleted AutofillActionConfig instance."""

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        deletion. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==DeletedAt will not include this instance.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.AutofillActionKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___AutofillActionConfigDeleteResponse = AutofillActionConfigDeleteResponse

@typing.final
class AutofillActionConfigDeleteSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AutofillActionKey]:
        """key contains a list of AutofillActionConfig keys to delete"""

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.AutofillActionKey] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys"]) -> None: ...

global___AutofillActionConfigDeleteSomeRequest = AutofillActionConfigDeleteSomeRequest

@typing.final
class AutofillActionConfigDeleteSomeResponse(google.protobuf.message.Message):
    """AutofillActionConfigDeleteSomeResponse is only sent when there is an error."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    error: builtins.str
    @property
    def key(self) -> arista.studio.v1.studio_pb2.AutofillActionKey: ...
    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.AutofillActionKey | None = ...,
        error: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key"]) -> None: ...

global___AutofillActionConfigDeleteSomeResponse = AutofillActionConfigDeleteSomeResponse

@typing.final
class AutofillActionConfigDeleteAllRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.AutofillActionConfig]:
        """PartialEqFilter provides a way to server-side filter a DeleteAll.
        This requires all provided fields to be equal to the response.
        A filtered DeleteAll will use GetAll with filter to find things to delete.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.AutofillActionConfig] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter"]) -> None: ...

global___AutofillActionConfigDeleteAllRequest = AutofillActionConfigDeleteAllRequest

@typing.final
class AutofillActionConfigDeleteAllResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    type: fmp.deletes_pb2.DeleteError.ValueType
    """This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """
    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """This indicates the error message from the delete failure."""

    @property
    def key(self) -> arista.studio.v1.studio_pb2.AutofillActionKey:
        """This is the key of the AutofillActionConfig instance that failed to be deleted."""

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp when the key was being deleted."""

    def __init__(
        self,
        *,
        type: fmp.deletes_pb2.DeleteError.ValueType = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        key: arista.studio.v1.studio_pb2.AutofillActionKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key", "time", b"time", "type", b"type"]) -> None: ...

global___AutofillActionConfigDeleteAllResponse = AutofillActionConfigDeleteAllResponse

@typing.final
class InputsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.InputsKey:
        """Key uniquely identifies a Inputs instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.InputsKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___InputsRequest = InputsRequest

@typing.final
class InputsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.Inputs:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        Inputs instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.Inputs | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___InputsResponse = InputsResponse

@typing.final
class InputsSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.InputsKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.InputsKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___InputsSomeRequest = InputsSomeRequest

@typing.final
class InputsSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.Inputs:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        Inputs instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.Inputs | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___InputsSomeResponse = InputsSomeResponse

@typing.final
class InputsStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.Inputs]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each Inputs at end.
            * Each Inputs response is fully-specified (all fields set).
          * start: Returns the state of each Inputs at start, followed by updates until now.
            * Each Inputs response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each Inputs at start, followed by updates
            until end.
            * Each Inputs response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.Inputs] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___InputsStreamRequest = InputsStreamRequest

@typing.final
class InputsStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the Inputs value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.Inputs:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this Inputs's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.Inputs | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___InputsStreamResponse = InputsStreamResponse

@typing.final
class InputsBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.Inputs]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each Inputs at end.
            * Each Inputs response is fully-specified (all fields set).
          * start: Returns the state of each Inputs at start, followed by updates until now.
            * Each Inputs response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each Inputs at start, followed by updates
            until end.
            * Each Inputs response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.Inputs] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___InputsBatchedStreamRequest = InputsBatchedStreamRequest

@typing.final
class InputsBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InputsStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___InputsStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___InputsBatchedStreamResponse = InputsBatchedStreamResponse

@typing.final
class InputsConfigRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.InputsKey:
        """Key uniquely identifies a InputsConfig instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.InputsKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___InputsConfigRequest = InputsConfigRequest

@typing.final
class InputsConfigResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.InputsConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        InputsConfig instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.InputsConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___InputsConfigResponse = InputsConfigResponse

@typing.final
class InputsConfigSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.InputsKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.InputsKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___InputsConfigSomeRequest = InputsConfigSomeRequest

@typing.final
class InputsConfigSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.InputsConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        InputsConfig instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.InputsConfig | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___InputsConfigSomeResponse = InputsConfigSomeResponse

@typing.final
class InputsConfigStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.InputsConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each InputsConfig at end.
            * Each InputsConfig response is fully-specified (all fields set).
          * start: Returns the state of each InputsConfig at start, followed by updates until now.
            * Each InputsConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each InputsConfig at start, followed by updates
            until end.
            * Each InputsConfig response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.InputsConfig] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___InputsConfigStreamRequest = InputsConfigStreamRequest

@typing.final
class InputsConfigStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the InputsConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.InputsConfig:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this InputsConfig's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.InputsConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___InputsConfigStreamResponse = InputsConfigStreamResponse

@typing.final
class InputsConfigBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.InputsConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each InputsConfig at end.
            * Each InputsConfig response is fully-specified (all fields set).
          * start: Returns the state of each InputsConfig at start, followed by updates until now.
            * Each InputsConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each InputsConfig at start, followed by updates
            until end.
            * Each InputsConfig response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.InputsConfig] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___InputsConfigBatchedStreamRequest = InputsConfigBatchedStreamRequest

@typing.final
class InputsConfigBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InputsConfigStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___InputsConfigStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___InputsConfigBatchedStreamResponse = InputsConfigBatchedStreamResponse

@typing.final
class InputsConfigSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.InputsConfig:
        """InputsConfig carries the value to set into the datastore.
        See the documentation on the InputsConfig struct for which fields are required.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.InputsConfig | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["value", b"value"]) -> None: ...

global___InputsConfigSetRequest = InputsConfigSetRequest

@typing.final
class InputsConfigSetResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.InputsConfig:
        """Value carries all the values given in the InputsConfigSetRequest as well
        as any server-generated values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        creation. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==CreatedAt will include this instance.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.InputsConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___InputsConfigSetResponse = InputsConfigSetResponse

@typing.final
class InputsConfigSetSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.InputsConfig]:
        """value contains a list of InputsConfig values to write.
        It is possible to provide more values than can fit within either:
            - the maxiumum send size of the client
            - the maximum receive size of the server
        If this error occurs you must reduce the number of values sent.
        See gRPC "maximum message size" documentation for more information.
        """

    def __init__(
        self,
        *,
        values: collections.abc.Iterable[arista.studio.v1.studio_pb2.InputsConfig] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

global___InputsConfigSetSomeRequest = InputsConfigSetSomeRequest

@typing.final
class InputsConfigSetSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    error: builtins.str
    @property
    def key(self) -> arista.studio.v1.studio_pb2.InputsKey: ...
    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.InputsKey | None = ...,
        error: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key"]) -> None: ...

global___InputsConfigSetSomeResponse = InputsConfigSetSomeResponse

@typing.final
class InputsConfigDeleteRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.InputsKey:
        """Key indicates which InputsConfig instance to remove.
        This field must always be set.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.InputsKey | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key"]) -> None: ...

global___InputsConfigDeleteRequest = InputsConfigDeleteRequest

@typing.final
class InputsConfigDeleteResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.InputsKey:
        """Key echoes back the key of the deleted InputsConfig instance."""

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        deletion. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==DeletedAt will not include this instance.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.InputsKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___InputsConfigDeleteResponse = InputsConfigDeleteResponse

@typing.final
class InputsConfigDeleteSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.InputsKey]:
        """key contains a list of InputsConfig keys to delete"""

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.InputsKey] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys"]) -> None: ...

global___InputsConfigDeleteSomeRequest = InputsConfigDeleteSomeRequest

@typing.final
class InputsConfigDeleteSomeResponse(google.protobuf.message.Message):
    """InputsConfigDeleteSomeResponse is only sent when there is an error."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    error: builtins.str
    @property
    def key(self) -> arista.studio.v1.studio_pb2.InputsKey: ...
    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.InputsKey | None = ...,
        error: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key"]) -> None: ...

global___InputsConfigDeleteSomeResponse = InputsConfigDeleteSomeResponse

@typing.final
class InputsConfigDeleteAllRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.InputsConfig]:
        """PartialEqFilter provides a way to server-side filter a DeleteAll.
        This requires all provided fields to be equal to the response.
        A filtered DeleteAll will use GetAll with filter to find things to delete.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.InputsConfig] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter"]) -> None: ...

global___InputsConfigDeleteAllRequest = InputsConfigDeleteAllRequest

@typing.final
class InputsConfigDeleteAllResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    type: fmp.deletes_pb2.DeleteError.ValueType
    """This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """
    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """This indicates the error message from the delete failure."""

    @property
    def key(self) -> arista.studio.v1.studio_pb2.InputsKey:
        """This is the key of the InputsConfig instance that failed to be deleted."""

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp when the key was being deleted."""

    def __init__(
        self,
        *,
        type: fmp.deletes_pb2.DeleteError.ValueType = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        key: arista.studio.v1.studio_pb2.InputsKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key", "time", b"time", "type", b"type"]) -> None: ...

global___InputsConfigDeleteAllResponse = InputsConfigDeleteAllResponse

@typing.final
class SecretInputRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.InputsKey:
        """Key uniquely identifies a SecretInput instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.InputsKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___SecretInputRequest = SecretInputRequest

@typing.final
class SecretInputResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.SecretInput:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        SecretInput instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.SecretInput | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___SecretInputResponse = SecretInputResponse

@typing.final
class SecretInputSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.InputsKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.InputsKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___SecretInputSomeRequest = SecretInputSomeRequest

@typing.final
class SecretInputSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.SecretInput:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        SecretInput instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.SecretInput | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___SecretInputSomeResponse = SecretInputSomeResponse

@typing.final
class SecretInputStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.SecretInput]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each SecretInput at end.
            * Each SecretInput response is fully-specified (all fields set).
          * start: Returns the state of each SecretInput at start, followed by updates until now.
            * Each SecretInput response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each SecretInput at start, followed by updates
            until end.
            * Each SecretInput response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.SecretInput] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___SecretInputStreamRequest = SecretInputStreamRequest

@typing.final
class SecretInputStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the SecretInput value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.SecretInput:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this SecretInput's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.SecretInput | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___SecretInputStreamResponse = SecretInputStreamResponse

@typing.final
class SecretInputBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.SecretInput]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each SecretInput at end.
            * Each SecretInput response is fully-specified (all fields set).
          * start: Returns the state of each SecretInput at start, followed by updates until now.
            * Each SecretInput response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each SecretInput at start, followed by updates
            until end.
            * Each SecretInput response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.SecretInput] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___SecretInputBatchedStreamRequest = SecretInputBatchedStreamRequest

@typing.final
class SecretInputBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SecretInputStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___SecretInputStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___SecretInputBatchedStreamResponse = SecretInputBatchedStreamResponse

@typing.final
class StudioRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """Key uniquely identifies a Studio instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___StudioRequest = StudioRequest

@typing.final
class StudioResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.Studio:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        Studio instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.Studio | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___StudioResponse = StudioResponse

@typing.final
class StudioSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___StudioSomeRequest = StudioSomeRequest

@typing.final
class StudioSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.Studio:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        Studio instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.Studio | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___StudioSomeResponse = StudioSomeResponse

@typing.final
class StudioStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.Studio]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each Studio at end.
            * Each Studio response is fully-specified (all fields set).
          * start: Returns the state of each Studio at start, followed by updates until now.
            * Each Studio response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each Studio at start, followed by updates
            until end.
            * Each Studio response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.Studio] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___StudioStreamRequest = StudioStreamRequest

@typing.final
class StudioStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the Studio value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.Studio:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this Studio's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.Studio | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___StudioStreamResponse = StudioStreamResponse

@typing.final
class StudioBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.Studio]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each Studio at end.
            * Each Studio response is fully-specified (all fields set).
          * start: Returns the state of each Studio at start, followed by updates until now.
            * Each Studio response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each Studio at start, followed by updates
            until end.
            * Each Studio response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.Studio] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___StudioBatchedStreamRequest = StudioBatchedStreamRequest

@typing.final
class StudioBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StudioStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___StudioStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___StudioBatchedStreamResponse = StudioBatchedStreamResponse

@typing.final
class StudioConfigRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """Key uniquely identifies a StudioConfig instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___StudioConfigRequest = StudioConfigRequest

@typing.final
class StudioConfigResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.StudioConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        StudioConfig instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.StudioConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___StudioConfigResponse = StudioConfigResponse

@typing.final
class StudioConfigSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___StudioConfigSomeRequest = StudioConfigSomeRequest

@typing.final
class StudioConfigSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.StudioConfig:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        StudioConfig instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.StudioConfig | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___StudioConfigSomeResponse = StudioConfigSomeResponse

@typing.final
class StudioConfigStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each StudioConfig at end.
            * Each StudioConfig response is fully-specified (all fields set).
          * start: Returns the state of each StudioConfig at start, followed by updates until now.
            * Each StudioConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each StudioConfig at start, followed by updates
            until end.
            * Each StudioConfig response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioConfig] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___StudioConfigStreamRequest = StudioConfigStreamRequest

@typing.final
class StudioConfigStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the StudioConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.StudioConfig:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this StudioConfig's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.StudioConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___StudioConfigStreamResponse = StudioConfigStreamResponse

@typing.final
class StudioConfigBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioConfig]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each StudioConfig at end.
            * Each StudioConfig response is fully-specified (all fields set).
          * start: Returns the state of each StudioConfig at start, followed by updates until now.
            * Each StudioConfig response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each StudioConfig at start, followed by updates
            until end.
            * Each StudioConfig response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioConfig] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___StudioConfigBatchedStreamRequest = StudioConfigBatchedStreamRequest

@typing.final
class StudioConfigBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StudioConfigStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___StudioConfigStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___StudioConfigBatchedStreamResponse = StudioConfigBatchedStreamResponse

@typing.final
class StudioConfigSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.StudioConfig:
        """StudioConfig carries the value to set into the datastore.
        See the documentation on the StudioConfig struct for which fields are required.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.StudioConfig | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["value", b"value"]) -> None: ...

global___StudioConfigSetRequest = StudioConfigSetRequest

@typing.final
class StudioConfigSetResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.StudioConfig:
        """Value carries all the values given in the StudioConfigSetRequest as well
        as any server-generated values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        creation. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==CreatedAt will include this instance.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.StudioConfig | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___StudioConfigSetResponse = StudioConfigSetResponse

@typing.final
class StudioConfigSetSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioConfig]:
        """value contains a list of StudioConfig values to write.
        It is possible to provide more values than can fit within either:
            - the maxiumum send size of the client
            - the maximum receive size of the server
        If this error occurs you must reduce the number of values sent.
        See gRPC "maximum message size" documentation for more information.
        """

    def __init__(
        self,
        *,
        values: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioConfig] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

global___StudioConfigSetSomeRequest = StudioConfigSetSomeRequest

@typing.final
class StudioConfigSetSomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    error: builtins.str
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey: ...
    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        error: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key"]) -> None: ...

global___StudioConfigSetSomeResponse = StudioConfigSetSomeResponse

@typing.final
class StudioConfigDeleteRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """Key indicates which StudioConfig instance to remove.
        This field must always be set.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key"]) -> None: ...

global___StudioConfigDeleteRequest = StudioConfigDeleteRequest

@typing.final
class StudioConfigDeleteResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """Key echoes back the key of the deleted StudioConfig instance."""

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp at which the system recognizes the
        deletion. The only guarantees made about this timestamp are:

           - it is after the time the request was received
           - a time-ranged query with StartTime==DeletedAt will not include this instance.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___StudioConfigDeleteResponse = StudioConfigDeleteResponse

@typing.final
class StudioConfigDeleteSomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioKey]:
        """key contains a list of StudioConfig keys to delete"""

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioKey] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys"]) -> None: ...

global___StudioConfigDeleteSomeRequest = StudioConfigDeleteSomeRequest

@typing.final
class StudioConfigDeleteSomeResponse(google.protobuf.message.Message):
    """StudioConfigDeleteSomeResponse is only sent when there is an error."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    error: builtins.str
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey: ...
    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        error: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key"]) -> None: ...

global___StudioConfigDeleteSomeResponse = StudioConfigDeleteSomeResponse

@typing.final
class StudioConfigDeleteAllRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioConfig]:
        """PartialEqFilter provides a way to server-side filter a DeleteAll.
        This requires all provided fields to be equal to the response.
        A filtered DeleteAll will use GetAll with filter to find things to delete.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioConfig] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter"]) -> None: ...

global___StudioConfigDeleteAllRequest = StudioConfigDeleteAllRequest

@typing.final
class StudioConfigDeleteAllResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    type: fmp.deletes_pb2.DeleteError.ValueType
    """This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """
    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """This indicates the error message from the delete failure."""

    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """This is the key of the StudioConfig instance that failed to be deleted."""

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the (UTC) timestamp when the key was being deleted."""

    def __init__(
        self,
        *,
        type: fmp.deletes_pb2.DeleteError.ValueType = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "key", b"key", "time", b"time", "type", b"type"]) -> None: ...

global___StudioConfigDeleteAllResponse = StudioConfigDeleteAllResponse

@typing.final
class StudioSummaryRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> arista.studio.v1.studio_pb2.StudioKey:
        """Key uniquely identifies a StudioSummary instance to retrieve.
        This value must be populated.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        key: arista.studio.v1.studio_pb2.StudioKey | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "time", b"time"]) -> None: ...

global___StudioSummaryRequest = StudioSummaryRequest

@typing.final
class StudioSummaryResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.StudioSummary:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        StudioSummary instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.StudioSummary | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> None: ...

global___StudioSummaryResponse = StudioSummaryResponse

@typing.final
class StudioSummarySomeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioKey]: ...
    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time indicates the time for which you are interested in the data.
        If no time is given, the server will use the time at which it makes the request.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioKey] | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "time", b"time"]) -> None: ...

global___StudioSummarySomeRequest = StudioSummarySomeRequest

@typing.final
class StudioSummarySomeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> arista.studio.v1.studio_pb2.StudioSummary:
        """Value is the value requested.
        This structure will be fully-populated as it exists in the datastore. If
        optional fields were not given at creation, these fields will be empty or
        set to default values.
        """

    @property
    def error(self) -> google.protobuf.wrappers_pb2.StringValue:
        """Error is an optional field.
        It should be filled when there is an error in the GetSome process.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time carries the (UTC) timestamp of the last-modification of the
        StudioSummary instance in this response.
        """

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.StudioSummary | None = ...,
        error: google.protobuf.wrappers_pb2.StringValue | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["error", b"error", "time", b"time", "value", b"value"]) -> None: ...

global___StudioSummarySomeResponse = StudioSummarySomeResponse

@typing.final
class StudioSummaryStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioSummary]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each StudioSummary at end.
            * Each StudioSummary response is fully-specified (all fields set).
          * start: Returns the state of each StudioSummary at start, followed by updates until now.
            * Each StudioSummary response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each StudioSummary at start, followed by updates
            until end.
            * Each StudioSummary response at start is fully-specified, but updates until end may
              be partial.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioSummary] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___StudioSummaryStreamRequest = StudioSummaryStreamRequest

@typing.final
class StudioSummaryStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: arista.subscriptions.subscriptions_pb2.Operation.ValueType
    """Operation indicates how the StudioSummary value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """
    @property
    def value(self) -> arista.studio.v1.studio_pb2.StudioSummary:
        """Value is a value deemed relevant to the initiating request.
        This structure will always have its key-field populated. Which other fields are
        populated, and why, depends on the value of Operation and what triggered this notification.
        """

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time holds the timestamp of this StudioSummary's last modification."""

    def __init__(
        self,
        *,
        value: arista.studio.v1.studio_pb2.StudioSummary | None = ...,
        time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        type: arista.subscriptions.subscriptions_pb2.Operation.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["time", b"time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["time", b"time", "type", b"type", "value", b"value"]) -> None: ...

global___StudioSummaryStreamResponse = StudioSummaryStreamResponse

@typing.final
class StudioSummaryBatchedStreamRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTIAL_EQ_FILTER_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def partial_eq_filter(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[arista.studio.v1.studio_pb2.StudioSummary]:
        """PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
        This requires all provided fields to be equal to the response.

        While transparent to users, this field also allows services to optimize internal
        subscriptions if filter(s) are sufficiently specific.
        """

    @property
    def time(self) -> arista.time.time_pb2.TimeBounds:
        """TimeRange allows limiting response data to within a specified time window.
        If this field is populated, at least one of the two time fields are required.

        For GetAll, the fields start and end can be used as follows:

          * end: Returns the state of each StudioSummary at end.
            * Each StudioSummary response is fully-specified (all fields set).
          * start: Returns the state of each StudioSummary at start, followed by updates until now.
            * Each StudioSummary response at start is fully-specified, but updates may be partial.
          * start and end: Returns the state of each StudioSummary at start, followed by updates
            until end.
            * Each StudioSummary response at start is fully-specified, but updates until end may
              be partial.
        """

    @property
    def max_messages(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """MaxMessages limits the maximum number of messages that can be contained in one batch.
        MaxMessages is required to be at least 1.
        The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
        INTERNAL_BATCH_LIMIT is set based on the maximum message size.
        """

    def __init__(
        self,
        *,
        partial_eq_filter: collections.abc.Iterable[arista.studio.v1.studio_pb2.StudioSummary] | None = ...,
        time: arista.time.time_pb2.TimeBounds | None = ...,
        max_messages: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["max_messages", b"max_messages", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["max_messages", b"max_messages", "partial_eq_filter", b"partial_eq_filter", "time", b"time"]) -> None: ...

global___StudioSummaryBatchedStreamRequest = StudioSummaryBatchedStreamRequest

@typing.final
class StudioSummaryBatchedStreamResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StudioSummaryStreamResponse]:
        """Values are the values deemed relevant to the initiating request.
        The length of this structure is guaranteed to be between (inclusive) 1 and
        min(req.max_messages, INTERNAL_BATCH_LIMIT).
        """

    def __init__(
        self,
        *,
        responses: collections.abc.Iterable[global___StudioSummaryStreamResponse] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["responses", b"responses"]) -> None: ...

global___StudioSummaryBatchedStreamResponse = StudioSummaryBatchedStreamResponse
