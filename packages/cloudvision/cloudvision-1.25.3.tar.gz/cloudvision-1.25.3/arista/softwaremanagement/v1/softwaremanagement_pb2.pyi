"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright (c) 2023 Arista Networks, Inc.  All rights reserved.
Use of this source code is governed by the Apache License 2.0
that can be found in the COPYING file.

EOS images, Streaming Agent, and other extensions in CloudVision are managed using this
resource API. Images and extensions can be added, deleted and updated.

New software is added to CloudVision either by uploading files directly from your computer using
the Software Upload REST API or by downloading them from Arista's Software Download site using
this resource API. To upload software using the Software Upload REST API in CloudVision, navigate
to Settings > Developer Tools > REST API Explorer > softwareRepository.

No matter how the image or extension is added, you can use the resource API to update or delete
it.
"""

import builtins
import fmp.wrappers_pb2
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _SoftwareSource:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SoftwareSourceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SoftwareSource.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SOFTWARE_SOURCE_UNSPECIFIED: _SoftwareSource.ValueType  # 0
    """SOFTWARE_SOURCE_UNSPECIFIED indicates that the source is not known"""
    SOFTWARE_SOURCE_CLOUD: _SoftwareSource.ValueType  # 1
    """SOFTWARE_SOURCE_CLOUD indicates that the image or extension has been downloaded from
    Arista's Software Download site
    """
    SOFTWARE_SOURCE_LOCAL: _SoftwareSource.ValueType  # 2
    """SOFTWARE_SOURCE_LOCAL indicates that the image or extension file has been uploaded directly
    to CloudVision by the user
    """
    SOFTWARE_SOURCE_PRELOADED: _SoftwareSource.ValueType  # 3
    """SOFTWARE_SOURCE_PRELOADED indicates that the image or extension file has been added as part
    of an upgrade of CloudVision.
    """
    SOFTWARE_SOURCE_NP_MIGRATION: _SoftwareSource.ValueType  # 4
    """SOFTWARE_SOURCE_NP_MIGRATION indicates that the image or extension file has been internally
    transferred from Network Provisioning to Software Management Studio as part of the
    migration process.
    """

class SoftwareSource(_SoftwareSource, metaclass=_SoftwareSourceEnumTypeWrapper):
    """SoftwareSource describes the software upload mode."""

SOFTWARE_SOURCE_UNSPECIFIED: SoftwareSource.ValueType  # 0
"""SOFTWARE_SOURCE_UNSPECIFIED indicates that the source is not known"""
SOFTWARE_SOURCE_CLOUD: SoftwareSource.ValueType  # 1
"""SOFTWARE_SOURCE_CLOUD indicates that the image or extension has been downloaded from
Arista's Software Download site
"""
SOFTWARE_SOURCE_LOCAL: SoftwareSource.ValueType  # 2
"""SOFTWARE_SOURCE_LOCAL indicates that the image or extension file has been uploaded directly
to CloudVision by the user
"""
SOFTWARE_SOURCE_PRELOADED: SoftwareSource.ValueType  # 3
"""SOFTWARE_SOURCE_PRELOADED indicates that the image or extension file has been added as part
of an upgrade of CloudVision.
"""
SOFTWARE_SOURCE_NP_MIGRATION: SoftwareSource.ValueType  # 4
"""SOFTWARE_SOURCE_NP_MIGRATION indicates that the image or extension file has been internally
transferred from Network Provisioning to Software Management Studio as part of the
migration process.
"""
global___SoftwareSource = SoftwareSource

class _Progress:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ProgressEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Progress.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PROGRESS_UNSPECIFIED: _Progress.ValueType  # 0
    """PROGRESS_UNSPECIFIED indicates that upload progress is not currently reportable"""
    PROGRESS_INITIAL: _Progress.ValueType  # 1
    """PROGRESS_INITIAL indicates that a software upload has begun"""
    PROGRESS_QUEUED: _Progress.ValueType  # 2
    """PROGRESS_QUEUED indicates that an image or extension upload is waiting in a queue"""
    PROGRESS_LOADING: _Progress.ValueType  # 3
    """PROGRESS_LOADING indicates that an image or extension is currently being retrieved from
    Arista's Software Download site or CloudVision file server for processing
    """
    PROGRESS_VALIDATING: _Progress.ValueType  # 4
    """PROGRESS_VALIDATING indicates that an image or extension is being validated"""
    PROGRESS_SAVING: _Progress.ValueType  # 5
    """PROGRESS_SAVING indicates that an image or extension is being uploaded to
    CloudVision file server
    """
    PROGRESS_SUCCESS: _Progress.ValueType  # 6
    """PROGRESS_SUCCESS indicates that an image or extension has been successfully uploaded and
    validated. This is a terminal state of an upload.
    """
    PROGRESS_ERROR: _Progress.ValueType  # 7
    """PROGRESS_ERROR indicates that an image or extension failed at either the upload or
    validation phase. This is a terminal state of an upload.
    """

class Progress(_Progress, metaclass=_ProgressEnumTypeWrapper):
    """Progress is used by the Repository service to describe the stages of the software upload
    and verification process.
    """

PROGRESS_UNSPECIFIED: Progress.ValueType  # 0
"""PROGRESS_UNSPECIFIED indicates that upload progress is not currently reportable"""
PROGRESS_INITIAL: Progress.ValueType  # 1
"""PROGRESS_INITIAL indicates that a software upload has begun"""
PROGRESS_QUEUED: Progress.ValueType  # 2
"""PROGRESS_QUEUED indicates that an image or extension upload is waiting in a queue"""
PROGRESS_LOADING: Progress.ValueType  # 3
"""PROGRESS_LOADING indicates that an image or extension is currently being retrieved from
Arista's Software Download site or CloudVision file server for processing
"""
PROGRESS_VALIDATING: Progress.ValueType  # 4
"""PROGRESS_VALIDATING indicates that an image or extension is being validated"""
PROGRESS_SAVING: Progress.ValueType  # 5
"""PROGRESS_SAVING indicates that an image or extension is being uploaded to
CloudVision file server
"""
PROGRESS_SUCCESS: Progress.ValueType  # 6
"""PROGRESS_SUCCESS indicates that an image or extension has been successfully uploaded and
validated. This is a terminal state of an upload.
"""
PROGRESS_ERROR: Progress.ValueType  # 7
"""PROGRESS_ERROR indicates that an image or extension failed at either the upload or
validation phase. This is a terminal state of an upload.
"""
global___Progress = Progress

class _SoftwareType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SoftwareTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SoftwareType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SOFTWARE_TYPE_UNSPECIFIED: _SoftwareType.ValueType  # 0
    """SOFTWARE_TYPE_UNSPECIFIED indicates that the type cannot or has not been determined"""
    SOFTWARE_TYPE_SWI: _SoftwareType.ValueType  # 1
    """SOFTWARE_TYPE_SWI identifies an EOS swi image type. The corresponding image files will
    have a .swi extension.
    """
    SOFTWARE_TYPE_TERMINATTR: _SoftwareType.ValueType  # 2
    """SOFTWARE_TYPE_TERMINATTR identifies a Streaming Agent extension. The corresponding
    files will contain the term: "TerminAttr" (case insensitive) and a .swix extension.
    """
    SOFTWARE_TYPE_SWIX: _SoftwareType.ValueType  # 3
    """SOFTWARE_TYPE_SWIX identifies an extension type. The corresponding files will have a .swix
    extension.
    """
    SOFTWARE_TYPE_RPM: _SoftwareType.ValueType  # 4
    """SOFTWARE_TYPE_RPM identifies an RPM file. The corresponding files will have a .rpm
    extension.
    """

class SoftwareType(_SoftwareType, metaclass=_SoftwareTypeEnumTypeWrapper):
    """SoftwareType is an enum containing the possible Software types. `SOFTWARE_TYPE_TERMINATTR`,
    which corresponds to an EOS Streaming Agent, is first-classed due to it's importance to
    CloudVision.
    """

SOFTWARE_TYPE_UNSPECIFIED: SoftwareType.ValueType  # 0
"""SOFTWARE_TYPE_UNSPECIFIED indicates that the type cannot or has not been determined"""
SOFTWARE_TYPE_SWI: SoftwareType.ValueType  # 1
"""SOFTWARE_TYPE_SWI identifies an EOS swi image type. The corresponding image files will
have a .swi extension.
"""
SOFTWARE_TYPE_TERMINATTR: SoftwareType.ValueType  # 2
"""SOFTWARE_TYPE_TERMINATTR identifies a Streaming Agent extension. The corresponding
files will contain the term: "TerminAttr" (case insensitive) and a .swix extension.
"""
SOFTWARE_TYPE_SWIX: SoftwareType.ValueType  # 3
"""SOFTWARE_TYPE_SWIX identifies an extension type. The corresponding files will have a .swix
extension.
"""
SOFTWARE_TYPE_RPM: SoftwareType.ValueType  # 4
"""SOFTWARE_TYPE_RPM identifies an RPM file. The corresponding files will have a .rpm
extension.
"""
global___SoftwareType = SoftwareType

class _ImageFormatVersion:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ImageFormatVersionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ImageFormatVersion.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    IMAGE_FORMAT_VERSION_UNSPECIFIED: _ImageFormatVersion.ValueType  # 0
    """IMAGE_FORMAT_VERSION_UNSPECIFIED indicates an unknown image format"""
    IMAGE_FORMAT_VERSION_1_0: _ImageFormatVersion.ValueType  # 1
    """IMAGE_FORMAT_VERSION_1_0 indicates legacy swi format"""
    IMAGE_FORMAT_VERSION_2_0: _ImageFormatVersion.ValueType  # 2
    """IMAGE_FORMAT_VERSION_2_0 indicates modular swi format"""
    IMAGE_FORMAT_VERSION_3_0: _ImageFormatVersion.ValueType  # 3
    """IMAGE_FORMAT_VERSION_3_0 indicates optimised modular swi format"""

class ImageFormatVersion(_ImageFormatVersion, metaclass=_ImageFormatVersionEnumTypeWrapper):
    """ImageFormatVersion is an enum defining the image format versions of a SWI image."""

IMAGE_FORMAT_VERSION_UNSPECIFIED: ImageFormatVersion.ValueType  # 0
"""IMAGE_FORMAT_VERSION_UNSPECIFIED indicates an unknown image format"""
IMAGE_FORMAT_VERSION_1_0: ImageFormatVersion.ValueType  # 1
"""IMAGE_FORMAT_VERSION_1_0 indicates legacy swi format"""
IMAGE_FORMAT_VERSION_2_0: ImageFormatVersion.ValueType  # 2
"""IMAGE_FORMAT_VERSION_2_0 indicates modular swi format"""
IMAGE_FORMAT_VERSION_3_0: ImageFormatVersion.ValueType  # 3
"""IMAGE_FORMAT_VERSION_3_0 indicates optimised modular swi format"""
global___ImageFormatVersion = ImageFormatVersion

class _Arch:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ArchEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Arch.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ARCH_UNSPECIFIED: _Arch.ValueType  # 0
    """ARCH_UNSPECIFIED indicates an unknown or unspecified architecture"""
    ARCH_NO_ARCH: _Arch.ValueType  # 1
    """ARCH_NO_ARCH indicates that the software is architecture agnostic"""
    ARCH_I386: _Arch.ValueType  # 2
    """ARCH_I386 indicates that the software is intended for the i386 architecture"""
    ARCH_I686: _Arch.ValueType  # 3
    """ARCH_I686 indicates that the software is intended for the i686 architecture"""
    ARCH_X86_64: _Arch.ValueType  # 4
    """ARCH_X86_64 indicates that the software is intended to be run on 64-bit platforms"""
    ARCH_AARCH64: _Arch.ValueType  # 5
    """ARCH_AARCH64 indicates that the software is intended to be run on ARM 64-bit platforms"""

class Arch(_Arch, metaclass=_ArchEnumTypeWrapper):
    """Arch is an enum used to specify the target architecture of an image or extension."""

ARCH_UNSPECIFIED: Arch.ValueType  # 0
"""ARCH_UNSPECIFIED indicates an unknown or unspecified architecture"""
ARCH_NO_ARCH: Arch.ValueType  # 1
"""ARCH_NO_ARCH indicates that the software is architecture agnostic"""
ARCH_I386: Arch.ValueType  # 2
"""ARCH_I386 indicates that the software is intended for the i386 architecture"""
ARCH_I686: Arch.ValueType  # 3
"""ARCH_I686 indicates that the software is intended for the i686 architecture"""
ARCH_X86_64: Arch.ValueType  # 4
"""ARCH_X86_64 indicates that the software is intended to be run on 64-bit platforms"""
ARCH_AARCH64: Arch.ValueType  # 5
"""ARCH_AARCH64 indicates that the software is intended to be run on ARM 64-bit platforms"""
global___Arch = Arch

class _Variant:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _VariantEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Variant.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    VARIANT_UNSPECIFIED: _Variant.ValueType  # 0
    """VARIANT_UNSPECIFIED is used to indicate an unknown or unspecified EOS image variant"""
    VARIANT_US: _Variant.ValueType  # 1
    """VARIANT_US specifies a US or default version of an EOS image variant"""
    VARIANT_INTERNATIONAL: _Variant.ValueType  # 2
    """VARIANT_INTERNATIONAL specifies an international EOS image variant"""

class Variant(_Variant, metaclass=_VariantEnumTypeWrapper):
    """Variant is an enum containing the possible .swi variant types."""

VARIANT_UNSPECIFIED: Variant.ValueType  # 0
"""VARIANT_UNSPECIFIED is used to indicate an unknown or unspecified EOS image variant"""
VARIANT_US: Variant.ValueType  # 1
"""VARIANT_US specifies a US or default version of an EOS image variant"""
VARIANT_INTERNATIONAL: Variant.ValueType  # 2
"""VARIANT_INTERNATIONAL specifies an international EOS image variant"""
global___Variant = Variant

class _Flavor:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _FlavorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Flavor.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    FLAVOR_UNSPECIFIED: _Flavor.ValueType  # 0
    """FLAVOR_UNSPECIFIED indicates that the swi image flavor is unknown"""
    FLAVOR_DEFAULT: _Flavor.ValueType  # 1
    """FLAVOR_DEFAULT is the default swi image"""
    FLAVOR_2GB: _Flavor.ValueType  # 2
    """FLAVOR_2GB is an obsolete image supporting a reduced-size 2GB image version that runs
    only on older models of devices with two gigabytes of flash memory
    """
    FLAVOR_CLOUD: _Flavor.ValueType  # 3
    """FLAVOR_CLOUD is a swi image that runs in a virtualized cloud environment"""
    FLAVOR_DPE: _Flavor.ValueType  # 4
    """FLAVOR_DPE is a swi image that provides MacSec without a license"""
    FLAVOR_PDP: _Flavor.ValueType  # 5
    """FLAVOR_PDP is an image that defaults to support PDP but can also support CoPP"""
    FLAVOR_2GB_PDP: _Flavor.ValueType  # 6
    """FLAVOR_2GB_PDP is a 2GB image that defaults to support PDP if available, but can support
    CoPP
    """
    FLAVOR_DPE_CTNR: _Flavor.ValueType  # 7
    """FLAVOR_DPE_CTNR is a swi image that provides MacSec without a license and natively
    supports running containers on EOS
    """

class Flavor(_Flavor, metaclass=_FlavorEnumTypeWrapper):
    """Flavor is an enum containing the possible .swi flavor types."""

FLAVOR_UNSPECIFIED: Flavor.ValueType  # 0
"""FLAVOR_UNSPECIFIED indicates that the swi image flavor is unknown"""
FLAVOR_DEFAULT: Flavor.ValueType  # 1
"""FLAVOR_DEFAULT is the default swi image"""
FLAVOR_2GB: Flavor.ValueType  # 2
"""FLAVOR_2GB is an obsolete image supporting a reduced-size 2GB image version that runs
only on older models of devices with two gigabytes of flash memory
"""
FLAVOR_CLOUD: Flavor.ValueType  # 3
"""FLAVOR_CLOUD is a swi image that runs in a virtualized cloud environment"""
FLAVOR_DPE: Flavor.ValueType  # 4
"""FLAVOR_DPE is a swi image that provides MacSec without a license"""
FLAVOR_PDP: Flavor.ValueType  # 5
"""FLAVOR_PDP is an image that defaults to support PDP but can also support CoPP"""
FLAVOR_2GB_PDP: Flavor.ValueType  # 6
"""FLAVOR_2GB_PDP is a 2GB image that defaults to support PDP if available, but can support
CoPP
"""
FLAVOR_DPE_CTNR: Flavor.ValueType  # 7
"""FLAVOR_DPE_CTNR is a swi image that provides MacSec without a license and natively
supports running containers on EOS
"""
global___Flavor = Flavor

class _DigestType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _DigestTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DigestType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    DIGEST_TYPE_UNSPECIFIED: _DigestType.ValueType  # 0
    """DIGEST_TYPE_UNSPECIFIED indicates that the digest type is unknown"""
    DIGEST_TYPE_SHA512: _DigestType.ValueType  # 1
    """DIGEST_TYPE_SHA512 indicates that the SHA512 algorithm is used to calculate the digest"""

class DigestType(_DigestType, metaclass=_DigestTypeEnumTypeWrapper):
    """DigestType is the digest algorithm used as a checksum on the software file."""

DIGEST_TYPE_UNSPECIFIED: DigestType.ValueType  # 0
"""DIGEST_TYPE_UNSPECIFIED indicates that the digest type is unknown"""
DIGEST_TYPE_SHA512: DigestType.ValueType  # 1
"""DIGEST_TYPE_SHA512 indicates that the SHA512 algorithm is used to calculate the digest"""
global___DigestType = DigestType

class _RecommendedAction:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _RecommendedActionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RecommendedAction.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    RECOMMENDED_ACTION_UNSPECIFIED: _RecommendedAction.ValueType  # 0
    """RECOMMENDED_ACTION_UNSPECIFIED indicates that no remedial action is needed."""
    RECOMMENDED_ACTION_CONTACT_TAC: _RecommendedAction.ValueType  # 1
    """RECOMMENDED_ACTION_CONTACT_TAC indicates that in order to resolve the current issue,
    Arista TAC assistance is recommended.
    """
    RECOMMENDED_ACTION_ADD_TOKEN: _RecommendedAction.ValueType  # 2
    """RECOMMENDED_ACTION_ADD_TOKEN indicates that a particular issue can be resolved by adding
    the access token stored in CloudVision.
    """
    RECOMMENDED_ACTION_UPDATE_TOKEN: _RecommendedAction.ValueType  # 3
    """RECOMMENDED_ACTION_UPDATE_TOKEN indicates that a particular issue can be resolved by updating
    the access token stored in CloudVision.
    """
    RECOMMENDED_ACTION_ACCEPT_EULA: _RecommendedAction.ValueType  # 4
    """RECOMMENDED_ACTION_ACCEPT_EULA indicates that a particular issue can be resolved by accepting
    the EULA agreement available at the Arista Software Download site.
    """
    RECOMMENDED_ACTION_RETRY: _RecommendedAction.ValueType  # 5
    """RECOMMENDED_ACTION_RETRY indicates that a paticular issue may be resolved by
    re-attempting the previous action.
    """

class RecommendedAction(_RecommendedAction, metaclass=_RecommendedActionEnumTypeWrapper):
    """RecommendedAction is an enum containing all of the possible steps a user can take to address
    problems encountered while performing software management-related actions.
    """

RECOMMENDED_ACTION_UNSPECIFIED: RecommendedAction.ValueType  # 0
"""RECOMMENDED_ACTION_UNSPECIFIED indicates that no remedial action is needed."""
RECOMMENDED_ACTION_CONTACT_TAC: RecommendedAction.ValueType  # 1
"""RECOMMENDED_ACTION_CONTACT_TAC indicates that in order to resolve the current issue,
Arista TAC assistance is recommended.
"""
RECOMMENDED_ACTION_ADD_TOKEN: RecommendedAction.ValueType  # 2
"""RECOMMENDED_ACTION_ADD_TOKEN indicates that a particular issue can be resolved by adding
the access token stored in CloudVision.
"""
RECOMMENDED_ACTION_UPDATE_TOKEN: RecommendedAction.ValueType  # 3
"""RECOMMENDED_ACTION_UPDATE_TOKEN indicates that a particular issue can be resolved by updating
the access token stored in CloudVision.
"""
RECOMMENDED_ACTION_ACCEPT_EULA: RecommendedAction.ValueType  # 4
"""RECOMMENDED_ACTION_ACCEPT_EULA indicates that a particular issue can be resolved by accepting
the EULA agreement available at the Arista Software Download site.
"""
RECOMMENDED_ACTION_RETRY: RecommendedAction.ValueType  # 5
"""RECOMMENDED_ACTION_RETRY indicates that a paticular issue may be resolved by
re-attempting the previous action.
"""
global___RecommendedAction = RecommendedAction

class _Level:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _LevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Level.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    LEVEL_UNSPECIFIED: _Level.ValueType  # 0
    """LEVEL_UNSPECIFIED is set when the message level is unknown"""
    LEVEL_INFO: _Level.ValueType  # 1
    """LEVEL_INFO is set when the message contains useful, informational content. No user action is
    required.
    """
    LEVEL_WARNING: _Level.ValueType  # 2
    """LEVEL_WARNING is set when the message contains important information for the user that
    should be addressed for continued proper behavior
    """
    LEVEL_ERROR: _Level.ValueType  # 3
    """LEVEL_ERROR is set when the message contains information alerting the user to an error
    condition that occurred while retrieving the set of software releases. Remedial user action
    may be required to clear this condition.
    """

class Level(_Level, metaclass=_LevelEnumTypeWrapper):
    """Level specifies relative importance of the information returned in the message field of the
    software releases status.
    """

LEVEL_UNSPECIFIED: Level.ValueType  # 0
"""LEVEL_UNSPECIFIED is set when the message level is unknown"""
LEVEL_INFO: Level.ValueType  # 1
"""LEVEL_INFO is set when the message contains useful, informational content. No user action is
required.
"""
LEVEL_WARNING: Level.ValueType  # 2
"""LEVEL_WARNING is set when the message contains important information for the user that
should be addressed for continued proper behavior
"""
LEVEL_ERROR: Level.ValueType  # 3
"""LEVEL_ERROR is set when the message contains information alerting the user to an error
condition that occurred while retrieving the set of software releases. Remedial user action
may be required to clear this condition.
"""
global___Level = Level

@typing.final
class RepositoryKey(google.protobuf.message.Message):
    """RepositoryKey is the key used by the `Repository` state and config models to uniquely
    identify an image or extension.

    The `name` field must contain the file suffix. Valid file types include .swi, .swix and .rpm
    files. Streaming Agent files must also contain the term: `TerminAttr` (case insensitive).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    @property
    def name(self) -> google.protobuf.wrappers_pb2.StringValue:
        """name is a unique identifier that will be used to identify the image or extension in
        CloudVision
        """

    def __init__(
        self,
        *,
        name: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["name", b"name"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["name", b"name"]) -> None: ...

global___RepositoryKey = RepositoryKey

@typing.final
class Repository(google.protobuf.message.Message):
    """Repository is the state model that displays metadata for software images and extensions.

    `Repository` objects are created when new software is added via a `Set`
    request issued to the `RepositoryConfig` resource or when using the Software Upload REST API.
    The `key` uniquely identifies the software state and is identical to the key used to create it
    via the call to `Set`.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    UPLOADED_BY_FIELD_NUMBER: builtins.int
    UPLOADED_AT_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_BY_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_AT_FIELD_NUMBER: builtins.int
    SOFTWARE_STATUS_FIELD_NUMBER: builtins.int
    SOFTWARE_METADATA_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___RepositoryKey:
        """key is the unique identifier"""

    @property
    def uploaded_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """uploaded_by specifies the author of the upload"""

    @property
    def uploaded_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """uploaded_at specifies the date and time of the upload"""

    @property
    def last_modified_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """last_modified_by is the author of the most recent metadata modification"""

    @property
    def last_modified_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """last_modified_at is the date and time of the most recent metadata modification"""

    @property
    def software_status(self) -> global___SoftwareStatus:
        """software_status displays status of the software that is being added to CloudVision"""

    @property
    def software_metadata(self) -> global___SoftwareMetadata:
        """software_metadata displays details about available software"""

    def __init__(
        self,
        *,
        key: global___RepositoryKey | None = ...,
        uploaded_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        uploaded_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        last_modified_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        last_modified_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        software_status: global___SoftwareStatus | None = ...,
        software_metadata: global___SoftwareMetadata | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by", "software_metadata", b"software_metadata", "software_status", b"software_status", "uploaded_at", b"uploaded_at", "uploaded_by", b"uploaded_by"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by", "software_metadata", b"software_metadata", "software_status", b"software_status", "uploaded_at", b"uploaded_at", "uploaded_by", b"uploaded_by"]) -> None: ...

global___Repository = Repository

@typing.final
class RepositoryConfig(google.protobuf.message.Message):
    """RepositoryConfig objects are used to add, delete, and update images or extensions in
    CloudVision.

    The `Set` method is used to add and modify software stored in CloudVision.
    The `Delete` method is used to remove software.

    Adding Software to CloudVision:

    When a `Set` is made, the software identified by the URI will be downloaded from Arista's
    Software Download site and stored in CloudVision. The status of the software will be reflected
    by a corresponding `Repository` entry identified by the same `RepositoryKey`.

    Here is an example where a .swi EOS image is added to CloudVision:

    ```
    {
     "value": {
       "key": {
         "name": "EOS64-4.30.0.1F.swi"
       },
       "uri": "/support/download/EOS-USA/Active Releases/4.30/EOS-4.30.0.1F/EOS64-4.30.0.1F.swi",
       "rebootRequired": true
     },
    }
    ```

    The following is an example of a configuration that will add the
    _AristaAppForSplunk-2.0.1-4.27.swix_ extension to CloudVision:

    ```
    {
     "value": {
       "key": {
         "name": "AristaAppForSplunk-2.0.1-4.27.swix"
       },
       "uri": "/support/download/Extensions/Splunk/AristaAppForSplunk-2.0.1-4.27.swix",
       "rebootRequired": false
     },
    }
    ```

    Updating Existing Software:

    `Repository` metadata objects can be _updated_ by using the config `Set` method and
    specifying the field or fields to be modified. Currently, `reboot_required` is the only field
    that can be modified after software has been added to CloudVision. All other fields must match
    the existing configuration, or can be omitted.

    NOTE: The `reboot_required` field must be `true` for .swi images.

    In this example, we update the `reboot_required` field changing it from `false` to `true`
    while leaving out the uri field:

    ```
    {
     "value": {
       "key": {
         "name": "AristaAppForSplunk-2.0.1-4.27.swix"
       },
       "rebootRequired": true
     },
    }
    ```

    Deleting Software:

    `Repository` objects can be deleted using the `RepositoryConfig` `Delete` method.
    A `Delete` request will specify the `key` which uniquely identifies the image or extension in
    CloudVision. For example, a delete request will look like the following:
    ```
    {
     "value": {
       "key": {
         "name": "AristaAppForSplunk-2.0.1-4.27.swix"
       },
     },
    }
    ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    URI_FIELD_NUMBER: builtins.int
    REBOOT_REQUIRED_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___RepositoryKey:
        """key is a unique identifier that must be supplied by the user to start a valid upload of
        software
        """

    @property
    def uri(self) -> google.protobuf.wrappers_pb2.StringValue:
        """uri value depends on the origin of the software. If you are downloading an image or
        extension file from Arista's Software Download site, use the site identifier. If you are
        uploading software from your computer using the Software Upload REST API, this field will
        be populated with the CloudVision file server identifier.
        """

    @property
    def reboot_required(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """reboot_required is a Boolean indicating if a device requires a reboot after software
        installation. .swi images always require a reboot.
        """

    def __init__(
        self,
        *,
        key: global___RepositoryKey | None = ...,
        uri: google.protobuf.wrappers_pb2.StringValue | None = ...,
        reboot_required: google.protobuf.wrappers_pb2.BoolValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "reboot_required", b"reboot_required", "uri", b"uri"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "reboot_required", b"reboot_required", "uri", b"uri"]) -> None: ...

global___RepositoryConfig = RepositoryConfig

@typing.final
class SoftwareStatus(google.protobuf.message.Message):
    """SoftwareStatus contains a progress field and a description explaining the progress during
    software upload.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PROGRESS_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    RECOMMENDED_ACTION_FIELD_NUMBER: builtins.int
    progress: global___Progress.ValueType
    """progress displays the current status of the software upload"""
    recommended_action: global___RecommendedAction.ValueType
    """recommended_action expresses a particular user-actionable step that can be carried out to
    ensure the proper operation of CloudVision while managing software.
    """
    @property
    def message(self) -> google.protobuf.wrappers_pb2.StringValue:
        """message describes the progress of the software upload"""

    def __init__(
        self,
        *,
        progress: global___Progress.ValueType = ...,
        message: google.protobuf.wrappers_pb2.StringValue | None = ...,
        recommended_action: global___RecommendedAction.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["message", b"message"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["message", b"message", "progress", b"progress", "recommended_action", b"recommended_action"]) -> None: ...

global___SoftwareStatus = SoftwareStatus

@typing.final
class SoftwareMetadata(google.protobuf.message.Message):
    """SoftwareMetadata is the detailed metadata describing software files."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DIGEST_TYPE_FIELD_NUMBER: builtins.int
    DIGEST_FIELD_NUMBER: builtins.int
    SIZE_FIELD_NUMBER: builtins.int
    REBOOT_REQUIRED_FIELD_NUMBER: builtins.int
    SOFTWARE_TYPE_FIELD_NUMBER: builtins.int
    SWI_METADATA_FIELD_NUMBER: builtins.int
    EXTENSION_METADATA_FIELD_NUMBER: builtins.int
    FILE_SERVER_PATH_FIELD_NUMBER: builtins.int
    SOFTWARE_SOURCE_FIELD_NUMBER: builtins.int
    digest_type: global___DigestType.ValueType
    """digest_type specifies the type of digest algorithm used to calculate the digest for this
    image or extension
    """
    software_type: global___SoftwareType.ValueType
    """software_type determines which version field is populated - .swi image metadata appears in
    swi_metadata. .swix and .rpm extensions appear in extension_metadata.
    """
    software_source: global___SoftwareSource.ValueType
    """software_source indicates if the software being processed has been downloaded
    from Arista's Software Download site or uploaded to CloudVision from a user's local computer
    """
    @property
    def digest(self) -> google.protobuf.wrappers_pb2.StringValue:
        """digest is the digest value for the image or extension"""

    @property
    def size(self) -> google.protobuf.wrappers_pb2.UInt64Value:
        """size is the size of the image or extension in bytes"""

    @property
    def reboot_required(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """reboot_required boolean indicating if a device requires a reboot after software installation"""

    @property
    def swi_metadata(self) -> global___SwiMetadata:
        """swi_metadata is versioning information for .swi type images"""

    @property
    def extension_metadata(self) -> global___ExtensionMetadata:
        """extension_metadata is versioning information for extensions (.rpm and .swix)"""

    @property
    def file_server_path(self) -> google.protobuf.wrappers_pb2.StringValue:
        """file_server_path is the location of the image or extension as stored in CloudVision"""

    def __init__(
        self,
        *,
        digest_type: global___DigestType.ValueType = ...,
        digest: google.protobuf.wrappers_pb2.StringValue | None = ...,
        size: google.protobuf.wrappers_pb2.UInt64Value | None = ...,
        reboot_required: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        software_type: global___SoftwareType.ValueType = ...,
        swi_metadata: global___SwiMetadata | None = ...,
        extension_metadata: global___ExtensionMetadata | None = ...,
        file_server_path: google.protobuf.wrappers_pb2.StringValue | None = ...,
        software_source: global___SoftwareSource.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["digest", b"digest", "extension_metadata", b"extension_metadata", "file_server_path", b"file_server_path", "reboot_required", b"reboot_required", "size", b"size", "swi_metadata", b"swi_metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["digest", b"digest", "digest_type", b"digest_type", "extension_metadata", b"extension_metadata", "file_server_path", b"file_server_path", "reboot_required", b"reboot_required", "size", b"size", "software_source", b"software_source", "software_type", b"software_type", "swi_metadata", b"swi_metadata"]) -> None: ...

global___SoftwareMetadata = SoftwareMetadata

@typing.final
class SwiMetadata(google.protobuf.message.Message):
    """SwiMetadata is versioning metadata describing .swi type images."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VERSION_FIELD_NUMBER: builtins.int
    RELEASE_FIELD_NUMBER: builtins.int
    VARIANT_FIELD_NUMBER: builtins.int
    FLAVOR_FIELD_NUMBER: builtins.int
    ARCH_FIELD_NUMBER: builtins.int
    MAX_HARDWARE_EPOCH_FIELD_NUMBER: builtins.int
    BLESSED_FIELD_NUMBER: builtins.int
    IMAGE_FORMAT_VERSION_FIELD_NUMBER: builtins.int
    EMBEDDED_TERMINATTR_FIELD_NUMBER: builtins.int
    OPTIMIZATION_FIELD_NUMBER: builtins.int
    variant: global___Variant.ValueType
    """variant specifies the swi image variant"""
    flavor: global___Flavor.ValueType
    """flavor is the swi image flavor"""
    arch: global___Arch.ValueType
    """arch is the swi architecture"""
    image_format_version: global___ImageFormatVersion.ValueType
    """image_format_version specifies the EOS image format version"""
    @property
    def version(self) -> google.protobuf.wrappers_pb2.StringValue:
        """version specifies the version of the swi image"""

    @property
    def release(self) -> google.protobuf.wrappers_pb2.StringValue:
        """release specifies the swi image release information"""

    @property
    def max_hardware_epoch(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """max_hardware_epoch specifies the max hardware epoch value supported"""

    @property
    def blessed(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """blessed indicates if the swi image is blessed"""

    @property
    def embedded_terminattr(self) -> global___ExtensionMetadata:
        """embedded_terminattr specifies the default embedded TerminAttr version pre-installed in the
        EOS swi image
        """

    @property
    def optimization(self) -> google.protobuf.wrappers_pb2.StringValue:
        """optimization specifies any adaptations made to the image for specific products or
        use-cases
        """

    def __init__(
        self,
        *,
        version: google.protobuf.wrappers_pb2.StringValue | None = ...,
        release: google.protobuf.wrappers_pb2.StringValue | None = ...,
        variant: global___Variant.ValueType = ...,
        flavor: global___Flavor.ValueType = ...,
        arch: global___Arch.ValueType = ...,
        max_hardware_epoch: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
        blessed: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        image_format_version: global___ImageFormatVersion.ValueType = ...,
        embedded_terminattr: global___ExtensionMetadata | None = ...,
        optimization: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["blessed", b"blessed", "embedded_terminattr", b"embedded_terminattr", "max_hardware_epoch", b"max_hardware_epoch", "optimization", b"optimization", "release", b"release", "version", b"version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["arch", b"arch", "blessed", b"blessed", "embedded_terminattr", b"embedded_terminattr", "flavor", b"flavor", "image_format_version", b"image_format_version", "max_hardware_epoch", b"max_hardware_epoch", "optimization", b"optimization", "release", b"release", "variant", b"variant", "version", b"version"]) -> None: ...

global___SwiMetadata = SwiMetadata

@typing.final
class ExtensionMetadata(google.protobuf.message.Message):
    """ExtensionMetadata is versioning metadata describing extensions (.swix and .rpm)."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DESCRIPTION_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    RELEASE_FIELD_NUMBER: builtins.int
    EPOCH_FIELD_NUMBER: builtins.int
    ARCH_FIELD_NUMBER: builtins.int
    SUPPORTED_EOS_VERSIONS_FIELD_NUMBER: builtins.int
    arch: global___Arch.ValueType
    """arch is the architecture of the swix or rpm extension"""
    @property
    def description(self) -> google.protobuf.wrappers_pb2.StringValue:
        """description is the swix or rpm description"""

    @property
    def name(self) -> google.protobuf.wrappers_pb2.StringValue:
        """name is the name of the swix or rpm extension"""

    @property
    def version(self) -> google.protobuf.wrappers_pb2.StringValue:
        """version is the version of the swix or rpm extension"""

    @property
    def release(self) -> google.protobuf.wrappers_pb2.StringValue:
        """release is the value of the swix or rpm extension release"""

    @property
    def epoch(self) -> google.protobuf.wrappers_pb2.StringValue:
        """epoch is versioning metadata in swix or rpm extensions which allows handling for
        hard-to-compare version numbers
        """

    @property
    def supported_eos_versions(self) -> fmp.wrappers_pb2.RepeatedString:
        """supported_eos_versions is a list which contains EOS versions supported by the extension.
        An empty list indicates there are no known restrictions on the EOS versions supported by
        the extension
        """

    def __init__(
        self,
        *,
        description: google.protobuf.wrappers_pb2.StringValue | None = ...,
        name: google.protobuf.wrappers_pb2.StringValue | None = ...,
        version: google.protobuf.wrappers_pb2.StringValue | None = ...,
        release: google.protobuf.wrappers_pb2.StringValue | None = ...,
        epoch: google.protobuf.wrappers_pb2.StringValue | None = ...,
        arch: global___Arch.ValueType = ...,
        supported_eos_versions: fmp.wrappers_pb2.RepeatedString | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["description", b"description", "epoch", b"epoch", "name", b"name", "release", b"release", "supported_eos_versions", b"supported_eos_versions", "version", b"version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["arch", b"arch", "description", b"description", "epoch", b"epoch", "name", b"name", "release", b"release", "supported_eos_versions", b"supported_eos_versions", "version", b"version"]) -> None: ...

global___ExtensionMetadata = ExtensionMetadata

@typing.final
class ReleasesStatus(google.protobuf.message.Message):
    """ReleasesStatus contains information about the state of the available software releases
    which are retrieved from Arista's Software Download site by CloudVision.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LEVEL_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    RECOMMENDED_ACTION_FIELD_NUMBER: builtins.int
    level: global___Level.ValueType
    """level is the relative importance of the message field contained in the status"""
    recommended_action: global___RecommendedAction.ValueType
    """recommended_action expresses a particular user-actionable step that can be carried out to
    ensure the proper operation of CloudVision while interacting with Arista's Software
    Download site to obtain the set of available software releases.
    """
    @property
    def message(self) -> google.protobuf.wrappers_pb2.StringValue:
        """message is populated with a string which will provide more information regarding
        the latest interaction with the Arista's Software Download site while pulling the set of
        available software releases
        """

    def __init__(
        self,
        *,
        level: global___Level.ValueType = ...,
        message: google.protobuf.wrappers_pb2.StringValue | None = ...,
        recommended_action: global___RecommendedAction.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["message", b"message"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["level", b"level", "message", b"message", "recommended_action", b"recommended_action"]) -> None: ...

global___ReleasesStatus = ReleasesStatus

@typing.final
class Releases(google.protobuf.message.Message):
    """Releases is the entire set of software releases available from the Arista's Software
    Download site. Once downloaded, a software release can be deployed to devices managed by
    CloudVision.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STATUS_FIELD_NUMBER: builtins.int
    URIS_FIELD_NUMBER: builtins.int
    @property
    def status(self) -> global___ReleasesStatus:
        """status is providing additional information about the retrieval of the software releases
        returned in the message
        """

    @property
    def uris(self) -> fmp.wrappers_pb2.RepeatedString:
        """uris are the URI paths specifying the location of the available software releases that
        can be downloaded from the Arista's Software Download site. These URIs are used
        by the `RepositoryConfig` API to add a software release to CloudVision.
        """

    def __init__(
        self,
        *,
        status: global___ReleasesStatus | None = ...,
        uris: fmp.wrappers_pb2.RepeatedString | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["status", b"status", "uris", b"uris"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["status", b"status", "uris", b"uris"]) -> None: ...

global___Releases = Releases
