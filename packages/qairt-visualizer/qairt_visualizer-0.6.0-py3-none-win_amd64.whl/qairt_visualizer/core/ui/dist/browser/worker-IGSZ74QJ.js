var Q={};Q.layout=(i,c,g,b)=>{let D=0,q=e=>{let d=++D;return e+d},X=e=>{if(Array.isArray(e)&&e.every(t=>!Array.isArray(t)))return e;let d=[];for(let t of e){if(!Array.isArray(t)){d.push(t);continue}for(let l of t)d.push(l)}return d},j=(e,d,t,l)=>{let f="";do f=q(l);while(e.hasNode(f));return t.dummy=d,e.setNode(f,t),f},W=e=>{let d=new Q.Graph(!0,!1);for(let t of e.nodes.values()){let l=t.v;e.hasChildren(l)||d.setNode(l,t.label)}for(let t of e.edges.values())d.setEdge(t.v,t.w,t.label);return d},re=e=>{let d=Number.NEGATIVE_INFINITY;for(let t of e.nodes.values()){let l=t.label.rank;l!==void 0&&l>d&&(d=l)}return d===Number.NEGATIVE_INFINITY?void 0:d},se=e=>{let d=re(e),t=d===void 0?0:d+1,l=Array.from(new Array(t),()=>[]);for(let f of e.nodes.values()){let o=f.label,h=o.rank;h!==void 0&&(l[h][o.order]=f.v)}return l},ce=(e,d,t)=>{t.ranksep/=2;let l=t.rankdir;for(let f of e.edges.values()){let o=f.label;o.minlen*=2,o.labelpos.toLowerCase()!=="c"&&(l==="TB"||l==="BT"?o.width+=o.labeloffset:o.height+=o.labeloffset)}},Re=e=>{for(let d of e.edges.values())if(d.v===d.w){let t=d.vNode.label;t.selfEdges||(t.selfEdges=[]),t.selfEdges.push({e:d,label:d.label}),e.removeEdge(d)}},Oe=e=>{let d=[],t=new Set,l=new Set,f=Array.from(e.nodes.keys()).reverse();for(;f.length>0;){let o=f.pop();if(Array.isArray(o))l.delete(o[0]);else if(!t.has(o)){t.add(o),l.add(o),f.push([o]);let h=e.node(o).out;for(let m=h.length-1;m>=0;m--){let I=h[m];l.has(I.w)&&d.push(I),f.push(I.w)}}}for(let o of d){let h=o.label;e.removeEdge(o),h.forwardName=o.name,h.reversed=!0,e.setEdge(o.w,o.v,h,q("rev"))}},De=e=>{for(let d of e.edges.values()){let t=d.label;if(t.reversed){t.points.reverse(),e.removeEdge(d);let l=t.forwardName;delete t.reversed,delete t.forwardName,e.setEdge(d.w,d.v,t,l)}}},ie=(e,d)=>d.wNode.label.rank-d.vNode.label.rank-d.label.minlen,Ge=e=>{e=W(e);let d=f=>{let o=new Q.Graph(!1,!1),h=f.nodes.keys().next().value,m=f.nodes.size;o.setNode(h,{});let I=(N,M)=>{let R=Array.from(N.nodes.keys()).reverse();for(;R.length>0;){let C=R.pop(),H=M.node(C);for(let _ of H.in.concat(H.out)){let P=_.v,Y=C===P?_.w:P;!N.hasNode(Y)&&!ie(M,_)&&(N.setNode(Y,{}),N.setEdge(C,Y,{}),R.push(Y))}}return N.nodes.size};for(;I(o,f)<m;){let N=Number.MAX_SAFE_INTEGER,M=null;for(let C of f.edges.values())if(o.hasNode(C.v)!==o.hasNode(C.w)){let H=ie(f,C);H<N&&(N=H,M=C)}let R=o.hasNode(M.v)?ie(f,M):-ie(f,M);for(let C of o.nodes.keys())f.node(C).label.rank+=R}return o},t=f=>{let o=new Set,h=[Array.from(f.nodes.values()).filter(m=>m.in.length===0).reverse()];for(;h.length>0;){let m=h[h.length-1];if(Array.isArray(m)){let I=m.pop();if(m.length===0&&h.pop(),!o.has(I)){o.add(I);let N=I.out.map(M=>M.wNode);N.length>0?(h.push(I),h.push(N.reverse())):I.label.rank=0}}else{h.pop();let I=Number.MAX_SAFE_INTEGER;for(let N of m.out)I=Math.min(I,N.wNode.label.rank-N.label.minlen);m.label.rank=I}}},l=f=>{let o=_=>{let P=new Q.Graph(!0,!1);for(let Y of _.nodes.values())P.setNode(Y.v,Y.label);for(let Y of _.edges.values()){let p=P.edge(Y.v,Y.w),L=p?p.label:{weight:0,minlen:1},v=Y.label;P.setEdge(Y.v,Y.w,{weight:L.weight+v.weight,minlen:Math.max(L.minlen,v.minlen)})}return P},h=(_,P)=>{let Y=(L,v,A)=>{let a=1,s=new Map,r=[[A,null,0]];for(;r.length>0;){let[n,u,w]=r.pop();if(w===0){if(!v.has(n)){v.add(n);let y=L.node(n).label,T=a;s.set(n,{label:y,low:T,parent:u,lim:null}),r.push([n,u,1]);for(let E of L.neighbors(n))v.has(E)||r.push([E,n,0])}}else{let y=s.get(n),T=y.label;T.low=y.low,T.lim=a++,y.parent?T.parent=y.parent:delete T.parent}}};P=_.nodes.keys().next().value,Y(_,new Set,P)},m=(_,P)=>{let Y=[],p=new Set,L=[Array.from(_.nodes.keys()).reverse()];for(;L.length>0;){let v=L[L.length-1];if(Array.isArray(v)){let A=v.pop();if(v.length===0&&L.pop(),!p.has(A)){p.add(A);let a=_.neighbors(A);a.size>0?(L.push(A),L.push(Array.from(a).reverse())):Y.push(A)}}else Y.push(L.pop())}for(let v of Y.slice(0,Y.length-1)){let a=_.node(v).label.parent,s=P.edge(v,a),r=!!s,u=(s?s.label:P.edge(a,v).label).weight,w=P.node(v);for(let y of w.in.concat(w.out)){let T=y.v===v,E=T?y.w:y.v;if(E!==a){let x=T===r;u+=x?y.label.weight:-y.label.weight;let O=_.edge(v,E);if(O){let k=O.label.cutvalue;u+=x?-k:k}}}_.edge(v,a).label.cutvalue=u}},I=_=>Array.from(_.edges.values()).find(P=>P.label.cutvalue<0),N=(_,P,Y)=>{let p=Y.v,L=Y.w;P.edge(p,L)||(p=Y.w,L=Y.v);let v=_.node(p).label,A=_.node(L).label,a=v,s=!1;v.lim>A.lim&&(a=A,s=!0);let r=(w,y)=>y.low<=w.lim&&w.lim<=y.lim,n=Number.POSITIVE_INFINITY,u=null;for(let w of P.edges.values())if(s===r(_.node(w.v).label,a)&&s!==r(_.node(w.w).label,a)){let y=ie(P,w);y<n&&(n=y,u=w)}return u},M=(_,P,Y,p)=>{_.removeEdge(Y),_.setEdge(p.v,p.w,{}),h(_),m(_,P);let v=[Array.from(_.nodes.keys()).find(s=>!P.node(s).label.parent)],A=new Set;for(;v.length>0;){let s=v.pop();if(!A.has(s)){A.add(s);let r=Array.from(_.neighbors(s));for(let n=r.length-1;n>=0;n--)v.push(r[n])}}let a=Array.from(A);for(let s of a.slice(1)){let r=_.node(s).label.parent,n=P.edge(s,r),u=!1;n||(n=P.edge(r,s),u=!0),P.node(s).label.rank=P.node(r).label.rank+(u?n.label.minlen:-n.label.minlen)}};f=o(f),t(f);let R=d(f);h(R),m(R,f);let C=null,H=null;for(;C=I(R);)H=N(R,f,C),M(R,f,C,H)};switch(g.ranker){case"tight-tree":t(e),d(e);break;case"longest-path":t(e);break;default:l(e);break}},Me=e=>{for(let d of e.edges.values()){let t=d.label;if(t.width&&t.height){let l=d.vNode.label,f=d.wNode.label;j(e,"edge-proxy",{rank:(f.rank-l.rank)/2+l.rank,e:d},"_ep")}}},Ve=(e,d)=>{if(e.nodes.size>0){let t=Number.MAX_SAFE_INTEGER,l=Number.MIN_SAFE_INTEGER,f=Array.from(e.nodes.values());for(let h of f){let m=h.label;m.rank!==void 0&&(t=Math.min(t,m.rank),l=Math.max(l,m.rank))}let o=l-t;if(o>0){let h=new Array(o);for(let N of f){let M=N.label;if(M.rank!==void 0){let R=M.rank-t;h[R]||(h[R]=[]),h[R].push(N.v)}}let m=0,I=d.nodeRankFactor;for(let N=0;N<h.length;N++){let M=h[N];if(M===void 0&&N%I!==0)m--;else if(m&&M)for(let R of M)e.node(R).label.rank+=m}}}},Se=(e,d)=>{let t=j(e,"root",{},"_root"),l=N=>{let M={},R=(C,H)=>{for(let _ of N.children(C))R(_,H+1);M[C]=H};for(let C of N.children())R(C,1);return M},f=(N,M,R,C,H,_,P)=>{let Y=Array.from(N.children(P));if(!Y.length){P!==M&&N.setEdge(M,P,{weight:0,minlen:R});return}let p=j(N,"border",{width:0,height:0},"_bt"),L=j(N,"border",{width:0,height:0},"_bb"),v=N.node(P).label;N.hasBorder=!0,N.setParent(p,P),v.borderTop=p,N.setParent(L,P),v.borderBottom=L;for(let A of Y){f(N,M,R,C,H,_,A);let a=N.node(A).label,s=a.borderTop?a.borderTop:A,r=a.borderBottom?a.borderBottom:A,n=a.borderTop?C:2*C,u=s===r?H-_[P]+1:1;N.setEdge(p,s,{weight:n,minlen:u,nestingEdge:!0}),N.setEdge(r,L,{weight:n,minlen:u,nestingEdge:!0})}N.parent(P)||N.setEdge(M,p,{weight:0,minlen:H+_[P]})},o=l(e),h=Math.max(...Object.values(o))-1,m=2*h+1;d.nestingRoot=t;for(let N of e.edges.values())N.label.minlen*=m;let I=Array.from(e.edges.values()).reduce((N,M)=>N+M.label.weight,0)+1;for(let N of e.children())f(e,t,m,I,h,o,N);d.nodeRankFactor=m},Ce=(e,d)=>{e.removeNode(d.nestingRoot),delete d.nestingRoot;for(let t of e.edges.values())t.label.nestingEdge&&e.removeEdge(t)},Pe=(e,d)=>{let t=Number.POSITIVE_INFINITY;for(let f of e.nodes.values()){let o=f.label.rank;o!==void 0&&o<t&&(t=o)}for(let f of e.nodes.values()){let o=f.label;o.rank!==void 0&&(o.rank-=t)}let l=0;if(e.hasBorder)for(let f of e.nodes.values()){let o=f.label;o.borderTop&&(o.minRank=e.node(o.borderTop).label.rank,o.maxRank=e.node(o.borderBottom).label.rank,l=Math.max(l,o.maxRank))}d.maxRank=l},qe=(e,d)=>{d.dummyChains=[];for(let t of e.edges.values()){let l=t.v,f=t.w,o=t.name,h=t.label,m=h.labelRank,I=e.node(l).label.rank,N=e.node(f).label.rank;if(N!==I+1){e.removeEdge(t);let M=!0;for(I++;I<N;){h.points=[],delete t.key;let R={width:0,height:0,edgeLabel:h,edgeObj:t,rank:I},C=j(e,"edge",R,"_d");I===m&&(R.width=h.width,R.height=h.height,R.dummy="edge-label",R.labelpos=h.labelpos),e.setEdge(l,C,{weight:h.weight},o),M&&(d.dummyChains.push(C),M=!1),l=C,I++}e.setEdge(l,f,{weight:h.weight},o)}}},Ye=(e,d)=>{for(let t of d.dummyChains){let l=e.node(t).label,f=l.edgeLabel,o=l.edgeObj;for(e.setEdge(o.v,o.w,f,o.name);l.dummy;){let h=e.successors(t).keys().next().value;e.removeNode(t),f.points.push({x:l.x,y:l.y}),l.dummy==="edge-label"&&(f.x=l.x,f.y=l.y,f.width=l.width,f.height=l.height),t=h,l=e.node(t).label}}},ze=e=>{for(let d of e.nodes.values()){let t=d.label;t.dummy==="edge-proxy"&&(t.e.label.labelRank=t.rank,e.removeNode(d.v))}},Fe=(e,d)=>{let t=(o,h,m,I)=>{let N=Math.min(h[m].low,h[I].low),M=Math.max(h[m].lim,h[I].lim),R=m,C=[];do R=o.parent(R),C.push(R);while(R&&(h[R].low>N||M>h[R].lim));let H=R;R=I;let _=[];for(;(R=o.parent(R))!==H;)_.push(R);return{path:C.concat(_.reverse()),lca:H}},f=(o=>{let h={},m=0,I=N=>{let M=m;for(let R of o.children(N))I(R);h[N]={low:M,lim:m++}};for(let N of o.children())I(N);return h})(e);for(let o of d.dummyChains||[]){let m=e.node(o).label.edgeObj,I=t(e,f,m.v,m.w),N=I.path,M=I.lca,R=0,C=N[R],H=!0;for(;o!==m.w;){let _=e.node(o).label;if(H){for(;(C=N[R])!==M&&e.node(C).label.maxRank<_.rank;)R++;C===M&&(H=!1)}if(!H){for(;R<N.length-1&&e.node(N[R+1]).label.minRank<=_.rank;)R++;C=N[R]}e.setParent(o,C),o=e.successors(o).keys().next().value}}},He=e=>{let d=(l,f,o,h,m,I)=>{let N={width:0,height:0,rank:I,borderType:f},M=m[f][I-1],R=j(l,"border",N,o);m[f][I]=R,l.setParent(R,h),M&&l.setEdge(M,R,{weight:1})},t=Array.from(e.children());for(let l=0;l<t.length;l++){let f=t[l],o=e.node(f).label;if("minRank"in o){o.borderLeft=[],o.borderRight=[];let m=o.maxRank+1;for(let I=o.minRank;I<m;I++)d(e,"borderLeft","_bl",f,o,I),d(e,"borderRight","_br",f,o,I)}let h=e.children(f);for(let m of h)t.push(m)}},Be=e=>{let d=(p,L,v,A)=>{let a=(k,G)=>{let S=new Map;for(let V=0;V<k.length;V++){let F=k[V],Z={indegree:0,in:[],out:[],vs:[F.v],i:V};F.barycenter!==void 0&&(Z.barycenter=F.barycenter,Z.weight=F.weight),S.set(F.v,Z)}for(let V of G.edges.values()){let F=S.get(V.v),Z=S.get(V.w);F&&Z&&(Z.indegree++,F.out.push(Z))}let z=Array.from(S.values()).filter(V=>!V.indegree),$=[],B=function(V){return function(F){if(!F.merged&&(F.barycenter===void 0||V.barycenter===void 0||F.barycenter>=V.barycenter)){let Z=0,te=0;V.weight&&(Z+=V.barycenter*V.weight,te+=V.weight),F.weight&&(Z+=F.barycenter*F.weight,te+=F.weight),V.vs=F.vs.concat(V.vs),V.barycenter=Z/te,V.weight=te,V.i=Math.min(F.i,V.i),F.merged=!0}}},K=V=>function(F){F.in.push(V),--F.indegree===0&&z.push(F)};for(;z.length;){let V=z.pop();$.push(V),V.in.reverse().forEach(B(V)),V.out.forEach(K(V))}return $.filter(V=>!V.merged).map(V=>{let F={vs:V.vs,i:V.i};return V.barycenter!==void 0&&(F.barycenter=V.barycenter),V.weight!==void 0&&(F.weight=V.weight),F})},s=(k,G)=>Array.from(G).map(S=>{let z=k.node(S).in;if(!z.length)return{v:S};let $=z.reduce((B,K)=>{let V=K.label,F=K.vNode.label;return{sum:B.sum+V.weight*F.order,weight:B.weight+V.weight}},{sum:0,weight:0});return{v:S,barycenter:$.sum/$.weight,weight:$.weight}}),r=(k,G)=>{let S=(J,ee,ne)=>{let xe=null;for(;ee.length&&(xe=ee[ee.length-1]).i<=ne;)ee.pop(),J.push(xe.vs),ne++;return ne},z=J=>function(ee,ne){return ee.barycenter<ne.barycenter?-1:ee.barycenter>ne.barycenter?1:J?ne.i-ee.i:ee.i-ne.i},$={lhs:[],rhs:[]};for(let J of k)"barycenter"in J?$.lhs.push(J):$.rhs.push(J);let B=$.lhs,K=$.rhs.sort((J,ee)=>-J.i+ee.i),V=[],F=0,Z=0,te=0;B.sort(z(!!G)),te=S(V,K,te);for(let J of B)te+=J.vs.length,V.push(J.vs),F+=J.barycenter*J.weight,Z+=J.weight,te=S(V,K,te);let pe={vs:X(V)};return Z&&(pe.barycenter=F/Z,pe.weight=Z),pe},n=p.node(L),u=n&&n.label?n.label.borderLeft:void 0,w=n&&n.label?n.label.borderRight:void 0,y={},T=u?Array.from(p.children(L)).filter(k=>k!==u&&k!==w):p.children(L),E=s(p,T);for(let k of E)if(p.hasChildren(k.v)){let G=d(p,k.v,v,A);y[k.v]=G,"barycenter"in G&&(k.barycenter===void 0?(k.barycenter=G.barycenter,k.weight=G.weight):(k.barycenter=(k.barycenter*k.weight+G.barycenter*G.weight)/(k.weight+G.weight),k.weight+=G.weight))}let x=a(E,v);for(let k of x)k.vs=X(k.vs.map(G=>y[G]?y[G].vs:G));let O=r(x,A);if(u){O.vs=X([u,O.vs,w]);let k=p.predecessors(u);if(k.size>0){let G=p.node(k.keys().next().value).label,S=p.node(p.predecessors(w).keys().next().value).label;"barycenter"in O||(O.barycenter=0,O.weight=0),O.barycenter=(O.barycenter*O.weight+G.order+S.order)/(O.weight+2),O.weight+=2}}return O},t=(p,L)=>{let v=new Q.Graph(!0,!1);for(let A of p){let a=A.root,r=d(A,a,v,L).vs,n=r.length;for(let T=0;T<n;T++)A.node(r[T]).label.order=T;let u={},w="",y=!1;for(let T of r){let E=A.parent(T),x=null;for(;E;){let O=A.parent(E);if(O?(x=u[O],u[O]=E):(x=w,w=E),x&&x!==E){v.setEdge(x,E,null),y=!0;break}E=O}if(y)break}}},l=(p,L,v)=>{let A=0;for(let a=1;a<L.length;a++){let s=L[a-1],r=L[a],n=new Map;for(let E=0;E<r.length;E++)n.set(r[E],E);let u=[];for(let E of s){let x=[];for(let O of p.node(E).out)x.push({pos:n.get(O.w),weight:O.label.weight});x.sort((O,k)=>O.pos-k.pos);for(let O of x)u.push(O)}let w=1;for(;w<r.length;)w<<=1;let y=2*w-1;w-=1;let T=Array.from(new Array(y),()=>0);for(let E of u){let x=E.pos+w;T[x]+=E.weight;let O=0;for(;x>0;)x%2&&(O+=T[x+1]),x=x-1>>1,T[x]+=E.weight;A+=E.weight*O}if(A>v)break}return A},f=p=>{let L=new Set,v=Array.from(p.nodes.values()).filter(a=>!p.hasChildren(a.v)),A=-1;for(let a of v){let s=a.label.rank;(A===-1||s!==void 0&&s>A)&&(A=s)}if(A!==-1){let a=Array.from(new Array(A+1),()=>[]),s=v.sort((r,n)=>r.label.rank-n.label.rank).map(r=>r.v).reverse();for(let r=0;r<s.length;r++){let n=s[r];if(!L.has(n)){L.add(n);let u=p.node(n).label.rank;a[u].push(n),s.push(...p.successors(n).keys())}}return a}return[]},o=(p,L,v,A,a)=>{let s="";for(;p.hasNode(s=q("_root")););let r=new Q.Graph(!0,!0);r.root=s,r.setDefaultNodeLabel(u=>{let w=p.node(u);return w?w.label:void 0});let n=L.length;if(p.hasBorder){let u=0;for(;u<n;){let w=L[u++],y=w.label;if(y.rank===A||"minRank"in y&&"maxRank"in y&&y.minRank<=A&&A<=y.maxRank){let T=w.v;r.setNode(T);let E=p.parent(T);if(r.setParent(T,E||s),a)for(let x of w.in)r.setEdge(x.v,T,{weight:x.label.weight});else for(let x of w.out)r.setEdge(x.w,T,{weight:x.label.weight});"minRank"in y&&r.setNode(T,{borderLeft:y.borderLeft[A],borderRight:y.borderRight[A]})}}}else{let u=v.get(A);for(;u<n;){let w=L[u++];if(w.label.rank!==A)break;let T=w.v;r.setNode(T);let E=p.parent(T);if(r.setParent(T,E||s),a)for(let x of w.in)r.setEdge(x.v,T,{weight:x.label.weight});else for(let x of w.out)r.setEdge(x.w,T,{weight:x.label.weight})}}return r},h=f(e),m=(p,L)=>{for(let v of L)for(let A=0;A<v.length;A++)p.node(v[A]).label.order=A};m(e,h);let I=re(e)||0,N=new Array(I),M=new Array(I),R=Array.from(e.nodes.values()),C=null;if(!e.hasBorder){R.sort((p,L)=>p.label.rank-L.label.rank),C=new Map;for(let p=0;p<R.length;++p){let v=R[p].label.rank;C.has(v)||C.set(v,p)}}for(let p=0;p<I;p++)N[p]=o(e,R,C,p+1,!0),M[p]=o(e,R,C,I-p-1,!1);let H=Number.POSITIVE_INFINITY,_=[];for(let p=0,L=0;L<4;++p,++L){t(p%2?N:M,p%4>=2),h=se(e);let v=l(e,h,H);if(v<H){L=0;let A=h.length;_=new Array(A);for(let a=0;a<A;a++)_[a]=h[a].slice();H=v}}let P=(p,L)=>p<L?1:2;for(let p=4;p<_.length;p+=2){let L=_[p];for(let v=0;v<L.length;++v){let A=e.nodes.get(L[v]);if(A.in&&A.in.length===2){let a=A.in[0].vNode.in[0].vNode,s=A.in[1].vNode.in[0].vNode,r=[],n=0;for(let u=p-2;u>=0;u-=2){let w=_[u],y=w.indexOf(a.v),T=w.indexOf(s.v),E=P(y,T);if(n|=E,y===T||Math.abs(y-T)!==1||a.in.length!==1||s.in.length!==1||a.out.length!==1||s.out.length!==1){if(n===3){let x=E,O=u+2;for(;r.length!==0;){let k=r.pop(),G=r.pop(),S=_[O],z=_[O-1],$=z.indexOf(e.node(S[G]).in[0].v),B=z.indexOf(e.node(S[k]).in[0].v);P(G,k)!==x&&([S[G],S[k]]=[S[k],S[G]]),P($,B)!==x&&([z[$],z[B]]=[z[B],z[$]]),O+=2}}break}r.push(y,T),a=a.in[0].vNode.in[0].vNode,s=s.in[0].vNode.in[0].vNode}}}}let Y=(p,L,v)=>{let A=p.indexOf(L.v),a=p.indexOf(v.v);p[a]=L.v,p[A]=v.v};for(let p=0;p<_.length-2;p+=2){let L=_[p],v=_[p+1],A=_[p+2];for(let a=0;a<L.length;++a){let s=e.nodes.get(L[a]);if(s.out&&s.out.length>=2)for(let r=0;r<s.out.length-1;++r){let n=s.out[r].wNode,u=s.out[r+1].wNode,w=n.out[0].wNode,y=u.out[0].wNode;v.indexOf(n.v)<v.indexOf(u.v)^A.indexOf(w.v)<A.indexOf(y.v)&&Y(v,n,u)}}for(let a=0;a<A.length;++a){let s=e.nodes.get(A[a]);if(s.in&&s.in.length>=2)if(s.in.length===2){let r=s.in[0].vNode,n=s.in[1].vNode,u=r.in[0].vNode,w=n.in[0].vNode;v.indexOf(r.v)<v.indexOf(n.v)^L.indexOf(u.v)<L.indexOf(w.v)&&Y(v,r,n)}else{let r=[];for(let n=0;n<s.in.length;++n){let u=s.in[n].vNode,w=u.in[0].vNode,y=L.indexOf(w.v),T=v.indexOf(u.v);s.in[n].idx0=y,r.push(T)}s.in.sort((n,u)=>n.idx0-u.idx0),r.sort((n,u)=>n-u);for(let n=0;n<r.length;++n)v[r[n]]=s.in[n].v}}}for(let p=0;p<_.length-4;p+=2){let L=_[p],v=_[p+2],A=_[p+4];if(v.length>=2&&A.length>=2){let a=_[p+1],s=_[p+3];for(let r=0;r<L.length;++r){let n=e.nodes.get(L[r]);if(n.in&&n.out&&n.out.length>=2)for(let u=0;u<n.out.length-1;++u){let w=n.out[u].wNode,y=n.out[u+1].wNode,T=w.out[0].wNode,E=y.out[0].wNode;if(T.out.length===1&&E.out.length===1){let x=v.indexOf(T.v),O=v.indexOf(E.v);if(x+1===O){let k=T.out[0].wNode,G=E.out[0].wNode;if(k.out.length===1&&G.out.length===1){let S=k.out[0].wNode,z=G.out[0].wNode,$=A.indexOf(S.v),B=A.indexOf(z.v);$>B&&(Y(a,w,y),Y(v,T,E),Y(s,k,G),++u)}}}}}for(let r=0;r<v.length-1;++r){let n=e.nodes.get(v[r]);if(n.in&&n.out&&n.in.length===1&&n.out.length===1){let u=e.nodes.get(v[r+1]);if(u.in&&u.out&&u.in.length===1&&u.out.length===1){let w=n.in[0].vNode,y=u.in[0].vNode;if(w.in.length===1&&y.in.length===1){let T=w.in[0].vNode,E=y.in[0].vNode,x=L.indexOf(T.v),O=L.indexOf(E.v);if(O+1===x){let k=n.out[0].wNode,G=u.out[0].wNode;x=s.indexOf(k.v),O=s.indexOf(G.v),x+1===O&&k.out[0].wNode===G.out[0].wNode&&(Y(a,w,y),Y(v,n,u),Y(s,k,G),r+=1)}}}}}}}m(e,_)},Xe=e=>{let d=se(e);for(let t of d){let l=0;t.forEach((f,o)=>{let h=e.node(f).label;if(h.order=o+l,h.selfEdges){for(let m of h.selfEdges)j(e,"selfedge",{width:m.label.width,height:m.label.height,rank:h.rank,order:o+ ++l,e:m.e,label:m.label},"_se");delete h.selfEdges}})}},ye=e=>{for(let d of e.nodes.values()){let t=d.label,l=t.width;t.width=t.height,t.height=l}for(let d of e.edges.values()){let t=d.label,l=t.width;t.width=t.height,t.height=l}},$e=(e,d,t)=>{let l=t.rankdir.toLowerCase();(l==="lr"||l==="rl")&&ye(e)},je=(e,d,t)=>{let l=t.rankdir.toLowerCase();if(l==="bt"||l==="rl"){for(let f of e.nodes.values())f.label.y=-f.label.y;for(let f of e.edges.values()){let o=f.label;for(let h of o.points)h.y=-h.y;"y"in o&&(o.y=-o.y)}}if(l==="lr"||l==="rl"){let f=o=>{[o.x,o.y]=[o.y,o.x]};for(let o of e.nodes.values())f(o.label);for(let o of e.edges.values()){let h=o.label;for(let m of h.points)f(m);h.x!==void 0&&f(h)}ye(e)}},Ue=(e,d,t)=>{let l=(a,s,r)=>{s>r&&([s,r]=[r,s]);let n=a.get(s);n||(n=new Set,a.set(s,n)),n.add(r)},f=(a,s,r)=>(s>r&&([s,r]=[r,s]),a.has(s)&&a.get(s).has(r)),o=(a,s,r,n,u)=>{let w=s.nodesep,y=s.edgesep,T=new Q.Graph(!0,!1);for(let E of r){let x=null;for(let O of E){let k=n.get(O);if(T.setNode(k,{}),x){let G=n.get(x),S=a.node(O).label,z=a.node(x).label,$=0,B=0;if($+=S.width/2,"labelpos"in S)switch(S.labelpos){case"l":B=-S.width/2;break;case"r":B=S.width/2;break;default:throw new Q.Error(`Unsupported label position '${S.labelpos}'.`)}if(B&&($+=u?B:-B),B=0,$+=(S.dummy?y:w)/2,$+=(z.dummy?y:w)/2,$+=z.width/2,"labelpos"in z)switch(z.labelpos){case"l":B=z.width/2;break;case"r":B=-z.width/2;break;default:throw new Q.Error(`Unsupported label position '${z.labelpos}'.`)}B&&($+=u?B:-B);let K=T.edge(G,k),V=Math.max($,K?K.label:0);K?K.label=V:T.setEdge(G,k,V)}x=O}}return T},h=(a,s,r)=>{let n=new Map,u=new Map,w=new Map;for(let y of a){let T=0;for(let E of y)n.set(E,E),u.set(E,E),w.set(E,T),T++}for(let y of a){let T=-1;for(let E of y){let x=r(E);if(x.size>0){x=Array.from(x.keys()),x=x.sort((G,S)=>w.get(G)-w.get(S));let O=(x.length-1)/2.0000001,k=Math.ceil(O);for(let G=Math.floor(O);G<=k;G++){let S=x[G];if(u.get(E)===E&&T<w.get(S)&&!f(s,E,S)){let z=n.get(S);u.set(S,E),u.set(E,z),n.set(E,z),T=w.get(S)}}}}}return{root:n,align:u}},m=(a,s,r,n,u,w)=>{let y=o(a,s,r,n,w),T=w?"borderLeft":"borderRight",E=new Map;if(y.nodes.size>0){let x=Array.from(y.nodes.keys()),O=new Set;for(;x.length>0;){let k=x.pop();if(O.has(k)){let G=0;for(let S of y.node(k).in)G=Math.max(G,E.get(S.v)+S.label);E.set(k,G)}else O.add(k),x.push(k),x.push(...y.predecessors(k).keys())}}if(y.nodes.size>0){let x=Array.from(y.nodes.keys()),O=new Set;for(;x.length>0;){let k=x.pop();if(O.has(k)){let G=Number.POSITIVE_INFINITY;for(let z of y.node(k).out)G=Math.min(G,E.get(z.w)-z.label);let S=a.node(k).label;if(S.dummy)continue;G!==Number.POSITIVE_INFINITY&&S.borderType!==T&&E.set(k,Math.max(E.get(k),G))}else O.add(k),x.push(k),x.push(...y.successors(k).keys())}}for(let x of u.values())E.set(x,E.get(n.get(x)));return E},I=(a,s)=>{let r=new Map;if(s.length>0){let[n]=s;for(let u=1;u<s.length;u++){let w=s[u],y=0,T=0,E=n.length,x=w[w.length-1];for(let O=0;O<w.length;O++){let k=w[O],G=a.node(k).label.dummy?Array.from(a.predecessors(k).keys()).find(S=>a.node(S).label.dummy):null;if(G||k===x){let S=G?a.node(G).label.order:E;for(let z of w.slice(T,O+1))if(a.predecessors(z).size>0)for(let B of a.predecessors(z).keys()){let K=a.node(B).label,V=K.order;(V<y||S<V)&&!(K.dummy&&a.node(z).label.dummy)&&l(r,B,z)}T=O+1,y=S}}n=w}}return r},N=(a,s)=>{let r=new Map,n=(u,w,y,T,E)=>{for(let x=w;x<y;x++){let O=u[x];if(a.node(O).labeldummy)for(let k of a.predecessors(O).keys()){let G=a.node(k).label;G.dummy&&(G.order<T||G.order>E)&&l(r,k,O)}}};if(s.length>0){let[u]=s;for(let w=1;w<s.length;w++){let y=s[w],T=-1,E=0,x=0;y.forEach((O,k)=>{if(a.node(O).label.dummy==="border"){let G=a.predecessors(O);G.size>0&&(E=a.node(G.keys().next().value).label.order,n(y,x,k,T,E),x=k,T=E)}n(y,x,y.length,E,u.length)}),u=y}}return r};e=W(e);let M=se(e),R=t.ranksep,C=0;for(let a of M){let s=a.reduce((r,n)=>Math.max(r,e.node(n).label.height),0);for(let r of a)e.node(r).label.y=C+s/2;C+=s+R}let H=new Map([...I(e,M).entries(),...N(e,M).entries()]),_={};for(let a of["u","d"]){let s=a==="u"?M:Object.values(M).reverse();for(let r of["l","r"]){r==="r"&&(s=s.map(y=>Object.values(y).reverse()));let n=(a==="u"?e.predecessors:e.successors).bind(e),u=h(s,H,n),w=m(e,t,s,u.root,u.align,r==="r");if(r==="r")for(let[y,T]of w.entries(w))w.set(y,-T);_[a+r]=w}}let P=Number.POSITIVE_INFINITY,Y=null;for(let a of Object.values(_)){let s=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(let[u,w]of a.entries()){let y=e.node(u).label.width/2;s=Math.max(w+y,s),r=Math.min(w-y,r)}let n=s-r;n<P&&(P=n,Y=a)}let p=Y,L=a=>{let s=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;for(let n of a)n<s&&(s=n),n>r&&(r=n);return[s,r]},v=L(p.values(p));for(let a of["u","d"])for(let s of["l","r"]){let r=a+s,n=_[r];if(n!==p){let u=L(n.values()),w=s==="l"?v[0]-u[0]:v[1]-u[1];if(w){let y=new Map;for(let[T,E]of n.entries())y.set(T,E+w);_[r]=y}}}let A=t.align;if(A){let a=_[A.toLowerCase()];for(let s of _.ul.keys())e.node(s).label.x=a.get(s)}else for(let a of _.ul.keys()){let s=[_.ul.get(a),_.ur.get(a),_.dl.get(a),_.dr.get(a)].sort((r,n)=>r-n);e.node(a).label.x=(s[1]+s[2])/2}},We=e=>{for(let d of e.nodes.values()){let t=d.label;if(t.dummy==="selfedge"){let l=d.v,f=e.node(t.e.v).label,o=f.x+f.width/2,h=f.y,m=t.x-o,I=f.height/2;e.setEdge(t.e.v,t.e.w,t.label),e.removeNode(l),t.label.points=[{x:o+2*m/3,y:h-I},{x:o+5*m/6,y:h-I},{x:o+m,y:h},{x:o+5*m/6,y:h+I},{x:o+2*m/3,y:h+I}],t.label.x=t.x,t.label.y=t.y}}},Ze=e=>{for(let d of e.nodes.values()){let t=d.v;if(e.hasChildren(t)){let l=d.label,f=e.node(l.borderTop).label,o=e.node(l.borderBottom).label,h=e.node(l.borderLeft[l.borderLeft.length-1]).label,m=e.node(l.borderRight[l.borderRight.length-1]).label;l.width=Math.abs(m.x-h.x),l.height=Math.abs(o.y-f.y),l.x=h.x+l.width/2,l.y=f.y+l.height/2}}for(let d of e.nodes.values())d.label.dummy==="border"&&e.removeNode(d.v)},Ke=e=>{for(let d of e.edges.values()){let t=d.label;if("x"in t)switch((t.labelpos==="l"||t.labelpos==="r")&&(t.width-=t.labeloffset),t.labelpos){case"l":t.x-=t.width/2+t.labeloffset;break;case"r":t.x+=t.width/2+t.labeloffset;break;default:throw new Q.Error(`Unsupported label position '${t.labelpos}'.`)}}},Je=(e,d)=>{let t=Number.POSITIVE_INFINITY,l=0,f=Number.POSITIVE_INFINITY,o=0,h=m=>{let I=m.x,N=m.y,M=m.width,R=m.height;t=Math.min(t,I-M/2),l=Math.max(l,I+M/2),f=Math.min(f,N-R/2),o=Math.max(o,N+R/2)};for(let m of e.nodes.values())h(m.label);for(let m of e.edges.values()){let I=m.label;"x"in I&&h(I)}for(let m of e.nodes.values())m.label.x-=t,m.label.y-=f;for(let m of e.edges.values()){let I=m.label;for(let N of I.points)N.x-=t,N.y-=f;"x"in I&&(I.x-=t),"y"in I&&(I.y-=f)}d.width=l-t,d.height=o-f},Qe=e=>{let d=(t,l)=>{let f=t.x,o=t.y,h=l.x-f,m=l.y-o;if(h===0&&m===0)throw new Error("Not possible to find intersection inside of the rectangle");let I=t.width/2,N=t.height/2;return Math.abs(m)*I>Math.abs(h)*N?(N=m<0?-N:N,{x:f+N*h/m,y:o+N}):(I=h<0?-I:I,{x:f+I,y:o+I*m/h})};for(let t of e.edges.values()){let l=t.label,f=t.vNode.label,o=t.wNode.label,h=null,m=null;l.points?([h]=l.points,m=l.points[l.points.length-1]):(l.points=[],h=o,m=f),l.points.unshift(d(f,h)),l.points.push(d(o,m))}},oe=new Q.Graph(!0,!0);for(let e of i)oe.setNode(e.v,{width:e.width,height:e.height}),e.parent&&oe.setParent(e.v,e.parent);for(let e of c)oe.setEdge(e.v,e.w,{minlen:e.minlen||1,weight:e.weight||1,width:e.width||0,height:e.height||0,labeloffset:e.labeloffset||10,labelpos:e.labelpos||"r"});g={ranksep:50,edgesep:20,nodesep:50,rankdir:"tb",...g};let Ne=[ce,Re,Oe,Se,Ge,Me,Ve,Ce,Pe,ze,qe,Fe,He,Be,Xe,$e,Ue,We,Ze,Ye,Ke,je,Je,Qe,De];for(;Ne.length>0;)Ne.shift()(oe,b,g);for(let e of i){let d=oe.node(e.v).label;e.x=d.x,e.y=d.y,oe.hasChildren(e.v)&&(e.width=d.width,e.height=d.height)}for(let e of c){let d=oe.edge(e.v,e.w).label;e.points=d.points,"x"in d&&(e.x=d.x,e.y=d.y)}b.log&&(b.log=oe.toString())};Q.Graph=class{constructor(i,c){this.directed=i,this.compound=c,this._defaultNodeLabelFn=()=>{},this.nodes=new Map,this.edges=new Map,this.compound&&(this._parent=new Map,this._children=new Map,this._children.set("\0",new Map))}setDefaultNodeLabel(i){this._defaultNodeLabelFn=i}setNode(i,c){let g=this.nodes.get(i);if(g)c&&(g.label=c);else{let b={label:c||this._defaultNodeLabelFn(i),in:[],out:[],predecessors:new Map,successors:new Map,v:i};this.nodes.set(i,b),this.compound&&(this._parent.set(i,"\0"),this._children.set(i,new Map),this._children.get("\0").set(i,!0))}}node(i){return this.nodes.get(i)}hasNode(i){return this.nodes.has(i)}removeNode(i){let c=this.nodes.get(i);if(c){if(this.compound){this._children.get(this._parent.get(i)).delete(i),this._parent.delete(i);for(let g of this.children(i))this.setParent(g);this._children.delete(i)}for(let g of c.in.concat())this.removeEdge(g);for(let g of c.out.concat())this.removeEdge(g);this.nodes.delete(i)}}setParent(i,c){if(!this.compound)throw new Error("Cannot set parent in a non-compound graph");if(c){for(let g=c;g!==void 0;g=this.parent(g))if(g===i)throw new Error(`Setting ${c} as parent of ${i} would create a cycle.`);this.setNode(c)}else c="\0";this._children.get(this._parent.get(i)).delete(i),this._parent.set(i,c),this._children.get(c).set(i,!0)}parent(i){if(this.compound){let c=this._parent.get(i);if(c!=="\0")return c}return null}children(i){return this.compound?this._children.get(i===void 0?"\0":i).keys():i===void 0?this.nodes.keys():this.hasNode(i)?[]:null}hasChildren(i){return this.compound?this._children.get(i===void 0?"\0":i).size>0:i===void 0?this.nodes.size>0:!1}predecessors(i){return this.nodes.get(i).predecessors}successors(i){return this.nodes.get(i).successors}neighbors(i){let c=this.nodes.get(i),g=c.predecessors.keys(),b=c.successors.keys(),D=new Set;for(let q of g)D.add(q);for(let q of b)D.add(q);return D}edge(i,c){return this.edges.get(this._edgeKey(this.directed,i,c))}setEdge(i,c,g,b){let D=this._edgeKey(this.directed,i,c,b),q=this.edges.get(D);if(q)q.label=g;else{!this.directed&&i>c&&([i,c]=[c,i]);let X={label:g,v:i,w:c,name:b,key:D,vNode:null,wNode:null};this.edges.set(D,X),this.setNode(i),this.setNode(c);let j=this.nodes.get(c),W=this.nodes.get(i);X.wNode=j,X.vNode=W;let re=(se,ce)=>{se.set(ce,(se.get(ce)??0)+1)};re(j.predecessors,i),re(W.successors,c),j.in.push(X),W.out.push(X)}}removeEdge(i){let c=i.key,g=i.v,b=i.w,D=i.wNode,q=i.vNode;if(D.predecessors.has(g)){let W=D.predecessors.get(g);W===1?D.predecessors.delete(g):D.predecessors.set(g,W-1)}if(q.successors.has(b)){let W=q.successors.get(b);W===1?q.successors.delete(b):q.successors.set(b,W-1)}let X=D.in.findIndex(W=>W.key===c);X!==-1&&D.in.splice(X,1);let j=q.out.findIndex(W=>W.key===c);j!==-1&&q.out.splice(j,1),this.edges.delete(c)}_edgeKey(i,c,g,b){return!i&&c>g?b?`${g}:${c}:${b}`:`${g}:${c}:`:b?`${c}:${g}:${b}`:`${c}:${g}:`}toString(){return["[nodes]",Array.from(this.nodes.values()).map(i=>JSON.stringify(i.label)).join(`
`),"[edges]",Array.from(this.edges.values()).map(i=>JSON.stringify(i.label)).join(`
`),"[parents]",JSON.stringify(this._parent,null,2),"[children]",JSON.stringify(this._children,null,2)].join(`
`)}};var{layout:Ie,Graph:at}=Q;var ve=6,ae=30,Ee=12,fe=Ee+ve*2;var ke="--qds-node-category-uncategorized",U={DATA:"Data",NN_LAYER:"NN Layer",ACTIVATION:"Activation",POOLING:"Pooling",NORMALIZATION:"Normalization",MATH:"Math",SHAPE:"Shape",TRANSFORM:"Transform",QUANTIZATION:"Quantization",SYNTHETIC_LAYER:"Synthetic Layer",NAMESPACE_LAYER:"Namespace Layer",DEFAULT:"Default"},et={[U.DATA]:"--qds-node-category-data",[U.NN_LAYER]:"--qds-node-category-layer",[U.ACTIVATION]:"--qds-node-category-activation",[U.POOLING]:"--qds-node-category-pool",[U.NORMALIZATION]:"--qds-node-category-normalization",[U.MATH]:"--qds-node-category-math",[U.SHAPE]:"--qds-node-category-shape",[U.TRANSFORM]:"--qds-node-category-transform",[U.QUANTIZATION]:"--qds-node-category-quantization",[U.SYNTHETIC_LAYER]:"--qds-synthetic-layer-header-1",[U.NAMESPACE_LAYER]:"--qds-layer-header-1",[U.DEFAULT]:ke},ct={[U.NN_LAYER]:["conv","deconv","fc","dense","linear","lstm","gru","rnn","attention","transformer","embedding"],[U.ACTIVATION]:["relu","sigmoid","tanh","softmax","gelu","swish","elu","selu","activation"],[U.POOLING]:["pool","maxpool","avgpool"],[U.NORMALIZATION]:["norm","batchnorm","layernorm","groupnorm","instancenorm","rmsnorm","lrn"],[U.MATH]:["add","sub","mul","div","mod","pow","neg","abs","sin","cos","tan","asin","acos","atan","sinh","cosh","tanh","exp","log","sqrt","reciprocal","erf","sum","mean","max","min","reducesum","reducemean","reducemax","reducemin","reduceprod","reducel1","reducel2","reducelogsum","reducelogsumexp","reducesumsquare","equal","greater","less","greaterorequal","lessorequal","and","or","xor","not","floor","ceil","round","clip","sign","matmul","bitwiseand","bitwiseor","bitwisexor","bitwisenot","cumsum"],[U.SHAPE]:["reshape","shape","size","flatten"],[U.TRANSFORM]:["transpose","gather","slice","concat","split","cast","pad","tile","repeat","flip","squeeze","unsqueeze","expand"],[U.QUANTIZATION]:["quant","dequant","quantize","dequantize"]};function le(i){return i.children?.length>0}function he(i){let c=1/0,g=1/0,b=-1/0,D=-1/0;for(let j of i)c=Math.min(c,j.x),b=Math.max(b,j.x+(j.width??0)),g=Math.min(g,j.y),D=Math.max(D,j.y+(j.height??0));let q=b-c,X=D-g;return{x:c,y:g,width:q,height:X}}var tt={nodesep:20,ranksep:20};function de(i,c,g){let b={namespace:i.namespace,nodes:[],edges:[]},D=i.children.map(X=>{let{width:j,height:W}=c[X.id];return{v:X.id,x:void 0,y:void 0,globalX:void 0,globalY:void 0,width:j,height:W,data:X,currentGraph:b,parentGraph:g}}),q=i.edges.map(X=>({v:X.sourceNode.id,w:X.targetNode.id,data:X,points:[],globalPoints:[],globalEdgeBounds:void 0}));return b.nodes=D,b.edges=q,Ae(b),b}function be(i,c){if(i.nodes.find(g=>g.data.id===c))return i;for(let g of i.nodes)if(g.childGraph){let b=be(g.childGraph,c);if(b)return b}}function Ae(i){Ie(i.nodes,i.edges,tt,{}),i.nodes.forEach(c=>{c.x-=c.width/2,c.y-=c.height/2,c.globalX=c.x,c.globalY=c.y}),i.edges.forEach(c=>{c.globalPoints=c.points,c.globalEdgeBounds=he(c.globalPoints)})}function ot(i){let c=i.nodes,g=i.edges.flatMap(D=>D.points),b=[...c,...g];return he(b)}function Te(i){let c=ot(i);return{width:c.width+ae*2,height:c.height+ae*2+fe}}function me(i,c,g){let b=i.nodes.find(D=>D.data.id===c);if(b.expanded){let{width:D,height:q}=Te(b.childGraph);b.width=D,b.height=q}else b.width=g[b.data.id].width,b.height=g[b.data.id].height;if(Ae(i),b.data.parent){let D=b.data.parent.id;b.parentGraph&&me(b.parentGraph,D,g)}}function ge(i,c,g){let b=c.nodes.find(D=>D.data.id===i);!le(b.data)||b.expanded||(b.expanded=!0,b.childGraph=de(b.data,g,c),me(c,i,g))}function _e(i,c,g){let b=c.nodes.find(D=>D.data.id===i);!le(b.data)||!b.expanded||(b.expanded=!1,delete b.childGraph,me(c,i,g))}function Le(i,c){let g=nt(i),b={};for(let D=g.length-1;D>=0;D--)for(let q of g[D]){let X=st(q,b,c);b[q.id]=X,c[q.id]=Te(X)}return b[i.id]}function nt(i){let c=[],g=[i];for(;g.length;){let b=g.pop();c[b.depth]??=[],c[b.depth].push(b);for(let D of b.children)le(D)&&g.push(D)}return c}function st(i,c,g){let b=de(i,g);for(let D of b.nodes)if(D.currentGraph=b,le(D.data)){D.expanded=!0,D.childGraph=c[D.data.id];for(let q of D.childGraph.nodes)q.parentGraph=b}return b}function ue(i,c){for(let g of i.edges)g.globalPoints=g.points.map(b=>({x:b.x+c.x,y:b.y+c.y})),g.globalEdgeBounds=he(g.globalPoints);for(let g of i.nodes)g.globalX=g.x+c.x,g.globalY=g.y+c.y,g.childGraph&&ue(g.childGraph,{x:g.globalX+ae,y:g.globalY+ae+fe})}function rt(i){let{type:c,data:g}=i.data;switch(c){case 0:{let{layerNode:b,nodeDimensions:D}=g,q=de(b,D);postMessage({rootViewGraph:q});break}case 1:{let{rootViewGraph:b,clickedNodeId:D,nodeDimensions:q}=g;we(ge,b,D,q),postMessage({rootViewGraph:b});break}case 2:{let{rootViewGraph:b,clickedNodeId:D,nodeDimensions:q}=g;we(_e,b,D,q),postMessage({rootViewGraph:b});break}case 3:{let{hierarchyRoot:b,nodeDimensions:D}=g,q=Le(b,D);ue(q,{x:0,y:0}),postMessage({rootViewGraph:q});break}case 4:{let{hierarchyRoot:b,nodeDimensions:D}=g,q=de(b,D);postMessage({rootViewGraph:q});break}case 5:{let{rootViewGraph:b,ancestors:D,nodeDimensions:q}=g;for(let X of D)we(ge,b,X.id,q);postMessage({rootViewGraph:b});break}}}function we(i,c,g,b){let D=be(c,g);if(!D){console.error(`Graph cannot be updated - clicked node "${g}" was not found`);return}i(g,D,b),ue(c,{x:0,y:0})}addEventListener("message",rt);export{rt as messageHandler};
