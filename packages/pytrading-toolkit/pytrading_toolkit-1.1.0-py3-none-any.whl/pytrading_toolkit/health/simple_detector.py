#!/usr/bin/env python3
"""
Í∞ÑÎã®Ìïú Ï†êÍ≤Ä Í∞êÏßÄ ÏãúÏä§ÌÖú
ÏóÖÎπÑÌä∏ÏôÄ Î∞îÏù¥ÎπÑÌä∏ ÏãúÏä§ÌÖúÏóêÏÑú Í≥µÌÜµÏúºÎ°ú ÏÇ¨Ïö©
"""

import threading
import time
import requests
import json
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Optional, Any
import logging
from dataclasses import dataclass

from ..notifications.telegram import TelegramNotifier

logger = logging.getLogger(__name__)

@dataclass
class MaintenanceEvent:
    """Ï†êÍ≤Ä Ïù¥Î≤§Ìä∏ Ï†ïÎ≥¥"""
    timestamp: datetime
    event_type: str  # 'start', 'end', 'detected'
    duration_minutes: Optional[int] = None
    details: Optional[Dict] = None

class SimpleMaintenanceDetector:
    """Í∞ÑÎã®Ìïú Ï†êÍ≤Ä Í∞êÏßÄ ÏãúÏä§ÌÖú"""
    
    def __init__(self, system_name: str, telegram_notifier: Optional[TelegramNotifier] = None):
        self.system_name = system_name
        self.telegram_notifier = telegram_notifier
        self.telegram_enabled = telegram_notifier is not None
        
        # Ï†êÍ≤Ä Í∞êÏßÄ ÏÑ§Ï†ï
        self.config = {
            'check_interval': 30,           # Ï≤¥ÌÅ¨ Í∞ÑÍ≤© (Ï¥à)
            'api_timeout': 10,              # API ÌÉÄÏûÑÏïÑÏõÉ
            'max_retry_attempts': 3,        # ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàò
            'retry_delay': 5,               # Ïû¨ÏãúÎèÑ Í∞ÑÍ≤©
            'response_delay_threshold': 8.0, # ÏùëÎãµ ÏßÄÏó∞ ÏûÑÍ≥ÑÍ∞í
            'required_success': 3,          # ÏÑ±Í≥µ ÌïÑÏöî ÌöüÏàò
        }
        
        # Ï†êÍ≤Ä ÏÉÅÌÉú
        self.maintenance_active = False
        self.maintenance_start_time = None
        self.last_check_time = None
        self.consecutive_failures = 0
        self.consecutive_successes = 0
        
        # Ï†êÍ≤Ä Ïù¥Î†•
        self.maintenance_history: List[MaintenanceEvent] = []
        self.max_history_size = 100
        
        # Î™®ÎãàÌÑ∞ÎßÅ ÏÉÅÌÉú
        self.monitoring = False
        self.monitor_thread = None
        
        logger.info(f"{system_name} Í∞ÑÎã®Ìïú Ï†êÍ≤Ä Í∞êÏßÄ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def start_monitoring(self):
        """Ï†êÍ≤Ä Í∞êÏßÄ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë"""
        if self.monitoring:
            logger.warning("Ï†êÍ≤Ä Í∞êÏßÄ Î™®ÎãàÌÑ∞ÎßÅÏù¥ Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§")
            return
        
        self.monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
        
        logger.info(f"{self.system_name} Ï†êÍ≤Ä Í∞êÏßÄ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûëÎê®")
    
    def stop_monitoring(self):
        """Ï†êÍ≤Ä Í∞êÏßÄ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÎã®"""
        self.monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
        
        logger.info(f"{self.system_name} Ï†êÍ≤Ä Í∞êÏßÄ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÎã®Îê®")
    
    def _monitor_loop(self):
        """Ï†êÍ≤Ä Í∞êÏßÄ Î™®ÎãàÌÑ∞ÎßÅ Î£®ÌîÑ"""
        while self.monitoring:
            try:
                self._check_maintenance_status()
                time.sleep(self.config['check_interval'])
                
            except Exception as e:
                logger.error(f"Ï†êÍ≤Ä Í∞êÏßÄ Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò: {e}")
                time.sleep(self.config['check_interval'])
    
    def _check_maintenance_status(self):
        """Ï†êÍ≤Ä ÏÉÅÌÉú ÌôïÏù∏"""
        try:
            start_time = time.time()
            
            # API ÏÉÅÌÉú ÌôïÏù∏ (ÏãúÏä§ÌÖúÎ≥ÑÎ°ú Íµ¨ÌòÑ ÌïÑÏöî)
            status = self._check_api_status()
            
            response_time = time.time() - start_time
            
            if status['healthy']:
                self._handle_success(response_time)
            else:
                self._handle_failure(status, response_time)
            
            self.last_check_time = datetime.now(timezone.utc)
            
        except Exception as e:
            logger.error(f"Ï†êÍ≤Ä ÏÉÅÌÉú ÌôïÏù∏ Ïò§Î•ò: {e}")
            self._handle_failure({'error': str(e)}, 0)
    
    def _check_api_status(self) -> Dict[str, Any]:
        """API ÏÉÅÌÉú ÌôïÏù∏ (ÌïòÏúÑ ÌÅ¥ÎûòÏä§ÏóêÏÑú Íµ¨ÌòÑ)"""
        # Í∏∞Î≥∏ Íµ¨ÌòÑ: Ìï≠ÏÉÅ Ï†ïÏÉÅÏúºÎ°ú Í∞ÄÏ†ï
        return {
            'healthy': True,
            'response_time': 0.1,
            'status_code': 200
        }
    
    def _handle_success(self, response_time: float):
        """ÏÑ±Í≥µ Ï≤òÎ¶¨"""
        self.consecutive_failures = 0
        self.consecutive_successes += 1
        
        # Ï†êÍ≤Ä Ï¢ÖÎ£å Í∞êÏßÄ
        if self.maintenance_active and self.consecutive_successes >= self.config['required_success']:
            self._end_maintenance()
        
        # ÏùëÎãµ ÏãúÍ∞ÑÏù¥ ÎäêÎ¶∞ Í≤ΩÏö∞ Í≤ΩÍ≥†
        if response_time > self.config['response_delay_threshold']:
            logger.warning(f"API ÏùëÎãµÏù¥ ÎäêÎ¶ΩÎãàÎã§: {response_time:.2f}Ï¥à")
    
    def _handle_failure(self, status: Dict, response_time: float):
        """Ïã§Ìå® Ï≤òÎ¶¨"""
        self.consecutive_successes = 0
        self.consecutive_failures += 1
        
        # Ï†êÍ≤Ä ÏãúÏûë Í∞êÏßÄ
        if not self.maintenance_active and self.consecutive_failures >= self.config['required_success']:
            self._start_maintenance(status, response_time)
        
        # ÏùëÎãµ ÏãúÍ∞ÑÏù¥ Îß§Ïö∞ ÎäêÎ¶∞ Í≤ΩÏö∞
        if response_time > self.config['response_delay_threshold'] * 2:
            logger.warning(f"API ÏùëÎãµÏù¥ Îß§Ïö∞ ÎäêÎ¶ΩÎãàÎã§: {response_time:.2f}Ï¥à")
    
    def _start_maintenance(self, status: Dict, response_time: float):
        """Ï†êÍ≤Ä ÏãúÏûë Ï≤òÎ¶¨"""
        self.maintenance_active = True
        self.maintenance_start_time = datetime.now(timezone.utc)
        
        # Ï†êÍ≤Ä Ïù¥Î≤§Ìä∏ Í∏∞Î°ù
        event = MaintenanceEvent(
            timestamp=self.maintenance_start_time,
            event_type='start',
            details={
                'status': status,
                'response_time': response_time,
                'consecutive_failures': self.consecutive_failures
            }
        )
        self._add_maintenance_event(event)
        
        # ÏïåÎ¶º Ï†ÑÏÜ°
        message = f"üîß {self.system_name} Ï†êÍ≤Ä ÏãúÏûë Í∞êÏßÄ\n\n"
        message += f"üìä ÏÉÅÌÉú: {status.get('error', 'API ÏùëÎãµ Ïã§Ìå®')}\n"
        message += f"‚è±Ô∏è ÏùëÎãµÏãúÍ∞Ñ: {response_time:.2f}Ï¥à\n"
        message += f"üîÑ Ïó∞ÏÜç Ïã§Ìå®: {self.consecutive_failures}Ìöå"
        
        self._send_maintenance_alert(message)
        
        logger.warning(f"{self.system_name} Ï†êÍ≤Ä ÏãúÏûë Í∞êÏßÄÎê®")
    
    def _end_maintenance(self):
        """Ï†êÍ≤Ä Ï¢ÖÎ£å Ï≤òÎ¶¨"""
        if not self.maintenance_active:
            return
        
        end_time = datetime.now(timezone.utc)
        duration = (end_time - self.maintenance_start_time).total_seconds() / 60
        
        # Ï†êÍ≤Ä Ïù¥Î≤§Ìä∏ Í∏∞Î°ù
        event = MaintenanceEvent(
            timestamp=end_time,
            event_type='end',
            duration_minutes=int(duration),
            details={
                'start_time': self.maintenance_start_time.isoformat(),
                'consecutive_successes': self.consecutive_successes
            }
        )
        self._add_maintenance_event(event)
        
        # ÏïåÎ¶º Ï†ÑÏÜ°
        message = f"‚úÖ {self.system_name} Ï†êÍ≤Ä Ï¢ÖÎ£å Í∞êÏßÄ\n\n"
        message += f"‚è±Ô∏è Ï†êÍ≤Ä ÏãúÍ∞Ñ: {int(duration)}Î∂Ñ\n"
        message += f"üîÑ Ïó∞ÏÜç ÏÑ±Í≥µ: {self.consecutive_successes}Ìöå\n"
        message += f"üïê ÏãúÏûë: {self.maintenance_start_time.strftime('%H:%M:%S')}\n"
        message += f"üïê Ï¢ÖÎ£å: {end_time.strftime('%H:%M:%S')}"
        
        self._send_maintenance_alert(message)
        
        # ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        self.maintenance_active = False
        self.maintenance_start_time = None
        
        logger.info(f"{self.system_name} Ï†êÍ≤Ä Ï¢ÖÎ£å Í∞êÏßÄÎê® (ÏßÄÏÜçÏãúÍ∞Ñ: {int(duration)}Î∂Ñ)")
    
    def _add_maintenance_event(self, event: MaintenanceEvent):
        """Ï†êÍ≤Ä Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä"""
        self.maintenance_history.append(event)
        
        # Ïù¥Î†• ÌÅ¨Í∏∞ Ï†úÌïú
        if len(self.maintenance_history) > self.max_history_size:
            self.maintenance_history.pop(0)
    
    def _send_maintenance_alert(self, message: str):
        """Ï†êÍ≤Ä ÏïåÎ¶º Ï†ÑÏÜ°"""
        if self.telegram_enabled:
            try:
                self.telegram_notifier.send_message(message)
                logger.info("Ï†êÍ≤Ä ÏïåÎ¶º ÌÖîÎ†àÍ∑∏Îû® Ï†ÑÏÜ° ÏôÑÎ£å")
            except Exception as e:
                logger.error(f"Ï†êÍ≤Ä ÏïåÎ¶º ÌÖîÎ†àÍ∑∏Îû® Ï†ÑÏÜ° Ïã§Ìå®: {e}")
        
        # Î°úÍ∑∏ÏóêÎèÑ Í∏∞Î°ù
        logger.info(f"Ï†êÍ≤Ä ÏïåÎ¶º: {message}")
    
    def get_maintenance_status(self) -> Dict[str, Any]:
        """ÌòÑÏû¨ Ï†êÍ≤Ä ÏÉÅÌÉú Î∞òÌôò"""
        current_time = datetime.now(timezone.utc)
        
        # Ï†êÍ≤Ä ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        total_maintenance = len([e for e in self.maintenance_history if e.event_type == 'end'])
        total_duration = sum([e.duration_minutes or 0 for e in self.maintenance_history if e.event_type == 'end'])
        avg_duration = total_duration / total_maintenance if total_maintenance > 0 else 0
        
        # ÏµúÍ∑º Ï†êÍ≤Ä Ï†ïÎ≥¥
        recent_maintenance = None
        if self.maintenance_history:
            recent_maintenance = self.maintenance_history[-1]
        
        return {
            'system_name': self.system_name,
            'maintenance_active': self.maintenance_active,
            'monitoring_active': self.monitoring,
            'last_check_time': self.last_check_time.isoformat() if self.last_check_time else None,
            'consecutive_failures': self.consecutive_failures,
            'consecutive_successes': self.consecutive_successes,
            'statistics': {
                'total_count': total_maintenance,
                'avg_duration_minutes': int(avg_duration),
                'total_duration_minutes': total_duration
            },
            'recent_event': {
                'type': recent_maintenance.event_type if recent_maintenance else None,
                'timestamp': recent_maintenance.timestamp.isoformat() if recent_maintenance else None,
                'duration_minutes': recent_maintenance.duration_minutes if recent_maintenance else None
            } if recent_maintenance else None,
            'current_status': {
                'healthy': self.consecutive_failures < self.config['required_success'],
                'response_time': None,  # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑú ÏÑ§Ï†ï
                'last_error': None      # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑú ÏÑ§Ï†ï
            }
        }
    
    def is_maintenance_active(self) -> bool:
        """Ï†êÍ≤Ä Ï§ëÏù∏ÏßÄ ÌôïÏù∏"""
        return self.maintenance_active
    
    def get_maintenance_duration(self) -> Optional[int]:
        """ÌòÑÏû¨ Ï†êÍ≤Ä ÏßÄÏÜç ÏãúÍ∞Ñ (Î∂Ñ) Î∞òÌôò"""
        if not self.maintenance_active or not self.maintenance_start_time:
            return None
        
        duration = (datetime.now(timezone.utc) - self.maintenance_start_time).total_seconds() / 60
        return int(duration)
