(()=>{"use strict";var c;(function(e){e.UNKNOWN_ERROR="unknown-error",e.STATE_ERROR="state-error",e.SECURITY_ERROR="security-error",e.GET_OPTIONS_FAILED="get-options-failed",e.ABORTED="aborted",e.NOT_ALLOWED_OR_ABORTED="not-allowed-or-aborted",e.SERVER_ERROR="server-error",e.SUCCESS="success",e.BUSY="busy"})(c||(c={}));async function C(){let e=null;const t=document.getElementById("otp_webauthn_config");if(t)return e=JSON.parse(t.innerText),Object.freeze(e);throw new Error("otp_webauthn_config element not found")}function W(e,t){const o=document.querySelector(t)?.value||new URLSearchParams(window.location.search).get("next");if(o){const s=new URL(e,window.location.origin);return s.searchParams.set("next",o),s.toString()}return e}function y(e){const t=new Uint8Array(e);let n="";for(const s of t)n+=String.fromCharCode(s);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function T(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,o=t.padEnd(t.length+n,"="),s=atob(o),b=new ArrayBuffer(s.length),h=new Uint8Array(b);for(let l=0;l<s.length;l++)h[l]=s.charCodeAt(l);return b}function v(){return D.stubThis(globalThis?.PublicKeyCredential!==void 0&&typeof globalThis.PublicKeyCredential=="function")}const D={stubThis:e=>e};function P(e){const{id:t}=e;return{...e,id:T(t),transports:e.transports}}function N(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class d extends Error{constructor({message:t,code:n,cause:o,name:s}){super(t,{cause:o}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=s??o.name,this.code=n}}function U({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new d({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(n.authenticatorSelection?.requireResidentKey===!0)return new d({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&n.authenticatorSelection?.userVerification==="required")return new d({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(n.authenticatorSelection?.userVerification==="required")return new d({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new d({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new d({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return n.pubKeyCredParams.filter(s=>s.type==="public-key").length===0?new d({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new d({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const o=globalThis.location.hostname;if(N(o)){if(n.rp.id!==o)return new d({message:`The RP ID "${n.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new d({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new d({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new d({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class L{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const B=new L,K=["cross-platform","platform"];function k(e){if(e&&!(K.indexOf(e)<0))return e}async function x(e){!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useAutoRegister:n=!1}=e;if(!v())throw new Error("WebAuthn is not supported in this browser");const o={...t,challenge:T(t.challenge),user:{...t.user,id:T(t.user.id)},excludeCredentials:t.excludeCredentials?.map(P)},s={};n&&(s.mediation="conditional"),s.publicKey=o,s.signal=B.createNewAbortSignal();let b;try{b=await navigator.credentials.create(s)}catch(r){throw U({error:r,options:s})}if(!b)throw new Error("Registration was not completed");const{id:h,rawId:l,response:a,type:_}=b;let R;typeof a.getTransports=="function"&&(R=a.getTransports());let m;if(typeof a.getPublicKeyAlgorithm=="function")try{m=a.getPublicKeyAlgorithm()}catch(r){O("getPublicKeyAlgorithm()",r)}let f;if(typeof a.getPublicKey=="function")try{const r=a.getPublicKey();r!==null&&(f=y(r))}catch(r){O("getPublicKey()",r)}let i;if(typeof a.getAuthenticatorData=="function")try{i=y(a.getAuthenticatorData())}catch(r){O("getAuthenticatorData()",r)}return{id:h,rawId:y(l),response:{attestationObject:y(a.attestationObject),clientDataJSON:y(a.clientDataJSON),transports:R,publicKeyAlgorithm:m,publicKey:f,authenticatorData:i},type:_,clientExtensionResults:b.getClientExtensionResults(),authenticatorAttachment:k(b.authenticatorAttachment)}}function O(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function V(){if(!browserSupportsWebAuthn())return I.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return e?.isConditionalMediationAvailable===void 0?I.stubThis(new Promise(t=>t(!1))):I.stubThis(e.isConditionalMediationAvailable())}const I={stubThis:e=>e};function G({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new WebAuthnError({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new WebAuthnError({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const o=globalThis.location.hostname;if(isValidDomain(o)){if(n.rpId!==o)return new WebAuthnError({message:`The RP ID "${n.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new WebAuthnError({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function F(e){!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:n=!1,verifyBrowserAutofillInput:o=!0}=e;if(!browserSupportsWebAuthn())throw new Error("WebAuthn is not supported in this browser");let s;t.allowCredentials?.length!==0&&(s=t.allowCredentials?.map(toPublicKeyCredentialDescriptor));const b={...t,challenge:base64URLStringToBuffer(t.challenge),allowCredentials:s},h={};if(n){if(!await browserSupportsWebAuthnAutofill())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&o)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');h.mediation="conditional",b.allowCredentials=[]}h.publicKey=b,h.signal=WebAuthnAbortService.createNewAbortSignal();let l;try{l=await navigator.credentials.get(h)}catch(i){throw identifyAuthenticationError({error:i,options:h})}if(!l)throw new Error("Authentication was not completed");const{id:a,rawId:_,response:R,type:m}=l;let f;return R.userHandle&&(f=bufferToBase64URLString(R.userHandle)),{id:a,rawId:bufferToBase64URLString(_),response:{authenticatorData:bufferToBase64URLString(R.authenticatorData),clientDataJSON:bufferToBase64URLString(R.clientDataJSON),signature:bufferToBase64URLString(R.signature),userHandle:f},type:m,clientExtensionResults:l.getClientExtensionResults(),authenticatorAttachment:toAuthenticatorAttachment(l.authenticatorAttachment)}}function q(){return browserSupportsWebAuthn()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}(async function(){const e="passkey-register-button",t="passkey-register-status-message",n="visible",o="passkey-registration-placeholder",s="passkey-registration-unavailable-template",b="passkey-registration-available-template",h="otp_webauthn.register_start",l="otp_webauthn.register_complete",a="otp_webauthn.register_failed";async function _(f){const i=document.getElementById(e);if(!i)return;const r=i.textContent||gettext("Register a Passkey");i.addEventListener("click",async E=>{i.dispatchEvent(new CustomEvent(h,{bubbles:!0})),await u({buttonDisabled:!0,buttonLabel:gettext("Registering...")});const g=await fetch(f.beginRegistrationUrl,{method:"POST",credentials:"same-origin",headers:{"X-CSRFToken":f.csrfToken,Accept:"application/json"}});if(!g.ok){u({buttonDisabled:!1,buttonLabel:r,requestFocus:!0,statusEnum:c.GET_OPTIONS_FAILED,status:gettext("Registration failed. Unable to fetch registration options from server.")}),i.dispatchEvent(new CustomEvent(a,{detail:{response:g},bubbles:!0}));return}let p;try{p=await x({optionsJSON:await g.json()})}catch(A){if(console.error(A),A instanceof Error||A instanceof d){switch(A.name){case"AbortError":u({buttonDisabled:!1,buttonLabel:r,statusEnum:c.ABORTED,status:gettext("Registration aborted."),requestFocus:!0});break;case"InvalidStateError":u({buttonDisabled:!1,buttonLabel:r,statusEnum:c.STATE_ERROR,status:gettext("Registration failed. You most likely already have a Passkey registered for this site."),requestFocus:!0});break;case"NotAllowedError":u({buttonDisabled:!1,buttonLabel:r,statusEnum:c.NOT_ALLOWED_OR_ABORTED,status:gettext("Registration aborted or not allowed."),requestFocus:!0});break;case"SecurityError":u({buttonDisabled:!1,buttonLabel:r,statusEnum:c.SECURITY_ERROR,status:gettext("Registration failed. A technical problem occurred that prevents you from registering a Passkey for this site."),requestFocus:!0});break;default:throw u({buttonDisabled:!1,buttonLabel:r,statusEnum:c.UNKNOWN_ERROR,status:gettext("Registration failed. An unknown error occurred."),requestFocus:!0}),A}i.dispatchEvent(new CustomEvent(a,{detail:{error:A},bubbles:!0}));return}}u({buttonDisabled:!0,statusEnum:c.BUSY,buttonLabel:gettext("Finishing registration...")});const w=await fetch(f.completeRegistrationUrl,{method:"POST",headers:{"Content-Type":"application/json","X-CSRFToken":f.csrfToken},credentials:"same-origin",body:JSON.stringify(p)});if(!w.ok){u({buttonDisabled:!1,buttonLabel:r,statusEnum:c.SERVER_ERROR,status:gettext("Registration failed. The server was unable to verify this passkey."),requestFocus:!0}),i.dispatchEvent(new CustomEvent(a,{detail:{response:w},bubbles:!0}));return}if(!w.headers.get("content-type")?.includes("application/json")){u({buttonDisabled:!1,buttonLabel:r,statusEnum:c.SERVER_ERROR,status:gettext("Registration failed. A server error occurred."),requestFocus:!0}),i.dispatchEvent(new CustomEvent(a,{detail:{response:w},bubbles:!0}));return}const S=await w.json();if(S&&S.id)u({buttonDisabled:!1,buttonLabel:r,statusEnum:c.SUCCESS,status:gettext("Registration successful!"),requestFocus:!0}),i.dispatchEvent(new CustomEvent(l,{detail:{response:S,id:S.id},bubbles:!0}));else{const A=S.error||gettext("An error occurred during registration.");u({buttonDisabled:!1,buttonLabel:r,statusEnum:c.SERVER_ERROR,status:A,requestFocus:!0}),i.dispatchEvent(new CustomEvent(a,{detail:{response:w},bubbles:!0}))}});async function u(E){const g=document.getElementById(e);if(!g)return;const p=document.getElementById(t);g.disabled=E.buttonDisabled,g.textContent=E.buttonLabel,E.statusEnum?p.setAttribute("data-status-enum",E.statusEnum):p.removeAttribute("data-status-enum"),p&&(E.status?(g.setAttribute("aria-describedby",t),p.classList.add(n),p.textContent=E.status,p.setAttribute("aria-live","assertive"),E.requestFocus&&g.focus()):(g.removeAttribute("aria-describedby"),p.removeAttribute("aria-live"),p.classList.remove(n)))}}async function R(f){const i=document.getElementById(o),r=document.getElementById(b),u=document.getElementById(s);if(!i)throw new Error("Placeholder element not found");if(!r)throw new Error("Available template not found");if(f){const E=r.content.cloneNode(!0);i.replaceWith(E)}else if(u){const E=u.content.cloneNode(!0);i.replaceWith(E)}else i.remove()}const m=await C();if(v())await R(!0),await _(m);else{await R(!1);return}})()})();

//# sourceMappingURL=otp_webauthn_register.js.map