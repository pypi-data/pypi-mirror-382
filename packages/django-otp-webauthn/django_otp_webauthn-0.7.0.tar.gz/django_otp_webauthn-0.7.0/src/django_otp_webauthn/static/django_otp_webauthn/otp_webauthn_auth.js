(()=>{"use strict";var b;(function(e){e.UNKNOWN_ERROR="unknown-error",e.STATE_ERROR="state-error",e.SECURITY_ERROR="security-error",e.GET_OPTIONS_FAILED="get-options-failed",e.ABORTED="aborted",e.NOT_ALLOWED_OR_ABORTED="not-allowed-or-aborted",e.SERVER_ERROR="server-error",e.SUCCESS="success",e.BUSY="busy"})(b||(b={}));async function L(){let e=null;const t=document.getElementById("otp_webauthn_config");if(t)return e=JSON.parse(t.innerText),Object.freeze(e);throw new Error("otp_webauthn_config element not found")}function N(e,t){const l=document.querySelector(t)?.value||new URLSearchParams(window.location.search).get("next");if(l){const i=new URL(e,window.location.origin);return i.searchParams.set("next",l),i.toString()}return e}function I(){return V.stubThis(globalThis?.PublicKeyCredential!==void 0&&typeof globalThis.PublicKeyCredential=="function")}const V={stubThis:e=>e};class _ extends Error{constructor({message:t,code:o,cause:l,name:i}){super(t,{cause:l}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=i??l.name,this.code=o}}function M({error:e,options:t}){const{publicKey:o}=t;if(!o)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new WebAuthnError({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(o.authenticatorSelection?.requireResidentKey===!0)return new WebAuthnError({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&o.authenticatorSelection?.userVerification==="required")return new WebAuthnError({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(o.authenticatorSelection?.userVerification==="required")return new WebAuthnError({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new WebAuthnError({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new WebAuthnError({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return o.pubKeyCredParams.filter(i=>i.type==="public-key").length===0?new WebAuthnError({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new WebAuthnError({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const l=globalThis.location.hostname;if(isValidDomain(l)){if(o.rp.id!==l)return new WebAuthnError({message:`The RP ID "${o.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new WebAuthnError({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(o.user.id.byteLength<1||o.user.id.byteLength>64)return new WebAuthnError({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class B{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const o=new Error("Cancelling existing WebAuthn API call for new one");o.name="AbortError",this.controller.abort(o)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const k=new B;async function J(e){!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useAutoRegister:o=!1}=e;if(!browserSupportsWebAuthn())throw new Error("WebAuthn is not supported in this browser");const l={...t,challenge:base64URLStringToBuffer(t.challenge),user:{...t.user,id:base64URLStringToBuffer(t.user.id)},excludeCredentials:t.excludeCredentials?.map(toPublicKeyCredentialDescriptor)},i={};o&&(i.mediation="conditional"),i.publicKey=l,i.signal=WebAuthnAbortService.createNewAbortSignal();let f;try{f=await navigator.credentials.create(i)}catch(n){throw identifyRegistrationError({error:n,options:i})}if(!f)throw new Error("Registration was not completed");const{id:h,rawId:u,response:a,type:T}=f;let p;typeof a.getTransports=="function"&&(p=a.getTransports());let c;if(typeof a.getPublicKeyAlgorithm=="function")try{c=a.getPublicKeyAlgorithm()}catch(n){v("getPublicKeyAlgorithm()",n)}let g;if(typeof a.getPublicKey=="function")try{const n=a.getPublicKey();n!==null&&(g=bufferToBase64URLString(n))}catch(n){v("getPublicKey()",n)}let w;if(typeof a.getAuthenticatorData=="function")try{w=bufferToBase64URLString(a.getAuthenticatorData())}catch(n){v("getAuthenticatorData()",n)}return{id:h,rawId:bufferToBase64URLString(u),response:{attestationObject:bufferToBase64URLString(a.attestationObject),clientDataJSON:bufferToBase64URLString(a.clientDataJSON),transports:p,publicKeyAlgorithm:c,publicKey:g,authenticatorData:w},type:T,clientExtensionResults:f.getClientExtensionResults(),authenticatorAttachment:toAuthenticatorAttachment(f.authenticatorAttachment)}}function v(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function S(e){const t=new Uint8Array(e);let o="";for(const i of t)o+=String.fromCharCode(i);return btoa(o).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function P(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),o=(4-t.length%4)%4,l=t.padEnd(t.length+o,"="),i=atob(l),f=new ArrayBuffer(i.length),h=new Uint8Array(f);for(let u=0;u<i.length;u++)h[u]=i.charCodeAt(u);return f}function D(){if(!I())return C.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return e?.isConditionalMediationAvailable===void 0?C.stubThis(new Promise(t=>t(!1))):C.stubThis(e.isConditionalMediationAvailable())}const C={stubThis:e=>e};function x(e){const{id:t}=e;return{...e,id:P(t),transports:e.transports}}function K(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}function F({error:e,options:t}){const{publicKey:o}=t;if(!o)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new _({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new _({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const l=globalThis.location.hostname;if(K(l)){if(o.rpId!==l)return new _({message:`The RP ID "${o.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new _({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new _({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}const W=["cross-platform","platform"];function q(e){if(e&&!(W.indexOf(e)<0))return e}async function U(e){!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:o=!1,verifyBrowserAutofillInput:l=!0}=e;if(!I())throw new Error("WebAuthn is not supported in this browser");let i;t.allowCredentials?.length!==0&&(i=t.allowCredentials?.map(x));const f={...t,challenge:P(t.challenge),allowCredentials:i},h={};if(o){if(!await D())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&l)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');h.mediation="conditional",f.allowCredentials=[]}h.publicKey=f,h.signal=k.createNewAbortSignal();let u;try{u=await navigator.credentials.get(h)}catch(w){throw F({error:w,options:h})}if(!u)throw new Error("Authentication was not completed");const{id:a,rawId:T,response:p,type:c}=u;let g;return p.userHandle&&(g=S(p.userHandle)),{id:a,rawId:S(T),response:{authenticatorData:S(p.authenticatorData),clientDataJSON:S(p.clientDataJSON),signature:S(p.signature),userHandle:g},type:c,clientExtensionResults:u.getClientExtensionResults(),authenticatorAttachment:q(u.authenticatorAttachment)}}function j(){return browserSupportsWebAuthn()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}(async function(){const e="passkey-verification-button",t="passkey-verification-status-message",o="visible",l="passkey-verification-placeholder",i="passkey-verification-unavailable-template",f="passkey-verification-available-template",h="otp_webauthn.verification_start",u="otp_webauthn.verification_complete",a="otp_webauthn.verification_failed";async function T(n){if(!n.autocompleteLoginFieldSelector)return;const r=document.querySelector(n.autocompleteLoginFieldSelector);if(!r){console.error(`Could not find login field with selector ${n.autocompleteLoginFieldSelector}. WebAuthn autofill cannot continue.`);return}const s=r.getAttribute("autocomplete")||"";r.setAttribute("autocomplete",s+" webauthn"),r.dispatchEvent(new CustomEvent(h,{detail:{fromAutofill:!0},bubbles:!0}));const y=await fetch(n.beginAuthenticationUrl,{method:"POST",credentials:"same-origin",headers:{"X-CSRFToken":n.csrfToken,Accept:"application/json"}});if(!y.ok){console.error("Unable to fetch options from server. Will not attempt autofill."),r.dispatchEvent(new CustomEvent(a,{detail:{fromAutofill:!0,response:y},bubbles:!0}));return}let A;try{A=await U({optionsJSON:await y.json(),useBrowserAutofill:!0})}catch(E){console.error("Got error during the webauthn credential autofill call",E),r.dispatchEvent(new CustomEvent(a,{detail:{fromAutofill:!0,error:E},bubbles:!0}));return}const O=N(n.completeAuthenticationUrl,n.nextFieldSelector),R=await fetch(O,{method:"POST",headers:{"Content-Type":"application/json","X-CSRFToken":n.csrfToken},credentials:"same-origin",body:JSON.stringify(A)});if(!R.headers.get("content-type")?.includes("application/json")){r.dispatchEvent(new CustomEvent(a,{detail:{fromAutofill:!0,response:R},bubbles:!0})),alert(gettext("Verification failed. A server error occurred."));return}const d=await R.json();if(!R.ok&&"detail"in d){r.dispatchEvent(new CustomEvent(a,{detail:{fromAutofill:!0,response:R},bubbles:!0})),alert(d.detail);return}if(d&&d.id)r.dispatchEvent(new CustomEvent(u,{detail:{fromAutofill:!0,response:R},bubbles:!0})),d.redirect_url&&(window.location.href=d.redirect_url);else{r.dispatchEvent(new CustomEvent(a,{detail:{fromAutofill:!0,response:R},bubbles:!0}));const E=d.error||gettext("An error occurred during verification.");alert(E)}}async function p(n){const r=document.getElementById(e);if(!r)return;const s=r.textContent||gettext("Verify with Passkey");r.addEventListener("click",async y=>{r.dispatchEvent(new CustomEvent(h,{detail:{fromAutofill:!1},bubbles:!0})),await c({buttonDisabled:!0,statusEnum:b.BUSY,buttonLabel:gettext("Verifying...")});const A=await fetch(n.beginAuthenticationUrl,{method:"POST",credentials:"same-origin",headers:{"X-CSRFToken":n.csrfToken,Accept:"application/json"}});if(!A.ok){await c({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,statusEnum:b.GET_OPTIONS_FAILED,status:gettext("Verification failed. Could not retrieve parameters from the server.")}),r.dispatchEvent(new CustomEvent(a,{detail:{fromAutofill:!1,response:A},bubbles:!0}));return}let O;try{O=await U({optionsJSON:await A.json(),useBrowserAutofill:!1})}catch(m){if(m instanceof Error||m instanceof _){switch(console.error(m),m.name){case"AbortError":await c({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,statusEnum:b.ABORTED,status:gettext("Verification aborted.")});break;case"NotAllowedError":await c({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,statusEnum:b.NOT_ALLOWED_OR_ABORTED,status:gettext("Verification canceled or not allowed.")});break;default:throw await c({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,statusEnum:b.UNKNOWN_ERROR,status:gettext("Verification failed. An unknown error occurred.")}),m}r.dispatchEvent(new CustomEvent(a,{detail:{fromAutofill:!1,error:m},bubbles:!0}));return}}await c({buttonDisabled:!0,statusEnum:b.BUSY,buttonLabel:gettext("Finishing verification...")});const R=N(n.completeAuthenticationUrl,n.nextFieldSelector),d=await fetch(R,{method:"POST",headers:{"Content-Type":"application/json","X-CSRFToken":n.csrfToken},credentials:"same-origin",body:JSON.stringify(O)});if(!d.headers.get("content-type")?.includes("application/json")){await c({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,statusEnum:b.SERVER_ERROR,status:gettext("Verification failed. An unknown server error occurred.")}),r.dispatchEvent(new CustomEvent(a,{detail:{fromAutofill:!1,response:d},bubbles:!0}));return}const E=await d.json();if(!d.ok){const m=E.detail||gettext("Verification failed. An unknown error occurred.");await c({buttonDisabled:!1,buttonLabel:s,statusEnum:b.SERVER_ERROR,requestFocus:!0,status:m}),r.dispatchEvent(new CustomEvent(a,{detail:{fromAutofill:!1,response:d},bubbles:!0}));return}if(E&&E.id)await c({buttonDisabled:!1,buttonLabel:s,statusEnum:b.SUCCESS,status:gettext("Verification successful!")}),r.dispatchEvent(new CustomEvent(u,{detail:{fromAutofill:!1,response:d,id:E.id},bubbles:!0})),E.redirect_url&&(window.location.href=E.redirect_url);else{const m=E.error||gettext("An error occurred during verification.");await c({buttonDisabled:!1,buttonLabel:s,statusEnum:b.SERVER_ERROR,requestFocus:!0,status:m})}})}async function c(n){const r=document.getElementById(e);if(!r)return;const s=document.getElementById(t);r.disabled=n.buttonDisabled,r.textContent=n.buttonLabel,n.statusEnum?s.setAttribute("data-status-enum",n.statusEnum):s.removeAttribute("data-status-enum"),s&&(n.status?(r.setAttribute("aria-describedby",t),s.classList.add(o),s.textContent=n.status,s.setAttribute("aria-live","assertive"),n.requestFocus&&r.focus()):(r.removeAttribute("aria-describedby"),s.removeAttribute("aria-live"),s.classList.remove(o)))}async function g(n){const r=document.getElementById(l),s=document.getElementById(f),y=document.getElementById(i);if(!r)throw new Error("Placeholder element not found");if(!s)throw new Error("Available template not found");if(n){const A=s.content.cloneNode(!0);r.replaceWith(A)}else if(y){const A=y.content.cloneNode(!0);r.replaceWith(A)}else r.remove()}const w=await L();w.autocompleteLoginFieldSelector&&await D()&&T(w),I()?(await g(!0),p(w)):await g(!1)})()})();

//# sourceMappingURL=otp_webauthn_auth.js.map