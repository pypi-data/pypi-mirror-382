# Copyright NTESS. See COPYRIGHT file for details.
#
# SPDX-License-Identifier: MIT

# CMake module
include(CMakeParseArguments)

function(join_quoted ARG_IN ARG_OUT)
  list(GET ARG_IN 0 ARG_0)
  set(TMP "\"${ARG_0}\"")
  list(LENGTH ARG_IN N)
  if(N GREATER 1)
    list(SUBLIST ARG_IN 1 -1 ARG_X)
    foreach(ARG_I ${ARG_X})
      string(APPEND TMP ", \"${ARG_I}\"")
    endforeach()
  endif()
  set(${ARG_OUT} "${TMP}" PARENT_SCOPE)
endfunction()

# --- ADD_CANARY --------------------------------------------------------------------- #
function(add_canary_test)
  macro(_print_usage)
    set(USAGE_STR "\nADD_CANARY(NAME <name> <COMMAND <command>|SCRIPT <script>> ")
    string(APPEND USAGE_STR "[NO_DEFAULT_LINK] [LINK link1 [link2...]])\n")
    string(APPEND USAGE_STR "[KEYWORDS kwd1 [kwd2...]])\n")
    string(APPEND USAGE_STR "[DEPENDS_ON dep1 [dep2...]])\n")
    string(APPEND USAGE_STR "Add a canary unit test.\n")
    message("${USAGE_STR}")
  endmacro(_print_usage)
  cmake_parse_arguments(PARSED_ARGS "NO_DEFAULT_LINK" "NAME;SCRIPT" "COMMAND;LINK;KEYWORDS;DEPENDS_ON" ${ARGN})
  if(NOT PARSED_ARGS_NAME)
    _print_usage()
    message(FATAL_ERROR "Must define <name>")
  endif()
  set(NAME ${PARSED_ARGS_NAME})

  if(NOT PARSED_ARGS_COMMAND AND NOT PARSED_ARGS_SCRIPT)
    _print_usage()
    message(FATAL_ERROR "Must define exactly one of <command> or <script>")
  endif()

  if(PARSED_ARGS_COMMAND AND PARSED_ARGS_SCRIPT)
    _print_usage()
    message(FATAL_ERROR "Must define exactly one of <command> or <script>")
  endif()

  if(PARSED_ARGS_COMMAND)
    set(CONTENT "#!/usr/bin/env python3\nimport argparse\nimport sys\nimport canary\n")
    list(GET PARSED_ARGS_COMMAND 0 PROGRAM)
    string(APPEND CONTENT "canary.directives.set_attribute(program=\"${PROGRAM}\")\n")
    if(PARSED_ARGS_KEYWORDS)
      join_quoted("${PARSED_ARGS_KEYWORDS}" KWDS)
      string(APPEND CONTENT "canary.directives.keywords(${KWDS})\n")
    endif()
    if(NOT NO_DEFAULT_LINK)
      string(APPEND CONTENT "canary.directives.link(\"${PROGRAM}\")\n")
    endif()
    if(PARSED_ARGS_DEPENDS_ON)
      foreach(DEP ${PARSED_ARGS_DEPENDS_ON})
        string(APPEND CONTENT "canary.directives.depends_on(\"${DEP}\")\n")
      endforeach()
    endif()
    if(PARSED_ARGS_LINK)
      foreach(LINK_ARG ${PARSED_ARGS_LINK})
        string(APPEND CONTENT "canary.directives.link(\"${LINK_ARG}\")\n")
      endforeach()
    endif()

    string(APPEND CONTENT "def test():\n")
    if(MPIEXEC_EXECUTABLE_OVERRIDE)
      # Even though this is a serial test, we use the override mpiexec but run
      # with a single processor
      string(APPEND CONTENT "    cmd = canary.Executable(\"${MPIEXEC_EXECUTABLE_OVERRIDE}\")\n")
      if(MPIEXEC_NUMPROC_FLAG_OVERRIDE)
         string(APPEND CONTENT "    args = [\"${MPIEXEC_NUMPROC_FLAG_OVERRIDE}\", \"1\"]\n")
      elseif(MPIEXEC_NUMPROC_FLAG)
         string(APPEND CONTENT "    args = [\"${MPIEXEC_NUMPROC_FLAG}\", \"1\"]\n")
      else()
         string(APPEND CONTENT "    args = [\"-n\", \"1\"]\n")
      endif()
      if(MPIEXEC_PREFLAGS_OVERRIDE)
        string(APPEND CONTENT "    preflags = \"${MPIEXEC_PREFLAGS_OVERRIDE}\" % {\"cpus\": 1}\n")
        string(APPEND CONTENT "    args.extend(preflags.split())\n")
      endif()
      string(APPEND CONTENT "    args.append(\"${PROGRAM}\")\n")
    else()
      string(APPEND CONTENT "    cmd = canary.Executable(\"${PROGRAM}\")\n")
      string(APPEND CONTENT "    args = []\n")
    endif()
    list(LENGTH PARSED_ARGS_COMMAND N)
    if(N GREATER 1)
      list(SUBLIST PARSED_ARGS_COMMAND 1 -1 SUBTMP)
      join_quoted("${SUBTMP}" XTMP)
      string(APPEND CONTENT "    args.extend([${XTMP}])\n")
    endif()
    string(APPEND CONTENT "    try:\n")
    string(APPEND CONTENT "        cmd(*args, fail_on_error=False)\n")
    string(APPEND CONTENT "    except Exception:\n")
    string(APPEND CONTENT "        raise canary.TestFailed(\"${NAME}\")\n")
    string(APPEND CONTENT "    else:\n")
    string(APPEND CONTENT "        if cmd.returncode != 0:\n")
    string(APPEND CONTENT "            raise canary.TestFailed(\"${NAME}\")\n")
    string(APPEND CONTENT "    return 0\n")
    string(APPEND CONTENT "if __name__ == \"__main__\":\n")
    string(APPEND CONTENT "    p = canary.make_argument_parser()\n")
    string(APPEND CONTENT "    args = p.parse_args()\n")
    string(APPEND CONTENT "    if not args.execute_analysis_sections:\n")
    string(APPEND CONTENT "        sys.exit(test())\n")
    file(GENERATE OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${NAME}.pyt" CONTENT "${CONTENT}")
  else()
    get_filename_component(F ${PARSED_ARGS_SCRIPT} NAME_WE)
    configure_file("${PARSED_ARGS_SCRIPT}" "${CMAKE_CURRENT_BINARY_DIR}/${F}.pyt")
  endif()
endfunction()

# --- ADD_PARALLEL_CANARY ------------------------------------------------------------ #
function(add_parallel_canary_test)
  macro(_print_usage)
    set(USAGE_STR "\nADD_PARALLEL_CANARY(NAME <name> COMMAND <command> NPROC <nproc1 [nproc2...]> ")
    string(APPEND USAGE_STR "[NO_DEFAULT_LINK] [LINK link1 [link2...]])\n")
    string(APPEND USAGE_STR "[KEYWORDS kwd1 [kwd1...]])\n")
    string(APPEND USAGE_STR "[DEPENDS_ON dep1 [dep2...]])\n")
    string(APPEND USAGE_STR "Add a canary unit test.\n")
    message("${USAGE_STR}")
  endmacro(_print_usage)
  if(NOT MPI_FOUND)
    message(FATAL_ERROR "add_parallel_canary_test requires MPI")
  endif()
  cmake_parse_arguments(PARSED_ARGS "NO_DEFAULT_LINK" "NAME" "COMMAND;LINK;KEYWORDS;NPROC;DEPENDS_ON" ${ARGN})
  if(NOT PARSED_ARGS_NAME)
    _print_usage()
    message(FATAL_ERROR "Must define <name>")
  endif()
  set(NAME ${PARSED_ARGS_NAME})

  if(NOT PARSED_ARGS_COMMAND)
    _print_usage()
    message(FATAL_ERROR "Must define <command>")
  endif()

  if(NOT PARSED_ARGS_NPROC)
    _print_usage()
    message(FATAL_ERROR "Must define NPROC")
  endif()

  set(CONTENT "#!/usr/bin/env python3\nimport argparse\nimport sys\nimport canary\n")
  if(PARSED_ARGS_KEYWORDS)
    join_quoted("${PARSED_ARGS_KEYWORDS}" KWDS)
    string(APPEND CONTENT "canary.directives.keywords(${KWDS})\n")
  endif()
  list(GET PARSED_ARGS_COMMAND 0 PROGRAM)
  string(APPEND CONTENT "canary.directives.set_attribute(program=\"${PROGRAM}\")\n")
  if(NOT NO_DEFAULT_LINK)
    string(APPEND CONTENT "canary.directives.link(\"${PROGRAM}\")\n")
  endif()
  if(PARSED_ARGS_LINK)
    foreach(LINK_ARG ${PARSED_ARGS_LINK})
      string(APPEND CONTENT "canary.directives.link(\"${LINK_ARG}\")\n")
    endforeach()
  endif()
  if(PARSED_ARGS_DEPENDS_ON)
    foreach(DEP ${PARSED_ARGS_DEPENDS_ON})
      string(APPEND CONTENT "canary.directives.depends_on(\"${DEP}\")\n")
    endforeach()
  endif()
  list(JOIN PARSED_ARGS_NPROC ", " NPROC)
  string(APPEND CONTENT "canary.directives.parameterize(\"cpus\", [${NPROC}])\n")
  string(APPEND CONTENT "def test():\n")
  string(APPEND CONTENT "    self = canary.test.instance\n")

  if(MPIEXEC_EXECUTABLE_OVERRIDE)
    string(APPEND CONTENT "    mpi = canary.Executable(\"${MPIEXEC_EXECUTABLE_OVERRIDE}\")\n")
  elseif(MPIEXEC_EXECUTABLE)
    string(APPEND CONTENT "    mpi = canary.Executable(\"${MPIEXEC_EXECUTABLE}\")\n")
  else()
    string(APPEND CONTENT "    mpi = canary.Executable(\"mpiexec\")\n")
  endif()
  string(APPEND CONTENT "    args = []\n")
  if(MPIEXEC_NUMPROC_FLAG_OVERRIDE)
    string(APPEND CONTENT "    args.extend([\"${MPIEXEC_NUMPROC_FLAG_OVERRIDE}\", str(self.parameters.cpus)])\n")
  elseif(MPIEXEC_NUMPROC_FLAG)
    string(APPEND CONTENT "    args.extend([\"${MPIEXEC_NUMPROC_FLAG}\", str(self.parameters.cpus)])\n")
  else()
    string(APPEND CONTENT "    args.extend([\"-n\", str(self.parameters.cpus)])\n")
  endif()
  if(MPIEXEC_PREFLAGS_OVERRIDE)
    string(APPEND CONTENT "    preflags = \"${MPIEXEC_PREFLAGS_OVERRIDE}\" % {\"cpus\": self.parameters.cpus}\n")
    string(APPEND CONTENT "    args.extend(preflags.split())\n")
  elseif(MPIEXEC_PREFLAGS)
    string(APPEND CONTENT "    preflags = \"${MPIEXEC_PREFLAGS}\"\n")
    string(APPEND CONTENT "    args.extend(preflags.split())\n")
  endif()
  join_quoted("${PARSED_ARGS_COMMAND}" XTMP)
  string(APPEND CONTENT "    args.extend([${XTMP}])\n")
  string(APPEND CONTENT "    try:\n")
  string(APPEND CONTENT "       mpi(*args, fail_on_error=False)\n")
  string(APPEND CONTENT "    except Exception:\n")
  string(APPEND CONTENT "       raise canary.TestFailed(\"${NAME}\")\n")
  string(APPEND CONTENT "    else:\n")
  string(APPEND CONTENT "        if mpi.returncode != 0:\n")
  string(APPEND CONTENT "            raise canary.TestFailed(\"${NAME}\")\n")
  string(APPEND CONTENT "    return 0\n")
  string(APPEND CONTENT "if __name__ == \"__main__\":\n")
  string(APPEND CONTENT "    p = canary.make_argument_parser()\n")
  string(APPEND CONTENT "    args = p.parse_args()\n")
  string(APPEND CONTENT "    if not args.execute_analysis_sections:\n")
  string(APPEND CONTENT "        sys.exit(test())\n")
  file(GENERATE OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${NAME}.pyt" CONTENT "${CONTENT}")
endfunction()

# --- ADD_CANARY_OPTIONS ------------------------------------------------------------- #
function(add_canary_test_options)
  macro(_print_usage)
    message("\nADD_CANARY_OPTIONS(ON_OPTION <option>)\n Add option to canary options.\n")
  endmacro(_print_usage)
  cmake_parse_arguments(PARSED_ARGS "" "" "ON_OPTION" ${ARGN})
  if(NOT PARSED_ARGS_ON_OPTION)
    _print_usage()
    message(FATAL_ERROR "Must define <option>")
  endif()
  foreach(ON_OPTION ${PARSED_ARGS_ON_OPTION})
    list(APPEND CANARY_ON_OPTIONS "${ON_OPTION}")
    list(REMOVE_DUPLICATES CANARY_ON_OPTIONS)
  endforeach()
  set(CANARY_ON_OPTIONS "${CANARY_ON_OPTIONS}" CACHE STRING "" FORCE)
endfunction()

# --- ADD_CANARY_TARGET -------------------------------------------------------------- #
function(add_canary_test_target)
  add_custom_target(
    canary
    VERBATIM
    WORKING_DIRECTORY ${PROJECT_BINARY_DIR}
    COMMAND canary run -w .
  )
  set_target_properties(canary PROPERTIES EXCLUDE_FROM_ALL TRUE)
endfunction()

# --- WRITE_CANARY_CONFIG ------------------------------------------------------------ #
function(write_canary_config)
  string(TIMESTAMP NOW)
  set(CONTENT "build:\n")
  string(APPEND CONTENT "  project: \"${PROJECT_NAME}@${PROJECT_VERSION}\"\n")
  string(APPEND CONTENT "  type: \"${CMAKE_BUILD_TYPE}\"\n")
  string(APPEND CONTENT "  date: \"${NOW}\"\n")
  string(APPEND CONTENT "  source_directory: \"${CMAKE_SOURCE_DIR}\"\n")
  string(APPEND CONTENT "  build_directory: \"${CMAKE_BINARY_DIR}\"\n")
  string(APPEND CONTENT "  compiler:\n")
  string(APPEND CONTENT "    vendor: \"${CMAKE_C_COMPILER_ID}\"\n")
  string(APPEND CONTENT "    version: \"${CMAKE_C_COMPILER_VERSION}\"\n")
  if(DEFINED ENV{SPACK_CC})
  string(APPEND CONTENT "    cc: \"$ENV{SPACK_CC}\"\n")
  string(APPEND CONTENT "    cxx: \"$ENV{SPACK_CXX}\"\n")
  if(DEFINED ENV{SPACK_FC})
  string(APPEND CONTENT "    fc: \"$ENV{SPACK_FC}\"\n")
  endif()
  else()
  string(APPEND CONTENT "    cc: \"${CMAKE_C_COMPILER}\"\n")
  string(APPEND CONTENT "    cxx: \"${CMAKE_CXX_COMPILER}\"\n")
  if(CMAKE_Fortran_COMPILER)
  string(APPEND CONTENT "    fc: \"${CMAKE_Fortran_COMPILER}\"\n")
  endif()
  endif()
  if(CANARY_ON_OPTIONS)
  string(APPEND CONTENT "  options:\n")
  foreach(OPT ${CANARY_ON_OPTIONS})
  string(APPEND CONTENT "    ${OPT}: true\n")
  endforeach()
  endif()
  if(CANARY_OFF_OPTIONS)
  if(NOT CANARY_ON_OPTIONS)
  string(APPEND CONTENT "  options:\n")
  endif()
  foreach(OPT ${CANARY_OFF_OPTIONS})
  string(APPEND CONTENT "    ${OPT}: false\n")
  endforeach()
  endif()
  file(GENERATE OUTPUT "${CMAKE_BINARY_DIR}/canary.yaml" CONTENT "${CONTENT}")
endfunction()
