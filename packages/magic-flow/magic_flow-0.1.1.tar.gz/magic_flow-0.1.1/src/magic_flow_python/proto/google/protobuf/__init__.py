# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: google/protobuf/timestamp.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = ("Timestamp",)

import datetime
import typing
from dataclasses import dataclass

import betterproto2
import dateutil.parser

from ...message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False)
class Timestamp(betterproto2.Message):
    """
    A Timestamp represents a point in time independent of any time zone or local
    calendar, encoded as a count of seconds and fractions of seconds at
    nanosecond resolution. The count is relative to an epoch at UTC midnight on
    January 1, 1970, in the proleptic Gregorian calendar which extends the
    Gregorian calendar backwards to year one.

    All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
    second table is needed for interpretation, using a [24-hour linear
    smear](https://developers.google.com/time/smear).

    The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
    restricting to that range, we ensure that we can convert to and from [RFC
    3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.

    # Examples

    Example 1: Compute Timestamp from POSIX `time()`.

        Timestamp timestamp;
        timestamp.set_seconds(time(NULL));
        timestamp.set_nanos(0);

    Example 2: Compute Timestamp from POSIX `gettimeofday()`.

        struct timeval tv;
        gettimeofday(&tv, NULL);

        Timestamp timestamp;
        timestamp.set_seconds(tv.tv_sec);
        timestamp.set_nanos(tv.tv_usec * 1000);

    Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.

        FILETIME ft;
        GetSystemTimeAsFileTime(&ft);
        UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;

        // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
        // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
        Timestamp timestamp;
        timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
        timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));

    Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.

        long millis = System.currentTimeMillis();

        Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
            .setNanos((int) ((millis % 1000) * 1000000)).build();

    Example 5: Compute Timestamp from Java `Instant.now()`.

        Instant now = Instant.now();

        Timestamp timestamp =
            Timestamp.newBuilder().setSeconds(now.getEpochSecond())
                .setNanos(now.getNano()).build();

    Example 6: Compute Timestamp from current time in Python.

        timestamp = Timestamp()
        timestamp.GetCurrentTime()

    # JSON Mapping

    In JSON format, the Timestamp type is encoded as a string in the
    [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
    format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
    where {year} is always expressed using four digits while {month}, {day},
    {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
    seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
    are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
    is required. A proto3 JSON serializer should always use UTC (as indicated by
    "Z") when printing the Timestamp type and a proto3 JSON parser should be
    able to accept both UTC and other timezones (as indicated by an offset).

    For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
    01:30 UTC on January 15, 2017.

    In JavaScript, one can convert a Date object to this format using the
    standard
    [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
    method. In Python, a standard `datetime.datetime` object can be converted
    to this format using
    [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
    the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
    the Joda Time's [`ISODateTimeFormat.dateTime()`](
    http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
    ) to obtain a formatter capable of generating timestamps in this format.
    """

    seconds: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    Represents seconds of UTC time since Unix epoch
    1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
    9999-12-31T23:59:59Z inclusive.
    """

    nanos: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)
    """
    Non-negative fractions of a second at nanosecond resolution. Negative
    second values with fractions must still have non-negative nanos values
    that count forward in time. Must be from 0 to 999,999,999
    inclusive.
    """

    @classmethod
    def from_datetime(cls, dt: datetime.datetime) -> "Timestamp":
        if not dt.tzinfo:
            raise ValueError("datetime must be timezone aware")

        dt = dt.astimezone(datetime.timezone.utc)

        # manual epoch offset calulation to avoid rounding errors,
        # to support negative timestamps (before 1970) and skirt
        # around datetime bugs (apparently 0 isn't a year in [0, 9999]??)
        offset = dt - datetime.datetime(1970, 1, 1, tzinfo=datetime.timezone.utc)
        # below is the same as timedelta.total_seconds() but without dividing by 1e6
        # so we end up with microseconds as integers instead of seconds as float
        offset_us = (
            offset.days * 24 * 60 * 60 + offset.seconds
        ) * 10**6 + offset.microseconds
        seconds, us = divmod(offset_us, 10**6)
        return cls(seconds, us * 1000)

    def to_datetime(self) -> datetime.datetime:
        # datetime.fromtimestamp() expects a timestamp in seconds, not microseconds
        # if we pass it as a floating point number, we will run into rounding errors
        # see also #407
        offset = datetime.timedelta(
            seconds=self.seconds, microseconds=self.nanos // 1000
        )
        return datetime.datetime(1970, 1, 1, tzinfo=datetime.timezone.utc) + offset

    @staticmethod
    def timestamp_to_json(dt: datetime.datetime) -> str:
        nanos = dt.microsecond * 1e3
        if dt.tzinfo is not None:
            # change timezone aware datetime objects to utc
            dt = dt.astimezone(datetime.timezone.utc)
        copy = dt.replace(microsecond=0, tzinfo=None)
        result = copy.isoformat()
        if (nanos % 1e9) == 0:
            # If there are 0 fractional digits, the fractional
            # point '.' should be omitted when serializing.
            return f"{result}Z"
        if (nanos % 1e6) == 0:
            # Serialize 3 fractional digits.
            return f"{result}.{int(nanos // 1e6):03d}Z"
        if (nanos % 1e3) == 0:
            # Serialize 6 fractional digits.
            return f"{result}.{int(nanos // 1e3):06d}Z"
        # Serialize 9 fractional digits.
        return f"{result}.{nanos:09d}"

    @classmethod
    def from_dict(cls, value, *, ignore_unknown_fields: bool = False):
        if isinstance(value, str):
            dt = dateutil.parser.isoparse(value)
            dt = dt.astimezone(datetime.timezone.utc)
            return Timestamp.from_datetime(dt)

        return super().from_dict(value, ignore_unknown_fields=ignore_unknown_fields)

    def to_dict(
        self,
        *,
        output_format: betterproto2.OutputFormat = betterproto2.OutputFormat.PROTO_JSON,
        casing: betterproto2.Casing = betterproto2.Casing.CAMEL,
        include_default_values: bool = False,
    ) -> dict[str, typing.Any] | typing.Any:
        # If the output format is PYTHON, we should have kept the wraped type without building the real class
        assert output_format == betterproto2.OutputFormat.PROTO_JSON

        return Timestamp.timestamp_to_json(self.to_datetime())

    @staticmethod
    def from_wrapped(wrapped: datetime.datetime) -> "Timestamp":
        return Timestamp.from_datetime(wrapped)

    def to_wrapped(self) -> datetime.datetime:
        return self.to_datetime()


default_message_pool.register_message("google.protobuf", "Timestamp", Timestamp)
