# Set shebang if needed
# -*- coding: utf-8 -*-
"""
Created on Wed Jul 23 22:06:32 2025

@author: mano

This file contains the model for the inputs for URL generation and the methods
to transform the url into something valid for the INE API.
"""

import typing as ty
import pydantic as p
import re


class URLModel(p.BaseModel):
    """
    Takes a generated URL and transform it in to a URL valid for the INE API.

    For clarification, when we generate a url based on the inputs, we may find
    params of the shape
    ?date1=YYYYMMDD&date2=YYYYMMDD:
    or so, same with tv1, tv2, ...

    They are generated like this because we use a dictionary to store this
    values, however, the INE API doesn't understand this params. Only date
    and tv.

    This model removes the number from these params.
    """

    url: str

    @p.model_validator(mode='after')
    def __url_correction(self):
        """
        Corrects the URL generated by our functions.

        You are not allow to set multiple equal keys in a dictionary
        but the INE API url allows you to set multiple dates.

        To solve this, you can set mutiple dates using the format
        date1,date2,date3,... to the dictionary,

        This will set the url as ?date1=***&date2=***...

        This function removes the number in those dates.
        """

        fixed_url = re.compile(r'(\bdate\d*)').sub('date', self.url)
        fixed_url = re.compile(r'(\btv\d*)').sub('tv', fixed_url)
        self.url = fixed_url
        return self


class InputModel(p.BaseModel):
    """Class model for Inputs for URL building."""

    function: ty.Literal[  # Must be one of INE API Functions
        # Operaciones
        'OPERACIONES_DISPONIBLES',
        'OPERACION',
        # Variables
        'VARIABLES',
        'VARIABLES_OPERACION',
        # Valores
        'VALORES_VARIABLE',
        'VALORES_VARIABLEOPERACION',
        'VALORES_HIJOS',
        # Tablas
        'TABLAS_OPERACION',
        'GRUPOS_TABLA',
        'VALORES_GRUPOSTABLA',
        # Series
        'SERIE',
        'SERIES_OPERACION',
        'VALORES_SERIE',
        'SERIES_TABLA',
        'SERIE_METADATAOPERACION',
        # Publicaciones
        'PUBLICACIONES',
        'PUBLICACIONES_OPERACION',
        'PUBLICACIONFECHA_PUBLICACION',
        # Datos (peticion de datos)
        'DATOS_SERIE',
        'DATOS_TABLA',
        'DATOS_METADATAOPERACION',
        # ---------------------
        # Los siguientes no están en la documentación del INE
        # ---------------------
        # Unidades
        'UNIDAD',
        'UNIDADES',
        # Escalas
        'ESCALA',
        'ESCALAS',
        # Periodos
        'PERIODO',
        # Periodicidades
        'PERIODICIDAD',
        'PERIODICIDADES',
        # Operaciones -- añade algunas operaciones
        'OPERACIONES',
        # Clasificaciones
        'CLASIFICACIONES',
        # Variables
        'VARIABLE'
    ]

    language: ty.Literal['ES', 'EN'] = 'ES'
    path: str | int | ty.List[str | int | None] | ty.Tuple[str | int | None] = ''
    query: ty.Dict[str, str | int] = dict()

    @p.model_validator(mode='after')
    def __path_correction(self):
        """
        Transform the list of path into a valid path.

        For example:
            If path is a list of str or None.
                ['A', 'B', None, 'C']
            It is transformed into:
                base_path_for_INE + 'A/B/C'

        """
        if isinstance(self.path, str):
            pass
        elif isinstance(self.path, int):
            self.path = str(self.path)
        else:
            path_str = f'wstempus/js/{self.language}/{self.function}/'
            for v in self.path:
                if v is None:
                    continue
                else:
                    path_str = path_str + str(v) + '/'
            path_str = path_str[:-1]
            # We remove the last /
            self.path = path_str
        return self

    @p.model_validator(mode='after')
    def __query_checks(self):
        """Checks that query keys are valid for the INE API."""
        date_param_regex = re.compile(r'\bdate\d+')
        FK_param_regex = re.compile(r'\bg\d+')
        FK_metadata_filter_regex = re.compile(r'\btv\d+')
        static_keys = ['det', 'tip', 'geo', 'page', 'nult', 'p', 'clasif']

        for k, v in self.query.items():
            check1 = date_param_regex.match(k)
            check2 = FK_param_regex.match(k)
            check3 = FK_metadata_filter_regex.match(k)
            check4 = k in static_keys
            if check1 or check2 or check3 or check4:
                continue
            else:
                raise ValueError(f'Your key {k} is not valid.')

        return self
