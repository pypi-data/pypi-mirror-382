specificationVersion: jobtemplate-2023-09
name: VRED Renderer
description: |
  This render job template depends on Autodesk VRED Core (or optionally VRED Pro) to perform rendering and supports
  versions 2025.X (17.X) and 2026.X (18.X) on Windows and Linux platforms. Please review official system requirements
  and software dependencies on Autodesk's official website.

  Render jobs take a VPB project file (including its file references) as input, and produce render output per
  the chosen output format and additional render settings.

  To run the render job without a conda virtual environment created by a Deadline Cloud queue environment,
  you must ensure that the environment variable "VREDCORE" (for VRED Core) or "VREDPRO" (for VRED Pro) is defined by a
  valid path to its product's executable file. You can find these executable files in paths similar to:
    (Linux): /opt/Autodesk/VREDCluster-{version}/bin/VREDCore
    (Windows): C:/Program Files/Autodesk/VREDPro-{version}/bin/WIN64/VREDCore.exe"
  Note: if both of these environment variables are assigned, then "VREDCORE" will take precedence.

  If you're using a conda queue environment, then please ensure that the channels listed in your CondaChannels list
  include all of the packages for these software dependencies. On Deadline Cloud service-managed fleets, there are
  two channels (deadline-cloud, conda-forge) that provide those packages.

  This job bundle also depends on the latest code that is located here (which also includes the latest job bundle):
      https://github.com/aws-deadline/deadline-cloud-for-vred

  You can also create a custom conda channel on S3 using the approach documented below:
      https://docs.aws.amazon.com/deadline-cloud/latest/developerguide/configure-jobs-s3-channel.html
  (At that point, you can build conda package recipes and deadline.)

  Source code link:
    git_url: https://github.com/aws-deadline/deadline-cloud-for-vred.git
    git_rev: mainline

parameterDefinitions:
  - name: SceneFile
    type: PATH
    objectType: FILE
    dataFlow: IN
    userInterface:
      control: CHOOSE_INPUT_FILE
      label: VRED Scene File
      fileFilters:
        - label: VRED Scene Files
          patterns:
            - '*.vpb'
        - label: All Files
          patterns:
            - '*'
    description: >
      Choose the VRED scene file that you want to render.
      Use the 'Job Attachments' tab of the submitter GUI to add
      other dependent files that the job needs.
  - name: OutputDir
    type: PATH
    objectType: DIRECTORY
    dataFlow: OUT
    userInterface:
      control: CHOOSE_DIRECTORY
      label: Output Directory
      groupLabel: Render Options
    description: The render output directory.
  - name: OutputFileNamePrefix
    type: STRING
    userInterface:
      control: LINE_EDIT
      label: Output Filename Prefix
      groupLabel: Render Options
    default: output
    description: The render output filename prefix (without extension).
  - name: OutputFormat
    type: STRING
    userInterface:
      control: DROPDOWN_LIST
      label: Output File Format
      groupLabel: Render Options
    description: The file format for rendered images.
    default: PNG
    allowedValues:
      - BMP
      - DDS
      - DIB
      - EXR
      - HDR
      - JFIF
      - JPE
      - JPEG
      - JPG
      - NRRD
      - PBM
      - PGM
      - PNG
      - PNM
      - PPM
      - PSB
      - PSD
      - RLE
      - TIF
      - TIFF
      - VIF
      - ZIP
  - name: View
    type: STRING
    userInterface:
      control: LINE_EDIT
      label: Render Viewpoint/Camera
      groupLabel: Render Options
    default: ""
    description: The name of the viewpoint or camera from which to render.
  - name: ImageWidth
    type: INT
    userInterface:
      control: SPIN_BOX
      label: Image Width (px)
      groupLabel: Render Options
    minValue: 1
    default: 800
    description: The rendered image width in pixels.
  - name: ImageHeight
    type: INT
    userInterface:
      control: SPIN_BOX
      label: Image Height (px)
      groupLabel: Render Options
    minValue: 1
    default: 600
    description: The rendered image height in pixels.
  - name: DPI
    type: INT
    userInterface:
      control: SPIN_BOX
      label: Resolution (px/inch)
      groupLabel: Render Options
    minValue: 1
    default: 72
    description: The dots-per-inch (DPI) physical scaling factor (pixels per inch).
  - name: RenderQuality
    type: STRING
    userInterface:
      control: DROPDOWN_LIST
      label: Render Quality
      groupLabel: Render Options
    default: 'Realistic High'
    allowedValues:
      - 'Analytic Low'
      - 'Analytic High'
      - 'Realistic Low'
      - 'Realistic High'
      - 'Raytracing'
      - 'NPR'
    description: The render quality level to apply.
  - name: DLSSQuality
    type: STRING
    userInterface:
      control: DROPDOWN_LIST
      label: DLSS Quality
      groupLabel: Render Options
    default: 'Off'
    allowedValues:
      - 'Off'
      - 'Performance'
      - 'Balanced'
      - 'Quality'
      - 'Ultra Performance'
    description: The Deep Learning Super Sampling (DLSS) quality level to apply.
  - name: SSQuality
    type: STRING
    userInterface:
      control: DROPDOWN_LIST
      label: SS Quality
      groupLabel: Render Options
    default: 'Off'
    allowedValues:
      - 'Off'
      - 'Low'
      - 'Medium'
      - 'High'
      - 'Ultra High'
    description: >
      The Super Sampling quality level to apply; note: DLSS quality level takes precedence.
  - name: RenderAnimation
    type: STRING
    userInterface:
      control: CHECK_BOX
      label: Render Animation
      groupLabel: Render Options
    default: 'true'
    allowedValues:
      - 'true'
      - 'false'
    description: >
      If checked, allows specifying an animation type (which can also include a specific animation clip),
      corresponding frame range and frames per task.
  - name: GPURaytracing
    type: STRING
    userInterface:
      control: CHECK_BOX
      label: Use GPU Ray Tracing
      groupLabel: Render Options
    default: 'false'
    allowedValues:
      - 'true'
      - 'false'
    description: Attempts to apply GPU raytracing to the rendering process (if sufficient hardware is available).
  - name: AnimationType
    type: STRING
    userInterface:
      control: DROPDOWN_LIST
      label: Animation Type
      groupLabel: Render Options
    default: 'Clip'
    allowedValues:
      - 'Clip'
      - 'Timeline'
    description: The type of animation (Clip or Timeline).
  - name: AnimationClip
    type: STRING
    userInterface:
      control: LINE_EDIT
      label: Animation Clip
      groupLabel: Render Options
    default: ""
    description: The name of the animation clip to render.
  - name: StartFrame
    type: INT
    userInterface:
      control: SPIN_BOX
      label: Start Frame
      groupLabel: Render Options
    default: 0
    description: The first frame of a range to render.
  - name: EndFrame
    type: INT
    userInterface:
      control: SPIN_BOX
      label: End Frame
      groupLabel: Render Options
    default: 20
    description: The last frame of a range to render.
  - name: FrameStep
    type: INT
    userInterface:
      control: SPIN_BOX
      label: Frame Step
      groupLabel: Render Options
    default: 1
    description: The frame step for the frame range (i.e. 2 for rendering every second frame).
  - name: FramesPerTask
    type: INT
    userInterface:
      control: SPIN_BOX
      label: Frames Per Task
      groupLabel: Render Options
    minValue: 1
    default: 1
    description: The number of frames that will be rendered at a time for each task within a render job.
  - name: IncludeAlphaChannel
    type: STRING
    userInterface:
      control: HIDDEN
      label: Include Alpha Channel
      groupLabel: Render Options
    default: 'false'
    allowedValues:
      - 'true'
      - 'false'
    description: Enables export of images with an alpha channel.
  - name: RegionRendering
    type: STRING
    userInterface:
      control: CHECK_BOX
      label: Enable Region Rendering
      groupLabel: Tiling Settings
    default: 'false'
    allowedValues:
      - 'true'
      - 'false'
    description: >
      When enabled, the output rendered image will be divided into multiple tiles (sub-regions)
      that are first rendered as separate tasks for a given frame. These tiles will then be
      assembled (combined) into one output image for a given frame (in a separate task).
  - name: NumXTiles
    type: INT
    userInterface:
      control: SPIN_BOX
      label: Tiles in X
      groupLabel: Tiling Settings
    minValue: 1
    default: 1
    description: The number of tiles to horizontally divide the specified image size.
  - name: NumYTiles
    type: INT
    userInterface:
      control: SPIN_BOX
      label: Tiles in Y
      groupLabel: Tiling Settings
    minValue: 1
    default: 1
    description: The number of tiles to vertically divide the specified image size.
  - name: OverrideRenderPass
    type: STRING
    userInterface:
      control: HIDDEN
      label: Override Render Pass
      groupLabel: Render Options
    default: 'false'
    allowedValues:
      - 'true'
      - 'false'
    description: >
      Enables the exporting of render passes when rendering to a file. If enabled, then the render pass
      settings via the job properties will be used; otherwise the settings defined in the scene will be used.
  - name: PremultiplyAlpha
    type: STRING
    userInterface:
      control: HIDDEN
      label: Premultiply Alpha
      groupLabel: Render Options
    default: 'false'
    allowedValues:
      - 'true'
      - 'false'
    description: Enables premultiplied alpha.
  - name: TonemapHDR
    type: STRING
    userInterface:
      control: HIDDEN
      label: Tone map HDR
      groupLabel: Render Options
    default: 'false'
    allowedValues:
      - 'true'
      - 'false'
    description: Enables tone mapping when rendering to a HDR image format.
  - name: JobType
    type: STRING
    userInterface:
      control: HIDDEN
      label: Job Type
      groupLabel: Render Options
    default: 'Render'
    allowedValues:
      - 'Render'
      - 'Sequencer'
    description: Type of job to submit.
  - name: SequenceName
    type: STRING
    userInterface:
      control: HIDDEN
      label: Sequence Name
      groupLabel: Render Options
    default: ""
    description: The name of the sequence to render; if empty, then all sequences will be rendered.
  - name: JobScriptDir
    userInterface:
      control: HIDDEN
    type: PATH
    objectType: DIRECTORY
    dataFlow: IN
    default: scripts
    description: Directory containing bundled scripts.
  - name: CondaPackages
    userInterface:
      control: HIDDEN
    type: STRING
    default: 'vredcore=2026*'
    description: >
      A list of conda packages to install. If a queue accepts this parameter, then it will create a conda virtual
      environment.
  - name: submitter_name
    type: STRING
    userInterface:
      control: HIDDEN
    default: 'VRED'
    description: >
      The type of submitter that is used to submit the render job.
  - name: name
    type: STRING
    userInterface:
      control: HIDDEN
    default: ''
    description: >
      The name of the render job.
  - name: description
    type: STRING
    userInterface:
      control: HIDDEN
    default: ''
    description: >
      The description of the render job.
  - name: input_filenames
    type: STRING
    userInterface:
      control: HIDDEN
    default: ''
    description: >
      Input filenames.
  - name: input_directories
    type: STRING
    userInterface:
      control: HIDDEN
    default: ''
    description: >
      Input directories.
  - name: output_directories
    type: STRING
    userInterface:
      control: HIDDEN
    default: ''
    description: >
      Output directories.

steps:
  - name: VRED Render
    parameterSpace:
      taskParameterDefinitions:
        - name: StartFrameFromCurrentChunk
          type: INT
          range: "{{Param.StartFrame}}-{{Param.EndFrame}}:{{Param.FramesPerTask}}"
        - name: TileNumberX
          type: INT
          range: "1-{{Param.NumXTiles}}"
        - name: TileNumberY
          type: INT
          range: "1-{{Param.NumYTiles}}"
    description: Invokes VRED Core, supplying it with render parameter data.
    script:
      embeddedFiles:
        - name: LoadRenderParameterValues
          filename: load_render_parameter_values.py
          type: TEXT
          data: |-
            from typing import Any, Dict

            def str_to_bool(s:str) -> bool: return s.lower() == 'true'

            def get_vred_render_parameters() -> Dict[str, Any]:
                """
                *WARNING*: it is imperative to maintain correct value typing for all parameters that you add using
                the conversion schemes below (for int, str, bool) as a guide. Value types are VRED API
                sensitive -- they need to be synchronized with future VRED API changes (if any). Please
                also keep value typing pairwise with parameterDefinitions-supported types (above).

                :return: a dictionary containing appropriately-typed values (non-inferred) for use in VRED API calls.
                """

                # Depending on implementation, a frame chunk ID or an actual starting frame number that
                # corresponds to that ID could be provided.
                #
                start_frame = int({{Task.Param.StartFrameFromCurrentChunk}})
                frames_per_task = int({{Param.FramesPerTask}})
                end_frame = min(start_frame + frames_per_task - 1, int({{Param.EndFrame}}))
                return {
                    'AnimationClip': str('{{Param.AnimationClip}}'),
                    'AnimationType': str('{{Param.AnimationType}}'),
                    'DLSSQuality': str('{{Param.DLSSQuality}}'),
                    'DPI': int({{Param.DPI}}),
                    'EndFrame': int(end_frame),
                    'FrameStep': int({{Param.FrameStep}}),
                    'FramesPerTask': int(frames_per_task),
                    'GPURaytracing': int(str_to_bool('{{Param.GPURaytracing}}')),
                    'ImageHeight': int({{Param.ImageHeight}}),
                    'ImageWidth': int({{Param.ImageWidth}}),
                    'IncludeAlphaChannel': str_to_bool('{{Param.IncludeAlphaChannel}}'),
                    'JobType': str('{{Param.JobType}}'),
                    'NumXTiles': int({{Param.NumXTiles}}),
                    'NumYTiles': int({{Param.NumYTiles}}),
                    'OutputDir': str(r'{{Param.OutputDir}}'),
                    'OutputFileNamePrefix': str('{{Param.OutputFileNamePrefix}}'),
                    'OutputFormat': str('{{Param.OutputFormat}}'),
                    'OverrideRenderPass': str_to_bool('{{Param.OverrideRenderPass}}'),
                    'PathMappingRulesFile': str(r'{{Session.PathMappingRulesFile}}'),
                    'PremultiplyAlpha': str_to_bool('{{Param.PremultiplyAlpha}}'),
                    'RegionRendering': str_to_bool('{{Param.RegionRendering}}'),
                    'RenderAnimation': str_to_bool('{{Param.RenderAnimation}}'),
                    'RenderQuality': str('{{Param.RenderQuality}}'),
                    'SceneFile': str(r'{{Param.SceneFile}}'),
                    'SequenceName': str('{{Param.SequenceName}}'),
                    'SSQuality': str('{{Param.SSQuality}}'),
                    'StartFrame': int(start_frame),
                    'TileNumberX': int({{Task.Param.TileNumberX}}),
                    'TileNumberY': int({{Task.Param.TileNumberY}}),
                    'TonemapHDR': str_to_bool('{{Param.TonemapHDR}}'),
                    'View': str('{{Param.View}}'),
                }
        - name: VREDInvocation
          filename: invoke-vred.py
          type: TEXT
          runnable: True
          data: |-
            # Please set one of the following environment variables: "VREDCORE" or "VREDPRO".
            # Please ensure that it resolves to a VRED binary executable that is reachable.
            # You can find relevant executables in paths similar to:
            #   (Linux): /opt/Autodesk/VREDCluster-{version}/bin/VREDCore
            #   (Windows): C:/Program Files/Autodesk/VREDPro-{version}/bin/WIN64/VREDCore.exe"
            # Note: if both of these environment variables are assigned, then "VREDCORE" will be take precedence.
            #
            import io
            import os
            import platform
            import subprocess
            import sys
            import time
            import re
            import threading
            import queue

            sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

            CODE_PASSING_ENV_VAR = "BOOTSTRAP_CODE"
            DISABLE_PYTHON_SANDBOX_PARAM = "-insecure_python"
            DISABLE_WEBINTERFACE_ENV_VAR = "VRED_DISABLE_WEBINTERFACE"
            DISABLE_WEBINTERFACE_VALUE = "1"
            ERROR_UNKNOWN_VRED_PATH = (
                "Cannot determine valid VRED binary to invoke from VREDCORE and VREDPRO environment "
                "variables."
            )
            FAST_START_PARAM = "-fast_start"
            FLEXLM_DIAGNOSTICS_ENV_VAR = "FLEXLM_DIAGNOSTICS"
            FLEXLM_DIAGNOSTICS_HIGH_VALUE = "3"
            HIDE_GUI_PARAM = "-hide_gui"
            IS_WINDOWS = platform.system().lower() == "windows"
            LICENSE_RELEASE_TIME_ENV_VAR = "VRED_IDLE_LICENSE_TIME"
            LICENSE_RELEASE_TIME_SECONDS_LIMIT = "60"
            POST_PYTHON_PARAM = "-postpython"
            VRED_CORE_ENV_VAR = "VREDCORE"
            VRED_PRO_ENV_VAR = "VREDPRO"

            # Invoke code found in VRED_PYTHON_BOOTSTRAP_CODE via CODE_PASSING_ENV_VAR without using import statements.
            # Remove all spaces to prevent VRED from assuming non-intended arguments.
            #
            VRED_PYTHON_PRE_BOOTSTRAP_CODE = fr"""
            load_module = getattr(__builtins__, '__import__');
            os = load_module('os');
            exec(os.environ.get('{CODE_PASSING_ENV_VAR}'));
            """.replace(
                "\n", ""
            ).replace(
                " ", ""
            )
            # Inject render parameters into render script, loading both of them at startup, enforce universal exit
            #
            VRED_PYTHON_BOOTSTRAP_CODE = r"""
            import importlib;
            import os;
            import sys;
            from vrController import terminateVred, vrLogError;

            sys.path.extend([r'{{Param.JobScriptDir}}', os.path.dirname(r'{{Task.File.LoadRenderParameterValues}}')]);
            render_module_name='VRED_RenderScript_DeadlineCloud';
            render_param_module_name='load_render_parameter_values';
            render_module = importlib.util.find_spec(render_module_name) is not None and importlib.import_module(
            render_module_name) or None;
            render_param_module = importlib.util.find_spec(render_param_module_name) is not None and importlib.import_module(
            render_param_module_name) or None;
            render_module.deadline_cloud_render(
            render_param_module.get_vred_render_parameters()) if render_module and render_param_module else vrLogError(
            'failed to import module for render script and/or render parameters');

            terminateVred();
            """.replace(
                "\n", ""
            ).replace(
                "\\", "/"
            )


            def get_vred_executable() -> str:
                """
                Determine VRED binary to use based on environment variable state and binary availability
                return: path to VRED binary
                raise: OSError: if a valid binary can't be determined.
                """
                try:
                    vred_executable = os.environ[VRED_CORE_ENV_VAR]
                    if not os.path.isfile(vred_executable):
                        raise FileNotFoundError(f"VREDCORE binary not found at: {vred_executable}")
                except (KeyError, FileNotFoundError):
                    try:
                        vred_executable = os.environ[VRED_PRO_ENV_VAR]
                        if not os.path.isfile(vred_executable):
                            raise FileNotFoundError(f"VREDPRO binary not found at: {vred_executable}")
                    except (KeyError, FileNotFoundError):
                        raise OSError(ERROR_UNKNOWN_VRED_PATH)
                return vred_executable


            def setup_vred_environment() -> None:
                """
                Disable VRED's web interface, release license on idle, pass bootstrapping code via environment variable
                """
                os.environ[DISABLE_WEBINTERFACE_ENV_VAR] = DISABLE_WEBINTERFACE_VALUE
                os.environ[LICENSE_RELEASE_TIME_ENV_VAR] = LICENSE_RELEASE_TIME_SECONDS_LIMIT
                os.environ[CODE_PASSING_ENV_VAR] = VRED_PYTHON_BOOTSTRAP_CODE
                os.environ[FLEXLM_DIAGNOSTICS_ENV_VAR] = FLEXLM_DIAGNOSTICS_HIGH_VALUE


            def reader_thread(pipe, output_queue, error_queue):
                """
                Thread to read output from pipe and put it into queue with proper error handling
                """
                try:
                    while True:
                        line = pipe.readline()
                        if not line:
                            break

                        try:
                            output_queue.put(line, timeout=5.0)
                        except queue.Full:
                            # Report output queue overflow
                            try:
                                error_queue.put_nowait("OUTPUT_QUEUE_FULL")
                            except queue.Full:
                                # Error queue is also full - use fallback error reporting
                                print("CRITICAL: Both output and error queues are full")
                            break

                except Exception as e:
                    # Report thread exception
                    error_msg = f"THREAD_ERROR: {str(e)}"
                    try:
                        error_queue.put_nowait(error_msg)
                    except queue.Full:
                        # Error queue is full - use fallback error reporting
                        print(f"CRITICAL: Cannot report thread error due to queue overflow! Thread error unreportable: {error_msg}")
                finally:
                    pipe.close()


            def invoke_vred(vred_executable: str) -> None:
                """
                Invoke VRED binary, passing it parameters to run headless, grant script access, load scene file,
                and execute code for the render process to complete
                param: vred_executable: path to VRED binary
                """
                executable = f'"{vred_executable}"' if IS_WINDOWS else vred_executable
                scene_file_path = r'"{{Param.SceneFile}}"' if IS_WINDOWS else r"{{Param.SceneFile}}"
                command_and_arg_list: list[str] = [
                    executable,
                    scene_file_path,
                    DISABLE_PYTHON_SANDBOX_PARAM,
                    FAST_START_PARAM,
                    HIDE_GUI_PARAM,
                    POST_PYTHON_PARAM,
                    VRED_PYTHON_PRE_BOOTSTRAP_CODE,
                ]
                invocation = " ".join(command_and_arg_list) if IS_WINDOWS else command_and_arg_list
                process = None
                output_queue = None
                error_queue = None
                output_reader_thread = None

                try:
                    process = subprocess.Popen(
                        invocation,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        text=True,
                        bufsize=1,
                    )

                    # Create queues for inter-thread communication
                    output_queue = queue.Queue(maxsize=1000)
                    error_queue = queue.Queue(maxsize=100)

                    # Start thread to read output
                    output_reader_thread = threading.Thread(
                      target=reader_thread,
                      args=(process.stdout, output_queue, error_queue)
                    )
                    output_reader_thread.daemon = True  # Terminate thread when the main process ends
                    output_reader_thread.start()

                    license_error_detected = False

                    # Read queue output in real-time from main thread
                    while output_reader_thread.is_alive() or not output_queue.empty():
                        # Error check
                        try:
                            error_msg = error_queue.get_nowait()
                            if error_msg.startswith("THREAD_ERROR:"):
                                process.terminate()
                                raise Exception(error_msg)
                            elif error_msg == "OUTPUT_QUEUE_FULL":
                                print("Warning: Output queue overflow, some output may be lost")
                        except queue.Empty:
                            pass

                        # Print console output
                        try:
                            # Get output from queue in non-blocking manner
                            # Set timeout to avoid infinite waiting
                            line = output_queue.get_nowait()
                            print(line.strip())

                            # Error message detection logic
                            if re.search(r"No valid license found", line):
                                license_error_detected = True
                                break

                        except queue.Empty:
                            # When queue is empty
                            if process.poll() is not None:
                                # Exit loop if process terminated and queue is empty
                                print("Process has terminated.")
                                break
                            # Otherwise, wait 1 second to prevent unnecessary CPU usage
                            time.sleep(1)

                    # When license error has been detected, raise exception
                    if license_error_detected:
                        process.terminate()
                        raise Exception("License error detected")

                    process.wait()

                except subprocess.CalledProcessError as error:
                    print(f"Command: [{invocation}] failed: \n{error.output}\n with return code {error.returncode}")
                    # Exit with non-zero status to indicate failure
                    sys.exit(1)
                except Exception as error:
                    print(f"Command: [{invocation}] failed: \n{error}")
                    sys.exit(1)
                finally:
                    # Clean up resources
                    if output_reader_thread and output_reader_thread.is_alive():
                        output_reader_thread.join(timeout=1)
                    # Empty the queue
                    if output_queue:
                        while not output_queue.empty():
                            try:
                                output_queue.get_nowait()
                            except queue.Empty:
                                break

            setup_vred_environment()
            invoke_vred(get_vred_executable())
      actions:
        onRun:
          command: python
          args: [ '{{Task.File.VREDInvocation}}' ]
    hostRequirements:
      amounts:
        - name: amount.worker.gpu
          min: 1
      attributes:
        - name: attr.worker.os.family
          anyOf:
            - linux
            - windows

  - name: Tile Assembly
    description: Combines tiles into individual frames. (step can be excluded as needed.)
    dependencies:
    - dependsOn: VRED Render
    script:
      actions:
        onRun:
          command: python
          args: [ "{{Task.File.Assembler}}"]
      embeddedFiles:
      - name: Assembler
        type: TEXT
        runnable: True
        data: |-
          import concurrent.futures
          import os
          import platform
          import subprocess

          IS_WINDOWS = platform.system().lower() == "windows"

          # Path to the ImageMagick binary, either by using the "MAGICK" env variable if it's set, 
          # or by defaulting to the "magick" command
          MAGICK_BIN = os.path.normpath(os.environ.get("MAGICK") or "magick").replace("\\", "/")

          EVALUATE_SEQUENCE_PARAM = "-evaluate-sequence"
          EVALUATE_SEQUENCE_PARAM_VALUE = "max"
          MIN_WORKERS_IF_UNKNOWN = 4
          NUM_X_TILES = int("{{Param.NumXTiles}}")
          NUM_Y_TILES = int("{{Param.NumYTiles}}")
          OUTPUT_DIR = os.path.normpath(r"{{Param.OutputDir}}").replace("\\", "/")
          OUTPUT_FILE_PREFIX = "{{Param.OutputFileNamePrefix}}"
          OUTPUT_FORMAT = "{{Param.OutputFormat}}".lower()
          START_FRAME = int("{{Param.StartFrame}}")
          END_FRAME = int("{{Param.EndFrame}}")
          IS_RENDER_ANIMATION = "{{Param.RenderAnimation}}".lower() == "true"

          def assemble_frame(frame_num: int) -> None:
              """
              Assembles a given frame from the tiles that comprise it.
              When "Render Animation" is enabled, VRED appends frame numbers to output filenames,
              so we need to account for this in both input and output filename formats.

              Filename formats:
              - Single frame: prefix_YxX_AxB.suffix -> prefix.suffix
              - Animation (multiple frames): prefix_YxX_AxB-NNNNN.suffix -> prefix-NNNNN.suffix
              """

              # Note: tile value is [columns count]x[rows count]
              tile_value = f"{NUM_X_TILES}x{NUM_Y_TILES}"
              frame_suffix = f"-{frame_num:05d}" if IS_RENDER_ANIMATION else ""
              input_file_mask = f"{OUTPUT_DIR}/*_{tile_value}{frame_suffix}.{OUTPUT_FORMAT}"
              output_file = f"{OUTPUT_DIR}/{OUTPUT_FILE_PREFIX}{frame_suffix}.{OUTPUT_FORMAT}"              

              command_and_arg_list: list[str] = [
                  MAGICK_BIN,
                  input_file_mask,
                  EVALUATE_SEQUENCE_PARAM,
                  EVALUATE_SEQUENCE_PARAM_VALUE,
                  output_file,
              ]

              try:
                  invocation = " ".join(command_and_arg_list) if IS_WINDOWS else command_and_arg_list
                  result = subprocess.run(invocation, capture_output=True, check=True, text=True)
                  print(f"command invocation result: {result}")
              except subprocess.CalledProcessError as error:
                  print(f"Command: {invocation} failed with return code {error.returncode}")
                  print(f"--------------- STDOUT ---------------\n{error.stdout}")
                  print(f"--------------- STDERR ---------------\n{error.stderr}")

          # Parallel processing of frames
          max_workers = os.cpu_count() or MIN_WORKERS_IF_UNKNOWN
          with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
              for frame in range(START_FRAME, END_FRAME + 1):
                  future = executor.submit(assemble_frame, frame)
