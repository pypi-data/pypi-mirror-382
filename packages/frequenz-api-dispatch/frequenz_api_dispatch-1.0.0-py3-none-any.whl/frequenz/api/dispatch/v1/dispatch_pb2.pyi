"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Frequenz Dispatch Automation API

Copyright:
Copyright 2022 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import builtins
import collections.abc
import frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2
import frequenz.api.common.v1alpha8.pagination.pagination_info_pb2
import frequenz.api.common.v1alpha8.pagination.pagination_params_pb2
import frequenz.api.common.v1alpha8.streaming.event_pb2
import frequenz.api.common.v1alpha8.types.interval_pb2
import google.protobuf.descriptor
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _SortField:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SortFieldEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SortField.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SORT_FIELD_UNSPECIFIED: _SortField.ValueType  # 0
    """UNSPECIFIED: Default, unspecified sort field."""
    SORT_FIELD_START_TIME: _SortField.ValueType  # 1
    """START_TIME: Sort by start time of the dispatch."""
    SORT_FIELD_CREATE_TIME: _SortField.ValueType  # 2
    """CREATE_TIME: Sort by creation time of the dispatch."""
    SORT_FIELD_LAST_UPDATE_TIME: _SortField.ValueType  # 3
    """UPDATE_TIME: Sort by last update time of the dispatch."""

class SortField(_SortField, metaclass=_SortFieldEnumTypeWrapper):
    """Enum for the fields to by sorted by."""

SORT_FIELD_UNSPECIFIED: SortField.ValueType  # 0
"""UNSPECIFIED: Default, unspecified sort field."""
SORT_FIELD_START_TIME: SortField.ValueType  # 1
"""START_TIME: Sort by start time of the dispatch."""
SORT_FIELD_CREATE_TIME: SortField.ValueType  # 2
"""CREATE_TIME: Sort by creation time of the dispatch."""
SORT_FIELD_LAST_UPDATE_TIME: SortField.ValueType  # 3
"""UPDATE_TIME: Sort by last update time of the dispatch."""
global___SortField = SortField

class _SortOrder:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SortOrderEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SortOrder.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SORT_ORDER_UNSPECIFIED: _SortOrder.ValueType  # 0
    """UNSPECIFIED: Default, unspecified sort order."""
    SORT_ORDER_ASCENDING: _SortOrder.ValueType  # 1
    """ASCENDING: Results are returned in ascending order."""
    SORT_ORDER_DESCENDING: _SortOrder.ValueType  # 2
    """DESCENDING: Results are returned in descending order."""

class SortOrder(_SortOrder, metaclass=_SortOrderEnumTypeWrapper):
    """Enum for sort order."""

SORT_ORDER_UNSPECIFIED: SortOrder.ValueType  # 0
"""UNSPECIFIED: Default, unspecified sort order."""
SORT_ORDER_ASCENDING: SortOrder.ValueType  # 1
"""ASCENDING: Results are returned in ascending order."""
SORT_ORDER_DESCENDING: SortOrder.ValueType  # 2
"""DESCENDING: Results are returned in descending order."""
global___SortOrder = SortOrder

@typing.final
class StreamMicrogridDispatchesRequest(google.protobuf.message.Message):
    """Subscribe to a stream of microgrid dispatch requests.
    This method provides real-time updates on newly or updated dispatch requests for edge-based
    realtime decision making.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """ID of the microgrid to subscribe to"""
    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["microgrid_id", b"microgrid_id"]) -> None: ...

global___StreamMicrogridDispatchesRequest = StreamMicrogridDispatchesRequest

@typing.final
class StreamMicrogridDispatchesResponse(google.protobuf.message.Message):
    """Response to a subscription request for a stream of microgrid dispatches.
    Real-time information on dispatches affecting a certain microgrid are pushed through this response.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DISPATCH_FIELD_NUMBER: builtins.int
    EVENT_FIELD_NUMBER: builtins.int
    event: frequenz.api.common.v1alpha8.streaming.event_pb2.Event.ValueType
    """Which event this response was triggered by"""
    @property
    def dispatch(self) -> global___Dispatch:
        """Dispatch record returned."""

    def __init__(
        self,
        *,
        dispatch: global___Dispatch | None = ...,
        event: frequenz.api.common.v1alpha8.streaming.event_pb2.Event.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["dispatch", b"dispatch"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["dispatch", b"dispatch", "event", b"event"]) -> None: ...

global___StreamMicrogridDispatchesResponse = StreamMicrogridDispatchesResponse

@typing.final
class DispatchData(google.protobuf.message.Message):
    """Represents a dispatches data, including its type, start time, duration,
    and target microgrid components.

    This `DispatchData` message describes a single dispatch instance. If a dispatch is set to recur,
    each occurrence is defined by `DispatchData` in combination with `RecurrenceRule`.

    !!! note "Indefinite Durations"
        This API allows dispatches to have an indefinite duration if the `duration` field
        is not set. Indefinite means:
        - There is no predefined end time known at dispatch creation.
        - The dispatch could, in theory, run indefinitely if no external conditions stop it.
        - External logic or changing conditions may end the dispatch at any time. For example,
          once a certain operational goal is met (like reaching a particular state-of-charge),
          the dispatch may end, or it may be allowed to continue if conditions warrant it.
        - Indefinite durations apply to each occurrence individually—every instance of a recurring
          dispatch can also be indefinite.

        For instance, a dispatch might aim to keep a battery’s SoC stable. If conditions never
        change, it could theoretically run forever. Conversely, another indefinite dispatch might
        end as soon as a particular SoC goal is reached.

    !!! note "Recurring Indefinite Dispatches"
        How recurring indefinite dispatches are managed is implementation-dependent.
        A key consideration is how to handle overlapping occurrences. For example, if a new
        dispatch is scheduled to start while a previous one is still running, the system
        needs a strategy to manage this.

        Commonly used approaches include:
        1.  **Start a new instance:** Each dispatch occurrence creates a new, independent
            instance that runs in parallel with any existing ones. This can lead to
            multiple dispatches "stacking up" if not managed carefully.
        2.  **Overwrite existing instances:** A new dispatch can replace an existing one
            based on certain criteria, such as having the same `type` or `target`
            components. This prevents multiple dispatches from running for the same
            purpose simultaneously.

        The chosen strategy is critical for preventing resource contention and ensuring
        predictable behavior, especially with indefinite, recurring dispatches.

    !!! note "Timestamps"
        Timestamps are in UTC. It is the responsibility of the receiver to translate UTC
        to respective local timezone.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    DURATION_FIELD_NUMBER: builtins.int
    TARGET_FIELD_NUMBER: builtins.int
    IS_ACTIVE_FIELD_NUMBER: builtins.int
    IS_DRY_RUN_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    RECURRENCE_FIELD_NUMBER: builtins.int
    type: builtins.str
    """The dispatch type.
    Contains user-defined information about what "type" of dispatch this is.
    Downstream applications that consume the dispatch API are responsible for
    understanding and processing this field.
    """
    duration: builtins.int
    """Duration in seconds
    The duration of the dispatch in seconds. If the duration is not set, the dispatch
    will be considered to have an indefinite duration.

    A duration of 0 seconds is also valid, indicating a dispatch that
    immediately starts and ends, e.g. switching a component on and off.

    Indefinite durations do not guarantee an eventual end; they continue until external logic changes it.
    """
    is_active: builtins.bool
    """The "active" status
    An active dispatch is eligible for processing, either immediately or at a scheduled
    time in the future, including recurring dispatches. If a dispatch is set to
    inactive, it won't be processed even if it matches all other conditions, allowing
    for temporary disabling of dispatches without deletion.
    """
    is_dry_run: builtins.bool
    """The "dry run" status
    A dry run dispatch is executed for logging and monitoring purposes
    without affecting the microgrid components. This is useful, for example,
    in scenarios where a user may want to test dispatch behavior without
    actually affecting any component states.
    Notably, a dispatch can be both "dry run" and "active," allowing for
    the system to generate logs and observe behavior without making actual changes.
    """
    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The dispatch start time in UTC.
        For reoccuring dispatches this is when the first time execution occurs. When
        creating a dispatch, ensure that the starting timestamp is set to the current
        time or any future time. Timestamps earlier than the current time are not allowed.
        """

    @property
    def target(self) -> global___TargetComponents:
        """The components this dispatch should apply to."""

    @property
    def payload(self) -> google.protobuf.struct_pb2.Struct:
        """The dispatch payload.

        Note!!!
            The payload field allows for flexible JSON data to be associated with this dispatch.
            The payload must adhere to the following constraints:
             - Maximum JSON nesting depth: 5 levels.
             - The data should not contain executable code or scripts.
             - Ensure all data is properly sanitized and encoded.
             - The total size of the payload should not exceed 50 KB.

        The payload is expected to follow a specific format that the downstream applications consuming the dispatch API
        are responsible for understanding and processing.

        Example JSON payload:
        {
          "settings": {
            "power_max": 10,   // Maximum power level for the dispatch (in kW)
            "soc_min": 20,     // Minimum state of charge for battery storage (in %)
            "soc_max": 80      // Maximum state of charge for battery storage (in %)
          }
        }

        In this example, a microgrid could use this payload to set operational parameters such as the maximum power output
        of a solar PV array or the charge/discharge limits of a battery storage system. This flexibility allows the microgrid
        to dynamically adjust its behavior based on the current needs or conditions, such as optimizing battery usage or
        limiting PV output during low demand periods.
        """

    @property
    def recurrence(self) -> global___RecurrenceRule:
        """The recurrence rule"""

    def __init__(
        self,
        *,
        type: builtins.str = ...,
        start_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        duration: builtins.int | None = ...,
        target: global___TargetComponents | None = ...,
        is_active: builtins.bool = ...,
        is_dry_run: builtins.bool = ...,
        payload: google.protobuf.struct_pb2.Struct | None = ...,
        recurrence: global___RecurrenceRule | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_duration", b"_duration", "duration", b"duration", "payload", b"payload", "recurrence", b"recurrence", "start_time", b"start_time", "target", b"target"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_duration", b"_duration", "duration", b"duration", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "payload", b"payload", "recurrence", b"recurrence", "start_time", b"start_time", "target", b"target", "type", b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_duration", b"_duration"]) -> typing.Literal["duration"] | None: ...

global___DispatchData = DispatchData

@typing.final
class Dispatch(google.protobuf.message.Message):
    """Represents a dispatch, including its metadata"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    METADATA_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    @property
    def metadata(self) -> global___DispatchMetadata:
        """Dispatch Metadata (id, create time, etc)"""

    @property
    def data(self) -> global___DispatchData:
        """The dispatch data"""

    def __init__(
        self,
        *,
        metadata: global___DispatchMetadata | None = ...,
        data: global___DispatchData | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["data", b"data", "metadata", b"metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["data", b"data", "metadata", b"metadata"]) -> None: ...

global___Dispatch = Dispatch

@typing.final
class DispatchMetadata(google.protobuf.message.Message):
    """Represents the metadata of a dispatch"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DISPATCH_ID_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    dispatch_id: builtins.int
    """Unique identifier of the microgrid dispatch."""
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """UTC Timestamp when the order was created."""

    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """UTC time of the last update to the order."""

    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """UTC Timestamp when the dispatch will stop working.

        Will be calculated internally based on the given: start_time,
        duration and `RecurrenceRule` settings. If the duration is not set (indefinite duration),
        there may be no calculable `end_time`. This means the dispatch does not have a
        predetermined stopping point and might run indefinitely. External logic, changes in
        conditions, or achieving certain operational goals may lead to its termination. If no
        such terminating condition occurs, it may effectively continue "forever."

        None if dispatch duration time is unset and this value can't be calculated.
        """

    def __init__(
        self,
        *,
        dispatch_id: builtins.int = ...,
        create_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        update_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        end_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["create_time", b"create_time", "end_time", b"end_time", "update_time", b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["create_time", b"create_time", "dispatch_id", b"dispatch_id", "end_time", b"end_time", "update_time", b"update_time"]) -> None: ...

global___DispatchMetadata = DispatchMetadata

@typing.final
class DispatchFilter(google.protobuf.message.Message):
    """Parameters for filtering the dispatch list"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class RecurrenceFilter(google.protobuf.message.Message):
        """Recurrence filters

        The fields are left commented out for now as the exact definition and requirements
        for recurrence filtering are still being finalized.
        The frequency specifier of this recurring dispatch
        optional RecurrenceRule.Frequency freq = 1;
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        def __init__(
            self,
        ) -> None: ...

    TARGETS_FIELD_NUMBER: builtins.int
    IS_ACTIVE_FIELD_NUMBER: builtins.int
    IS_DRY_RUN_FIELD_NUMBER: builtins.int
    IS_RECURRING_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    START_TIME_INTERVAL_FIELD_NUMBER: builtins.int
    END_TIME_INTERVAL_FIELD_NUMBER: builtins.int
    UPDATE_TIME_INTERVAL_FIELD_NUMBER: builtins.int
    DISPATCH_IDS_FIELD_NUMBER: builtins.int
    QUERIES_FIELD_NUMBER: builtins.int
    is_active: builtins.bool
    """Optional filter by active status.
    If this field is not set, dispatches of any active status will be included.
    """
    is_dry_run: builtins.bool
    """Optional filter by dry run status.
    If this field is not set, dispatches of any dry run status will be included.
    """
    is_recurring: builtins.bool
    """Filter by recurring status
    True: Only recurring dispatches will be returned.
    False: Only non-recurring dispatches will be returned.
    Examples:
    - To retrieve only recurring dispatches:
      filter { recurrence { is_recurring: true } }
    - To retrieve only non-recurring dispatches:
      filter { recurrence { is_recurring: false } }
    - To retrieve all dispatches:
      filter { recurrence {} }
    For advanced recurrence filtering, use the `filter` field.
    """
    @property
    def targets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TargetComponents]:
        """Optional filter by component ID or category."""

    @property
    def filter(self) -> global___DispatchFilter.RecurrenceFilter:
        """Filter by recurrence details
        Examples:
        - To retrieve only recurring dispatches with a specific frequency:
          filter { recurrence { filter { freq: FREQUENCY_DAILY } } }
        - To retrieve recurring dispatches with a specific frequency and interval:
          filter { recurrence { filter { freq: FREQUENCY_HOURLY, interval: 2 } } }
        - To retrieve recurring dispatches that end after a specific criteria:
          filter { recurrence { filter { end_criteria: { count: 10 } } } }
        - To retrieve recurring dispatches at specific minutes of the hour:
          filter { recurrence { filter { byminutes: [0, 15, 30, 45] } } }
        - To retrieve recurring dispatches at specific hours of the day:
          filter { recurrence { filter { byhours: [8, 12, 16] } } }
        - To retrieve recurring dispatches on specific days of the week:
          filter { recurrence { filter { byweekdays: [WEEKDAY_MONDAY, WEEKDAY_WEDNESDAY] } } }
        - To retrieve recurring dispatches on specific days of the month:
          filter { recurrence { filter { bymonthdays: [1, 15, 30, -1] } } }
        - To retrieve recurring dispatches in specific months of the year:
          filter { recurrence { filter { bymonths: [1, 6, 12] } } }
        """

    @property
    def start_time_interval(self) -> frequenz.api.common.v1alpha8.types.interval_pb2.Interval:
        """Optional filter by start time.
        If no interval is provided, all dispatches will be returned.
        """

    @property
    def end_time_interval(self) -> frequenz.api.common.v1alpha8.types.interval_pb2.Interval:
        """Optional filter by end time
        Filter dispatches based on their explicit end time.
        """

    @property
    def update_time_interval(self) -> frequenz.api.common.v1alpha8.types.interval_pb2.Interval:
        """Optional filter by update time"""

    @property
    def dispatch_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Optional filter by dispatch IDs.
        If this field is not set, dispatches with any ID will be included.
        Multiple IDs are combined with an OR relationship.
        """

    @property
    def queries(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Optional free-text search filter.

        This filter is applied to the dispatch `id` and `type` fields.
        The `queries` filter combines multiple queries with an OR relationship.

        ID tokens are preceded by a `#` so we can tell if an id is intended or a type.

        - input of [`#4`] will match only the record with id of `4`
        - input of [`bar`] will match `bar` and `foobar`
        - input of [`#4`, `#24`, `bar`, `foo`] will match ids of `4` and `24` and types `foo` `bar` `foobar` `foolish bartender`
        """

    def __init__(
        self,
        *,
        targets: collections.abc.Iterable[global___TargetComponents] | None = ...,
        is_active: builtins.bool | None = ...,
        is_dry_run: builtins.bool | None = ...,
        is_recurring: builtins.bool = ...,
        filter: global___DispatchFilter.RecurrenceFilter | None = ...,
        start_time_interval: frequenz.api.common.v1alpha8.types.interval_pb2.Interval | None = ...,
        end_time_interval: frequenz.api.common.v1alpha8.types.interval_pb2.Interval | None = ...,
        update_time_interval: frequenz.api.common.v1alpha8.types.interval_pb2.Interval | None = ...,
        dispatch_ids: collections.abc.Iterable[builtins.int] | None = ...,
        queries: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "end_time_interval", b"end_time_interval", "filter", b"filter", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "is_recurring", b"is_recurring", "recurrence", b"recurrence", "start_time_interval", b"start_time_interval", "update_time_interval", b"update_time_interval"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "dispatch_ids", b"dispatch_ids", "end_time_interval", b"end_time_interval", "filter", b"filter", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "is_recurring", b"is_recurring", "queries", b"queries", "recurrence", b"recurrence", "start_time_interval", b"start_time_interval", "targets", b"targets", "update_time_interval", b"update_time_interval"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_is_active", b"_is_active"]) -> typing.Literal["is_active"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_is_dry_run", b"_is_dry_run"]) -> typing.Literal["is_dry_run"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["recurrence", b"recurrence"]) -> typing.Literal["is_recurring", "filter"] | None: ...

global___DispatchFilter = DispatchFilter

@typing.final
class TargetComponents(google.protobuf.message.Message):
    """Parameter for controlling which components a dispatch applies to
    either a set of component IDs, or a set of component categories (with optional type).
    Examples:
    - To dispatch to a set of component IDs:
      components { component_ids { ids: [1, 2, 3] } }
    - To dispatch to a set of component categories:
      components {
        component_categories {
          categories: [
            {category: COMPONENT_CATEGORY_BATTERY, type: BATTERY_TYPE_LI_ION},
            {cateogry: COMPONENT_CRYPTO_MINER}
          ]
        }
      }
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class IdSet(google.protobuf.message.Message):
        """Wrapper for controlling dispatches with a set of component IDs
        Required as we can't use `repeated` directly in a `oneof`
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        IDS_FIELD_NUMBER: builtins.int
        @property
        def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """Set of component IDs"""

        def __init__(
            self,
            *,
            ids: collections.abc.Iterable[builtins.int] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["ids", b"ids"]) -> None: ...

    @typing.final
    class CategorySet(google.protobuf.message.Message):
        """Deprecated: Use `CategoryTypeSet` instead"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        CATEGORIES_FIELD_NUMBER: builtins.int
        @property
        def categories(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentCategory.ValueType]:
            """Set of component categories"""

        def __init__(
            self,
            *,
            categories: collections.abc.Iterable[frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentCategory.ValueType] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["categories", b"categories"]) -> None: ...

    @typing.final
    class CategoryTypeSet(google.protobuf.message.Message):
        """Wrapper for controlling dispatches with a set of component categories and optional types
        Required as we can't use `repeated` directly in a `oneof`
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        CATEGORIES_FIELD_NUMBER: builtins.int
        @property
        def categories(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TargetComponents.CategoryAndType]:
            """Set of component categories"""

        def __init__(
            self,
            *,
            categories: collections.abc.Iterable[global___TargetComponents.CategoryAndType] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["categories", b"categories"]) -> None: ...

    @typing.final
    class CategoryAndType(google.protobuf.message.Message):
        """A tuple of a required category and an optional type
        If a type is specified, it must be a valid type for the given category and
        only components of that type will be targeted.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        CATEGORY_FIELD_NUMBER: builtins.int
        BATTERY_FIELD_NUMBER: builtins.int
        INVERTER_FIELD_NUMBER: builtins.int
        EV_CHARGER_FIELD_NUMBER: builtins.int
        category: frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentCategory.ValueType
        """The category of the target component (required)"""
        battery: frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.BatteryType.ValueType
        """The type of battery
        Only applicable if the category is COMPONENT_CATEGORY_BATTERY
        """
        inverter: frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.InverterType.ValueType
        """The type of solar array
        Only applicable if the category is COMPONENT_CATEGORY_INVERTER
        """
        ev_charger: frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.EvChargerType.ValueType
        """The type of EV charger
        Only applicable if the category is COMPONENT_CATEGORY_EV_CHARGER
        """
        def __init__(
            self,
            *,
            category: frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentCategory.ValueType = ...,
            battery: frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.BatteryType.ValueType = ...,
            inverter: frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.InverterType.ValueType = ...,
            ev_charger: frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.EvChargerType.ValueType = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["battery", b"battery", "ev_charger", b"ev_charger", "inverter", b"inverter", "type", b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["battery", b"battery", "category", b"category", "ev_charger", b"ev_charger", "inverter", b"inverter", "type", b"type"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["type", b"type"]) -> typing.Literal["battery", "inverter", "ev_charger"] | None: ...

    COMPONENT_IDS_FIELD_NUMBER: builtins.int
    COMPONENT_CATEGORIES_FIELD_NUMBER: builtins.int
    COMPONENT_CATEGORIES_TYPES_FIELD_NUMBER: builtins.int
    @property
    def component_ids(self) -> global___TargetComponents.IdSet:
        """Set of component IDs"""

    @property
    def component_categories(self) -> global___TargetComponents.CategorySet:
        """Deprecated: Component categories
        Use `CategoryTypeSet` instead
        In future versions, this field will be removed.
        """

    @property
    def component_categories_types(self) -> global___TargetComponents.CategoryTypeSet:
        """Component categories with optional types"""

    def __init__(
        self,
        *,
        component_ids: global___TargetComponents.IdSet | None = ...,
        component_categories: global___TargetComponents.CategorySet | None = ...,
        component_categories_types: global___TargetComponents.CategoryTypeSet | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["component_categories", b"component_categories", "component_categories_types", b"component_categories_types", "component_ids", b"component_ids", "components", b"components"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["component_categories", b"component_categories", "component_categories_types", b"component_categories_types", "component_ids", b"component_ids", "components", b"components"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["components", b"components"]) -> typing.Literal["component_ids", "component_categories", "component_categories_types"] | None: ...

global___TargetComponents = TargetComponents

@typing.final
class RecurrenceRule(google.protobuf.message.Message):
    """Ruleset governing when and how a dispatch should re-occur.

    Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC
    to its local timezone.

    This definition tries to adhere closely to the iCalendar specification ([RFC5545]),
    particularly for recurrence rules. For advanced use-cases or further clarifications,
    refer to [RFC5545].

    [RFC5545]: https://tools.ietf.org/html/rfc5545

    #### Examples

    ##### Every 6 months

    ```proto
    message RecurrenceRule {
      Frequency freq = FREQUENCY_MONTHLY;
      uint32 interval = 6;
    }
    ```

    ##### Weekends only

    ```proto
    message RecurrenceRule {
      Frequency freq = FREQUENCY_WEEKLY;
      repeated Weekday byweekdays = [WEEKDAY_SATURDAY, WEEKDAY_SUNDAY];
    }
    ```

    ##### At midnight

    Every day at midnight.

    ```proto
    message RecurrenceRule {
      Frequency freq = FREQUENCY_DAILY;
      repeated uint32 byhours = [0];
    }
    ```

    ##### Nightly

    Assuming "night" means from 8 PM to 6 AM.

    ```proto
    message RecurrenceRule {
      Frequency freq = FREQUENCY_DAILY;
      repeated uint32 byhours = [20, 21, 22, 23, 0, 1, 2, 3, 4, 5];
    }
    ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Weekday:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _WeekdayEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RecurrenceRule._Weekday.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        WEEKDAY_UNSPECIFIED: RecurrenceRule._Weekday.ValueType  # 0
        WEEKDAY_MONDAY: RecurrenceRule._Weekday.ValueType  # 1
        WEEKDAY_TUESDAY: RecurrenceRule._Weekday.ValueType  # 2
        WEEKDAY_WEDNESDAY: RecurrenceRule._Weekday.ValueType  # 3
        WEEKDAY_THURSDAY: RecurrenceRule._Weekday.ValueType  # 4
        WEEKDAY_FRIDAY: RecurrenceRule._Weekday.ValueType  # 5
        WEEKDAY_SATURDAY: RecurrenceRule._Weekday.ValueType  # 6
        WEEKDAY_SUNDAY: RecurrenceRule._Weekday.ValueType  # 7

    class Weekday(_Weekday, metaclass=_WeekdayEnumTypeWrapper):
        """Enum representing the day of the week"""

    WEEKDAY_UNSPECIFIED: RecurrenceRule.Weekday.ValueType  # 0
    WEEKDAY_MONDAY: RecurrenceRule.Weekday.ValueType  # 1
    WEEKDAY_TUESDAY: RecurrenceRule.Weekday.ValueType  # 2
    WEEKDAY_WEDNESDAY: RecurrenceRule.Weekday.ValueType  # 3
    WEEKDAY_THURSDAY: RecurrenceRule.Weekday.ValueType  # 4
    WEEKDAY_FRIDAY: RecurrenceRule.Weekday.ValueType  # 5
    WEEKDAY_SATURDAY: RecurrenceRule.Weekday.ValueType  # 6
    WEEKDAY_SUNDAY: RecurrenceRule.Weekday.ValueType  # 7

    class _Frequency:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _FrequencyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RecurrenceRule._Frequency.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        FREQUENCY_UNSPECIFIED: RecurrenceRule._Frequency.ValueType  # 0
        FREQUENCY_MINUTELY: RecurrenceRule._Frequency.ValueType  # 1
        FREQUENCY_HOURLY: RecurrenceRule._Frequency.ValueType  # 2
        FREQUENCY_DAILY: RecurrenceRule._Frequency.ValueType  # 3
        FREQUENCY_WEEKLY: RecurrenceRule._Frequency.ValueType  # 4
        FREQUENCY_MONTHLY: RecurrenceRule._Frequency.ValueType  # 5
        FREQUENCY_YEARLY: RecurrenceRule._Frequency.ValueType  # 6

    class Frequency(_Frequency, metaclass=_FrequencyEnumTypeWrapper):
        """Enum representing the frequency of the recurrence"""

    FREQUENCY_UNSPECIFIED: RecurrenceRule.Frequency.ValueType  # 0
    FREQUENCY_MINUTELY: RecurrenceRule.Frequency.ValueType  # 1
    FREQUENCY_HOURLY: RecurrenceRule.Frequency.ValueType  # 2
    FREQUENCY_DAILY: RecurrenceRule.Frequency.ValueType  # 3
    FREQUENCY_WEEKLY: RecurrenceRule.Frequency.ValueType  # 4
    FREQUENCY_MONTHLY: RecurrenceRule.Frequency.ValueType  # 5
    FREQUENCY_YEARLY: RecurrenceRule.Frequency.ValueType  # 6

    @typing.final
    class EndCriteria(google.protobuf.message.Message):
        """Controls when a recurring dispatch should end"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        COUNT_FIELD_NUMBER: builtins.int
        UNTIL_TIME_FIELD_NUMBER: builtins.int
        count: builtins.int
        """The number of times this dispatch should recur.
        If this field is set, the dispatch will recur the given number of times.
        Valid values are 1 to 4096.
        """
        @property
        def until_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The end time of this dispatch in UTC.
            If this field is set, the last recurrence event will start before this
            timestamp.
            Note that the duration of the event is not considered in this value,
            so the dispatch may end after the timestamp.
            """

        def __init__(
            self,
            *,
            count: builtins.int = ...,
            until_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["count", b"count", "count_or_until", b"count_or_until", "until_time", b"until_time"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["count", b"count", "count_or_until", b"count_or_until", "until_time", b"until_time"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["count_or_until", b"count_or_until"]) -> typing.Literal["count", "until_time"] | None: ...

    FREQ_FIELD_NUMBER: builtins.int
    INTERVAL_FIELD_NUMBER: builtins.int
    END_CRITERIA_FIELD_NUMBER: builtins.int
    BYMINUTES_FIELD_NUMBER: builtins.int
    BYHOURS_FIELD_NUMBER: builtins.int
    BYWEEKDAYS_FIELD_NUMBER: builtins.int
    BYMONTHDAYS_FIELD_NUMBER: builtins.int
    BYMONTHS_FIELD_NUMBER: builtins.int
    freq: global___RecurrenceRule.Frequency.ValueType
    """The frequency specifier of this recurring dispatch"""
    interval: builtins.int
    """How often this dispatch should recur, based on the frequency
    Example:
    - Every 2 hours:
      freq = FREQUENCY_HOURLY
      interval = 2
    Valid values typically range between 1 and 10_000, depending on the implementation.
    """
    @property
    def end_criteria(self) -> global___RecurrenceRule.EndCriteria:
        """When this dispatch should end.
        A dispatch can either recur a fixed number of times, or until a given timestamp.
        If this field is not set, the dispatch will recur indefinitely.
        """

    @property
    def byminutes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which minute(s) of the hour does the event occur"""

    @property
    def byhours(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which hour(s) of the day does the event occur"""

    @property
    def byweekdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___RecurrenceRule.Weekday.ValueType]:
        """On which day(s) of the week does the event occur"""

    @property
    def bymonthdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which day(s) of the month does the event occur. Valid values are 1 to 31 or -31 to -1.

        For example, -10 represents the tenth to the last day of the month.
        The bymonthdays rule part MUST NOT be specified when the FREQ rule part is set to WEEKLY.
        """

    @property
    def bymonths(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which month(s) of the year does the event occur"""

    def __init__(
        self,
        *,
        freq: global___RecurrenceRule.Frequency.ValueType = ...,
        interval: builtins.int = ...,
        end_criteria: global___RecurrenceRule.EndCriteria | None = ...,
        byminutes: collections.abc.Iterable[builtins.int] | None = ...,
        byhours: collections.abc.Iterable[builtins.int] | None = ...,
        byweekdays: collections.abc.Iterable[global___RecurrenceRule.Weekday.ValueType] | None = ...,
        bymonthdays: collections.abc.Iterable[builtins.int] | None = ...,
        bymonths: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_criteria", b"end_criteria"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["byhours", b"byhours", "byminutes", b"byminutes", "bymonthdays", b"bymonthdays", "bymonths", b"bymonths", "byweekdays", b"byweekdays", "end_criteria", b"end_criteria", "freq", b"freq", "interval", b"interval"]) -> None: ...

global___RecurrenceRule = RecurrenceRule

@typing.final
class SortOptions(google.protobuf.message.Message):
    """Message defining parameters for sorting list requests.

    Example Usage:
    To retrieve dispatches sorted by creation time in descending order:
    sort_options: { field: CREATE_TIME, order: DESCENDING }
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SORT_FIELD_FIELD_NUMBER: builtins.int
    SORT_ORDER_FIELD_NUMBER: builtins.int
    sort_field: global___SortField.ValueType
    """Optional field by which to sort the results."""
    sort_order: global___SortOrder.ValueType
    """Optional Order in which to sort the results."""
    def __init__(
        self,
        *,
        sort_field: global___SortField.ValueType = ...,
        sort_order: global___SortOrder.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["sort_field", b"sort_field", "sort_order", b"sort_order"]) -> None: ...

global___SortOptions = SortOptions

@typing.final
class ListMicrogridDispatchesRequest(google.protobuf.message.Message):
    """Message for listing dispatches for a given microgrid.

    Allows retrieval of dispatches for a specified microgrid with optional filtering and sorting.
    Sorting can be specified by setting 'sort_field' and 'sort_order'. If no sorting is specified,
    the results will be returned by their create time in a descending order.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    SORT_OPTIONS_FIELD_NUMBER: builtins.int
    PAGINATION_PARAMS_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid ID"""
    @property
    def filter(self) -> global___DispatchFilter:
        """Optional filters to apply"""

    @property
    def sort_options(self) -> global___SortOptions:
        """Sorting options for the result"""

    @property
    def pagination_params(self) -> frequenz.api.common.v1alpha8.pagination.pagination_params_pb2.PaginationParams:
        """Pagination Parameters
        page_size: Amount of items to return per page. Should only be provided in the first request.
        page_token: Cursor to specify which page to return. Should not be set in the first request.
                    Should be populated in subsequent requests by the `next_page_token` found in
                    the `pagination_info` in the response.
                    The tokens stays valid indefinitely.
        """

    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        filter: global___DispatchFilter | None = ...,
        sort_options: global___SortOptions | None = ...,
        pagination_params: frequenz.api.common.v1alpha8.pagination.pagination_params_pb2.PaginationParams | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter", "pagination_params", b"pagination_params", "sort_options", b"sort_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filter", b"filter", "microgrid_id", b"microgrid_id", "pagination_params", b"pagination_params", "sort_options", b"sort_options"]) -> None: ...

global___ListMicrogridDispatchesRequest = ListMicrogridDispatchesRequest

@typing.final
class ListMicrogridDispatchesResponse(google.protobuf.message.Message):
    """A list of dispatches"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DISPATCHES_FIELD_NUMBER: builtins.int
    PAGINATION_INFO_FIELD_NUMBER: builtins.int
    @property
    def dispatches(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Dispatch]:
        """The dispatches"""

    @property
    def pagination_info(self) -> frequenz.api.common.v1alpha8.pagination.pagination_info_pb2.PaginationInfo:
        """Pagination Info
        total_items: Total amount of entries found by the list request.
        next_page_token: Token that can be used to request the next page.
                         Will be unset if no further pages exist.
        """

    def __init__(
        self,
        *,
        dispatches: collections.abc.Iterable[global___Dispatch] | None = ...,
        pagination_info: frequenz.api.common.v1alpha8.pagination.pagination_info_pb2.PaginationInfo | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["pagination_info", b"pagination_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["dispatches", b"dispatches", "pagination_info", b"pagination_info"]) -> None: ...

global___ListMicrogridDispatchesResponse = ListMicrogridDispatchesResponse

@typing.final
class CreateMicrogridDispatchRequest(google.protobuf.message.Message):
    """Message to create a new dispatch with the given attributes"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    DISPATCH_DATA_FIELD_NUMBER: builtins.int
    START_IMMEDIATELY_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid identifier"""
    start_immediately: builtins.bool
    """Optional, set start_time to NOW() (server-time) if set"""
    @property
    def dispatch_data(self) -> global___DispatchData:
        """Content of the dispatch to be created"""

    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        dispatch_data: global___DispatchData | None = ...,
        start_immediately: builtins.bool | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_start_immediately", b"_start_immediately", "dispatch_data", b"dispatch_data", "start_immediately", b"start_immediately"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_start_immediately", b"_start_immediately", "dispatch_data", b"dispatch_data", "microgrid_id", b"microgrid_id", "start_immediately", b"start_immediately"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_start_immediately", b"_start_immediately"]) -> typing.Literal["start_immediately"] | None: ...

global___CreateMicrogridDispatchRequest = CreateMicrogridDispatchRequest

@typing.final
class CreateMicrogridDispatchResponse(google.protobuf.message.Message):
    """Response message for creating a new dispatch"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DISPATCH_FIELD_NUMBER: builtins.int
    @property
    def dispatch(self) -> global___Dispatch:
        """The created dispatch"""

    def __init__(
        self,
        *,
        dispatch: global___Dispatch | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["dispatch", b"dispatch"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["dispatch", b"dispatch"]) -> None: ...

global___CreateMicrogridDispatchResponse = CreateMicrogridDispatchResponse

@typing.final
class UpdateMicrogridDispatchRequest(google.protobuf.message.Message):
    """Message to update the dispatch with the given ID, with the given attributes"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class DispatchUpdate(google.protobuf.message.Message):
        """Message containing the updated dispatch attributes"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class RecurrenceRuleUpdate(google.protobuf.message.Message):
            """Message containing the updated recurrence rule attributes"""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            FREQ_FIELD_NUMBER: builtins.int
            INTERVAL_FIELD_NUMBER: builtins.int
            END_CRITERIA_FIELD_NUMBER: builtins.int
            BYMINUTES_FIELD_NUMBER: builtins.int
            BYHOURS_FIELD_NUMBER: builtins.int
            BYWEEKDAYS_FIELD_NUMBER: builtins.int
            BYMONTHDAYS_FIELD_NUMBER: builtins.int
            BYMONTHS_FIELD_NUMBER: builtins.int
            freq: global___RecurrenceRule.Frequency.ValueType
            """The frequency specifier of this recurring dispatch"""
            interval: builtins.int
            """How often this dispatch should recur, based on the frequency"""
            @property
            def end_criteria(self) -> global___RecurrenceRule.EndCriteria:
                """When this dispatch should end."""

            @property
            def byminutes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which minute(s) of the hour does the event occur"""

            @property
            def byhours(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which hour(s) of the day does the event occur"""

            @property
            def byweekdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___RecurrenceRule.Weekday.ValueType]:
                """On which day(s) of the week does the event occur"""

            @property
            def bymonthdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which day(s) of the month does the event occur. Valid values are 1 to 31 or -31 to -1.

                For example, -10 represents the tenth to the last day of the month.
                The bymonthdays rule part MUST NOT be specified when the FREQ rule part is set to WEEKLY.
                """

            @property
            def bymonths(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which month(s) of the year does the event occur"""

            def __init__(
                self,
                *,
                freq: global___RecurrenceRule.Frequency.ValueType | None = ...,
                interval: builtins.int | None = ...,
                end_criteria: global___RecurrenceRule.EndCriteria | None = ...,
                byminutes: collections.abc.Iterable[builtins.int] | None = ...,
                byhours: collections.abc.Iterable[builtins.int] | None = ...,
                byweekdays: collections.abc.Iterable[global___RecurrenceRule.Weekday.ValueType] | None = ...,
                bymonthdays: collections.abc.Iterable[builtins.int] | None = ...,
                bymonths: collections.abc.Iterable[builtins.int] | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["_freq", b"_freq", "_interval", b"_interval", "end_criteria", b"end_criteria", "freq", b"freq", "interval", b"interval"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["_freq", b"_freq", "_interval", b"_interval", "byhours", b"byhours", "byminutes", b"byminutes", "bymonthdays", b"bymonthdays", "bymonths", b"bymonths", "byweekdays", b"byweekdays", "end_criteria", b"end_criteria", "freq", b"freq", "interval", b"interval"]) -> None: ...
            @typing.overload
            def WhichOneof(self, oneof_group: typing.Literal["_freq", b"_freq"]) -> typing.Literal["freq"] | None: ...
            @typing.overload
            def WhichOneof(self, oneof_group: typing.Literal["_interval", b"_interval"]) -> typing.Literal["interval"] | None: ...

        START_TIME_FIELD_NUMBER: builtins.int
        DURATION_FIELD_NUMBER: builtins.int
        TARGET_FIELD_NUMBER: builtins.int
        IS_ACTIVE_FIELD_NUMBER: builtins.int
        PAYLOAD_FIELD_NUMBER: builtins.int
        RECURRENCE_FIELD_NUMBER: builtins.int
        duration: builtins.int
        """Duration in seconds"""
        is_active: builtins.bool
        """The "active" status"""
        @property
        def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The start time in UTC.
            When updating a dispatch, ensure that the starting timestamp is set to
            the current time or any future time.
            Timestamps earlier than the current time are not allowed.
            """

        @property
        def target(self) -> global___TargetComponents:
            """The target components"""

        @property
        def payload(self) -> google.protobuf.struct_pb2.Struct:
            """The dispatch payload"""

        @property
        def recurrence(self) -> global___UpdateMicrogridDispatchRequest.DispatchUpdate.RecurrenceRuleUpdate:
            """The recurrence rule"""

        def __init__(
            self,
            *,
            start_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
            duration: builtins.int | None = ...,
            target: global___TargetComponents | None = ...,
            is_active: builtins.bool | None = ...,
            payload: google.protobuf.struct_pb2.Struct | None = ...,
            recurrence: global___UpdateMicrogridDispatchRequest.DispatchUpdate.RecurrenceRuleUpdate | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["_duration", b"_duration", "_is_active", b"_is_active", "duration", b"duration", "is_active", b"is_active", "payload", b"payload", "recurrence", b"recurrence", "start_time", b"start_time", "target", b"target"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["_duration", b"_duration", "_is_active", b"_is_active", "duration", b"duration", "is_active", b"is_active", "payload", b"payload", "recurrence", b"recurrence", "start_time", b"start_time", "target", b"target"]) -> None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_duration", b"_duration"]) -> typing.Literal["duration"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_is_active", b"_is_active"]) -> typing.Literal["is_active"] | None: ...

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    DISPATCH_ID_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    UPDATE_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """ID of the microgrid"""
    dispatch_id: builtins.int
    """The dispatch identifier"""
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Field mask specifying which fields should be updated"""

    @property
    def update(self) -> global___UpdateMicrogridDispatchRequest.DispatchUpdate:
        """The updated dispatch attributes"""

    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        dispatch_id: builtins.int = ...,
        update_mask: google.protobuf.field_mask_pb2.FieldMask | None = ...,
        update: global___UpdateMicrogridDispatchRequest.DispatchUpdate | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["update", b"update", "update_mask", b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["dispatch_id", b"dispatch_id", "microgrid_id", b"microgrid_id", "update", b"update", "update_mask", b"update_mask"]) -> None: ...

global___UpdateMicrogridDispatchRequest = UpdateMicrogridDispatchRequest

@typing.final
class UpdateMicrogridDispatchResponse(google.protobuf.message.Message):
    """Response message for updating a dispatch"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DISPATCH_FIELD_NUMBER: builtins.int
    @property
    def dispatch(self) -> global___Dispatch:
        """The updated dispatch"""

    def __init__(
        self,
        *,
        dispatch: global___Dispatch | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["dispatch", b"dispatch"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["dispatch", b"dispatch"]) -> None: ...

global___UpdateMicrogridDispatchResponse = UpdateMicrogridDispatchResponse

@typing.final
class GetMicrogridDispatchRequest(google.protobuf.message.Message):
    """Message to get a single dispatch by its ID"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    DISPATCH_ID_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid ID that the dispatch belongs to"""
    dispatch_id: builtins.int
    """The dispatch identifier"""
    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        dispatch_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["dispatch_id", b"dispatch_id", "microgrid_id", b"microgrid_id"]) -> None: ...

global___GetMicrogridDispatchRequest = GetMicrogridDispatchRequest

@typing.final
class GetMicrogridDispatchResponse(google.protobuf.message.Message):
    """Response message for getting a single dispatch"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    DISPATCH_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid ID that the dispatch belongs to"""
    @property
    def dispatch(self) -> global___Dispatch:
        """The dispatch"""

    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        dispatch: global___Dispatch | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["dispatch", b"dispatch"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["dispatch", b"dispatch", "microgrid_id", b"microgrid_id"]) -> None: ...

global___GetMicrogridDispatchResponse = GetMicrogridDispatchResponse

@typing.final
class DeleteMicrogridDispatchRequest(google.protobuf.message.Message):
    """Message to delete a single dispatch by its ID"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    DISPATCH_ID_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid ID that the dispatch belongs to"""
    dispatch_id: builtins.int
    """The dispatch identifier"""
    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        dispatch_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["dispatch_id", b"dispatch_id", "microgrid_id", b"microgrid_id"]) -> None: ...

global___DeleteMicrogridDispatchRequest = DeleteMicrogridDispatchRequest

@typing.final
class DeleteMicrogridDispatchResponse(google.protobuf.message.Message):
    """Response message for deleting a single dispatch"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    DISPATCH_ID_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid ID that the dispatch belonged to"""
    dispatch_id: builtins.int
    """The dispatch ID that was deleted"""
    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        dispatch_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["dispatch_id", b"dispatch_id", "microgrid_id", b"microgrid_id"]) -> None: ...

global___DeleteMicrogridDispatchResponse = DeleteMicrogridDispatchResponse
