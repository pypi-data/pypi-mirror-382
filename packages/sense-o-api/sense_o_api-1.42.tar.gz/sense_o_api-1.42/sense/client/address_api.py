#!/usr/bin/env python3
# coding: utf-8
"""
    SENSE-O Northbound Address API

    StackV SENSE-O Northbound REST API Documentation  # noqa: E501

    OpenAPI spec version: 2.0.2

    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""
import json
from sense.client.requestwrapper import RequestWrapper
from sense.common import classwrapper

@classwrapper
class AddressApi():
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, req_wrapper=None):
        if req_wrapper is None:
            self.client = RequestWrapper()
        else:
            self.client = req_wrapper

    def get_allocations(self, pool: str, **kwargs):  # noqa: E501
        """Retrieve allocations by pool and scope  # noqa: E501

        Queries all service intents belonging to given instance UUID.  # noqa: E501
        This method makes a synchronous HTTP request by default.
        :param async_req bool
        :param str pool: Pool Name. (required)
        :return: list[IntentExpanded]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.allocations_get_with_http_info(pool, **kwargs)  # noqa: E501
        else:
            (data) = self.allocations_get_with_http_info(pool, **kwargs)  # noqa: E501
            return data

    def allocations_get_with_http_info(self, pool: str,
                                       **kwargs):  # noqa: E501
        """Retrieve allocations by pool and scope  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.allocations_get_with_http_info(pool, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pool: Pool Name (required)
        :return: list[Allocations]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool', 'scope']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'"
                                " to method allocations_get_with_http_info" % key)
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'si_uuid' is set
        if 'pool' not in params or params['pool'] is None:
            raise ValueError(
                "Missing the required parameter `pool` when calling `allocations_get_with_http_info`"
            )  # noqa: E501
        if 'scope' not in params:
            params['scope'] = 'default'
        return self.client.request('GET', '/address/allocate/' + pool + '/' + params['scope'])

    def allocate_ipv4_address(self, pool: str, alloc_name: str, batch: str, scope='default'):
        return self.allocate_address(pool, 'IPv4', alloc_name, batch=batch, scope=scope)

    def allocate_ipv4_subnet(self, pool: str, alloc_name: str, netmask: str, scope='default'):
        return self.allocate_address(pool, 'IPv4', alloc_name, batch='subnet', netmask=netmask, scope=scope)

    def allocate_ipv4_address_subnet(self, pool: str, alloc_name: str, batch: str, netmask: str, scope='default'):
        return self.allocate_address(pool, 'IPv4', alloc_name, batch=batch, netmask=netmask, scope=scope)

    def allocate_ipv6_address(self, pool: str, alloc_name: str, batch: str, scope='default'):
        return self.allocate_address(pool, 'IPv6', alloc_name, batch=batch, scope=scope)

    def allocate_ipv6_subnet(self, pool: str, alloc_name: str, netmask: str, scope='default'):
        return self.allocate_address(pool, 'IPv6', alloc_name, batch='subnet', netmask=netmask, scope=scope)

    def allocate_ipv6_address_subnet(self, pool: str, alloc_name: str, batch: str, netmask: str, scope='default'):
        return self.allocate_address(pool, 'IPv6', alloc_name, batch=batch, netmask=netmask, scope=scope)

    def allocate_mac_address(self, pool: str, alloc_name: str, batch: str, scope='default'):
        return self.allocate_address(pool, 'MAC', alloc_name, batch=batch, scope=scope)

    def allocate_id_address(self, pool: str, alloc_name: str, batch: str, scope='default'):
        return self.allocate_address(pool, 'ID', alloc_name, batch=batch, scope=scope)

    def allocate_address(self, pool: str, addr_type: str, alloc_name: str, **kwargs):  # noqa: E501
        """allocate address by pool, scope and name  # noqa: E501
        This method makes a synchronous HTTP request by default.
        :param async_req bool
        :param str pool: Pool Name. (required)
        :param str alloc_name: Alloc Name. (required)
        :return: allocation result
                 If the method is called asynchronously,
                 returns the request thread.
        """

        kwargs['_return_http_data_only'] = True

        if addr_type not in ['IPv4', 'IPv6', 'MAC', 'ID']:
            raise ValueError(
                "Parameter 'type' must of one of ['ipv4', 'ipv6', 'mac', 'id']"
            )  # noqa: E501
        if 'scope' not in kwargs:
            scope = 'default'
        else:
            scope = kwargs['scope']
        if 'batch' not in kwargs:
            batch = 1
        else:
            batch = kwargs['batch']
            if batch.isnumeric():
                batch = int(batch)
            elif batch != 'subnet':
                raise ValueError(
                    "Parameter `batch` must be either numeric or 'subnet'"
                )  # noqa: E501
        allocRequest = {'type': addr_type, 'name': alloc_name}

        allocParams = {'scope': scope, 'batch': batch}
        if batch == 'subnet':
            if 'netmask' not in kwargs:
                raise ValueError(
                    "Missing the required parameter `netmask` when calling `allocate_post_with_http_info` for 'subnet' alloc"
                )  # noqa: E501
            allocParams['netmask'] = kwargs['netmask']
        elif not isinstance(batch, int) or batch < 1:
            raise ValueError(
                "Parameter `batch` must be either numeric or 'subnet'"
            )  # noqa: E501
        else:
            if 'netmask' in kwargs:
                allocParams['netmask'] = kwargs['netmask']
        allocRequest['allocate'] = allocParams

        if kwargs.get('async_req'):
            return self.allocate_post_with_http_info(pool, json.dumps(allocRequest), **kwargs)  # noqa: E501
        else:
            (data) = self.allocate_post_with_http_info(pool, json.dumps(allocRequest), **kwargs)  # noqa: E501
            return data

    def allocate_post_with_http_info(self, pool: str, body: str,
                                     **kwargs):  # noqa: E501
        """allocate address by pool, scope and name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.allocate_post_with_http_info(pool, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pool: Pool Name (required)
        :return: list[Allocations]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool', 'scope', 'type', 'name', 'batch', 'netmask']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'"
                                " to method intent_instance_si_uuid_get" % key)
            params[key] = val
        del params['kwargs']

        path_params = {}
        query_params = []

        return self.client.request('POST',
                                   '/address/allocate/' + pool,
                                   body_params=body)

    def free_address(self, pool: str, **kwargs):  # noqa: E501
        """free address by pool by scope and optionally with address or name  # noqa: E501

        This method makes a synchronous HTTP request by default.
        :param async_req bool
        :param str pool: Pool Name. (required)
        :return: allocation result
                 If the method is called asynchronously,
                 returns the request thread.
        """

        kwargs['_return_http_data_only'] = True

        if 'scope' not in kwargs:
            kwargs['scope'] = 'default'

        if kwargs.get('async_req'):
            return self.free_delete_with_http_info(pool, **kwargs)  # noqa: E501
        else:
            (data) = self.free_delete_with_http_info(pool, **kwargs)  # noqa: E501
            return data

    def free_delete_with_http_info(self, pool: str,
                                   **kwargs):  # noqa: E501
        """free address by pool by scope and optionally with address or name  # noqa: E501

        Queries all allocations belonging to given pool and scope.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.free_delete_with_http_info(pool, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pool: Pool Name (required)
        :return: list[Allocations]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool', 'scope', 'name', 'address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'"
                                " to method intent_instance_si_uuid_get" % key)
            params[key] = val
        del params['kwargs']

        if 'pool' not in params or params['pool'] is None:
            raise ValueError(
                "Missing the required parameter `pool` when calling `allocations_get_with_http_info`"
            )  # noqa: E501
        if 'scope' not in params:
            params['scope'] = 'default'

        if 'address' not in params and 'name' not in params:
            return self.client.request('DELETE',
                                       '/address/allocate/' + pool + '/' + params['scope'])
        elif 'address' in params:
            address = params['address'].replace('/', '%2F')
            return self.client.request('DELETE',
                                       '/address/allocate/' + pool + '/' + address + '/' + params['scope'])
        else:
            return self.client.request('DELETE',
                                       '/address/allocate/' + pool + '/name/' + params['name'] + '/' + params['scope'])

    def affiliate_address(self, pool: str, uri: str, **kwargs):  # noqa: E501
        """affilicate address with resource uri by address or name  # noqa: E501
        This method makes a synchronous HTTP request by default.
        :param async_req bool
        :param str pool: Pool Name. (required)
        :return: allocation result
                 If the method is called asynchronously,
                 returns the request thread.
        """

        kwargs['_return_http_data_only'] = True

        if 'scope' not in kwargs:
            kwargs['scope'] = 'default'

        if kwargs.get('async_req'):
            return self.affiliate_put_with_http_info(pool, uri, **kwargs)  # noqa: E501
        else:
            (data) = self.affiliate_put_with_http_info(pool, uri, **kwargs)  # noqa: E501
            return data

    def affiliate_put_with_http_info(self, pool: str, uri: str,
                                     **kwargs):  # noqa: E501
        """affilicate address with resource uri by address or name  # noqa: E501
        Queries all allocations belonging to given pool and scope.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.affiliate_put_with_http_info(pool, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pool: Pool Name (required)
        :param str uri: Affiliated resource URI (required)
        :return: list[Allocations]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool', 'scope', 'name', 'address', 'uri']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in params['kwargs'].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'"
                                " to method intent_instance_si_uuid_get" % key)
            params[key] = val
        del params['kwargs']

        if 'pool' not in params or params['pool'] is None:
            raise ValueError(
                "Missing the required parameter `pool` when calling `allocations_get_with_http_info`"
            )  # noqa: E501
        if 'scope' not in params:
            params['scope'] = 'default'

        if 'address' not in params and 'name' not in params:
            raise TypeError("affiliate_address call needs either a 'name' or 'address' parameter")
        elif 'address' in params:
            address = params['address'].replace('/', '%2F')
            return self.client.request('PUT',
                                       '/address/affiliate/' + pool + '/' + address + '/' + params['scope'] + '/' + uri)
        else:
            return self.client.request('PUT',
                                       '/address/affiliate/' + pool + '/name/' + params['name'] + '/' + params[
                                           'scope'] + '/' + uri)
