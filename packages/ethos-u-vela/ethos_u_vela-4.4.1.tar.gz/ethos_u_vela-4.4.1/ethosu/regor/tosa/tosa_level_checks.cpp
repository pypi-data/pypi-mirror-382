//
// SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the License); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an AS IS BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Partially generated by tosaValidationGenerator for TOSA Specification 1.0.0draft
// TODO: Implement the constraints.

#include "tosa_level_checks.hpp"

namespace tosa
{
namespace validator
{
namespace checks
{
// Checks for TOSA Specification 1.0.0draft
void LevelCheck_1lz89reckvj8d(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: ARGMAX, RESHAPE,
    static constexpr char constraint[] = "LEVEL_CHECK(rank(shape1) <= MAX_RANK)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_2i1ithnrq06wi(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: AVG_POOL2D, MAX_POOL2D,
    static constexpr char constraint[] = "LEVEL_CHECK(kernel_y <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1wobi8axf7z2y(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: AVG_POOL2D, MAX_POOL2D,
    static constexpr char constraint[] = "LEVEL_CHECK(kernel_x <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1xppm0ufw64nq(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: AVG_POOL2D, CONV2D, CONV3D, DEPTHWISE_CONV2D, MAX_POOL2D, TRANSPOSE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(stride_y <= MAX_STRIDE)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_as2lzdd5d28b(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: AVG_POOL2D, CONV2D, CONV3D, DEPTHWISE_CONV2D, MAX_POOL2D, TRANSPOSE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(stride_x <= MAX_STRIDE)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_2n3xkkz3ip4mz(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: AVG_POOL2D, CONV2D, CONV3D, DEPTHWISE_CONV2D, MAX_POOL2D,
    static constexpr char constraint[] = "LEVEL_CHECK(pad_top <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_3o7qpmmd9ga58(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: AVG_POOL2D, CONV2D, CONV3D, DEPTHWISE_CONV2D, MAX_POOL2D,
    static constexpr char constraint[] = "LEVEL_CHECK(pad_bottom <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_16lxbjk2bszcz(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: AVG_POOL2D, CONV2D, CONV3D, DEPTHWISE_CONV2D, MAX_POOL2D,
    static constexpr char constraint[] = "LEVEL_CHECK(pad_left <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_2kwfb08mbiwpg(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: AVG_POOL2D, CONV2D, CONV3D, DEPTHWISE_CONV2D, MAX_POOL2D,
    static constexpr char constraint[] = "LEVEL_CHECK(pad_right <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1l00wczs5w70i(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CONV2D, CONV3D, DEPTHWISE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(dilation_y * KH <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1hle41fus7cpl(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CONV2D, CONV3D, DEPTHWISE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(dilation_x * KW <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1npkwxnbypn8z(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CONV3D,
    static constexpr char constraint[] = "LEVEL_CHECK(dilation_d * KD <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_olu6vs8y9f61(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CONV3D,
    static constexpr char constraint[] = "LEVEL_CHECK(pad_d0 <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_3l4no1w1u6sq4(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CONV3D,
    static constexpr char constraint[] = "LEVEL_CHECK(pad_d1 <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1416gon2u3sue(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CONV3D,
    static constexpr char constraint[] = "LEVEL_CHECK(stride_d <= MAX_STRIDE)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1wd03gtw7132o(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: FFT2D, RFFT2D,
    static constexpr char constraint[] = "LEVEL_CHECK(H <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_i8zuc5feuxbr(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: FFT2D, RFFT2D,
    static constexpr char constraint[] = "LEVEL_CHECK(W <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_17eyg1nicy12g(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: TRANSPOSE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(KH <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_6qao6e1mxke0(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: TRANSPOSE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(KW <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_pnaf5n03f8jg(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: TRANSPOSE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(out_pad_top <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_me421i5r5j13(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: TRANSPOSE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(out_pad_bottom <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_2ffhdgbz1kvxc(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: TRANSPOSE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(out_pad_left <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_a0x2apl3zoz(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: TRANSPOSE_CONV2D,
    static constexpr char constraint[] = "LEVEL_CHECK(out_pad_right <= MAX_KERNEL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1flzmpv6hubzc(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CLAMP, ERF, SIGMOID, TANH, ADD, ARITHMETIC_RIGHT_SHIFT, BITWISE_AND, BITWISE_OR, BITWISE_XOR, INTDIV,
    //  LOGICAL_AND, LOGICAL_LEFT_SHIFT, LOGICAL_RIGHT_SHIFT, LOGICAL_OR, LOGICAL_XOR, MAXIMUM, MINIMUM, MUL, POW, SUB,
    //  TABLE, ABS, BITWISE_NOT, CEIL, CLZ, COS, EXP, FLOOR, LOG, LOGICAL_NOT, NEGATE, RECIPROCAL, RSQRT, SIN, SELECT,
    //  EQUAL, GREATER, GREATER_EQUAL, CONCAT, PAD, RESHAPE, REVERSE, SLICE, TILE, TRANSPOSE, CAST, RESCALE, COND_IF,
    //  VARIABLE, VARIABLE_WRITE, VARIABLE_READ,
    static constexpr char constraint[] = "LEVEL_CHECK(rank(shape) <= MAX_RANK)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_3tcyujqdy8gol(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CONCAT,
    static constexpr char constraint[] = "LEVEL_CHECK(tensor_list_shape(input1) <= MAX_TENSOR_LIST_SIZE)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1r40jc4ashh6o(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: RESIZE,
    static constexpr char constraint[] = "LEVEL_CHECK(scale_y_n/scale_y_d <= MAX_SCALE)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_1u7rtl141felu(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: RESIZE,
    static constexpr char constraint[] = "LEVEL_CHECK(scale_x_n/scale_x_d <= MAX_SCALE)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_3ufj7d9b3dpok(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CUSTOM, COND_IF, WHILE_LOOP,
    static constexpr char constraint[] = "LEVEL_CHECK(tensor_list_shape(input_list) <= MAX_TENSOR_LIST_SIZE)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void LevelCheck_2b1mift7kqw7v(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: CUSTOM, COND_IF, WHILE_LOOP,
    static constexpr char constraint[] = "LEVEL_CHECK(tensor_list_shape(output_list) <= MAX_TENSOR_LIST_SIZE)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

}  // namespace checks
}  // namespace validator
}  // namespace tosa
