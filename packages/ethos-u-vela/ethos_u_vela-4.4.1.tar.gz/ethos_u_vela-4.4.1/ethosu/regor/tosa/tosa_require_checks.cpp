//
// SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the License); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an AS IS BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Partially generated by tosaValidationGenerator for TOSA Specification 1.0.0draft
// TODO: Implement the constraints.

#include "tosa_require_checks.hpp"

namespace tosa
{
namespace validator
{
namespace checks
{
// Checks for TOSA Specification 1.0.0draft
void RequireCheck_3gogyrefl20gp(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: ARITHMETIC_RIGHT_SHIFT, LOGICAL_LEFT_SHIFT, LOGICAL_RIGHT_SHIFT,
    static constexpr char constraint[] = "REQUIRE((is_same<in_out_t,i32_t>() && 0 <= value2 && value2 <= 31) || (is_same<in_out_t,i16_t>() && 0 <= value2 && value2 <= 15) || (is_same<in_out_t,i8_t>() && 0 <= value2 && value2 <= 7))";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_35z4hcgn21c8p(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: INTDIV,
    static constexpr char constraint[] = "REQUIRE(value2 != 0)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_2f51h19mqfhr8(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: MUL,
    static constexpr char constraint[] = "REQUIRE(0 <= shift && shift <= 63)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_3jqx5d6a2c85r(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: MUL,
    static constexpr char constraint[] = "REQUIRE(is_same<in_t,int32_t>() || shift == 0)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_1b64l72fvni7o(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: MUL,
    static constexpr char constraint[] = "REQUIRE(product >= minimum_s<i32_t>() && product <= maximum_s<i32_t>())";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_3otz8rylb4eh1(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: POW,
    static constexpr char constraint[] = "REQUIRE(value1 >= 0)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_2p74g4god707n(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: POW,
    static constexpr char constraint[] = "REQUIRE(value1 > 0 || value2 > 0)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_61j2lms4vo0v(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: POW,
    static constexpr char constraint[] = "REQUIRE(!isNaN(value1) && !isNaN(value2))";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_3nkub9jwwaf4h(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: POW,
    static constexpr char constraint[] = "REQUIRE(is_finite(value1) && is_finite(value2))";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_3o6eotvyt76cz(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: TABLE,
    static constexpr char constraint[] = "REQUIRE(length(table) == TABLE_SIZE)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_31n0oq4yculbk(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: GATHER, SCATTER,
    static constexpr char constraint[] = "REQUIRE(0 <= k && k < K)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_2apk8ly9uthz6(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: SCATTER,
    static constexpr char constraint[] = "REQUIRE(output_modified[n,k,c] == false)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_3ah9e1mnk126p(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE,
    static constexpr char constraint[] = "REQUIRE(var_t == in_t)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_2e13btqfr98am(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE,
    static constexpr char constraint[] = "REQUIRE(var_shape == shape)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_lt5trq6bbw9w(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE,
    static constexpr char constraint[] = "REQUIRE(!var_tensor.seen)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_1nuiu459z8num(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE_WRITE,
    static constexpr char constraint[] = "REQUIRE(variable_tensor)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_182ljbxwn59zs(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE_WRITE,
    static constexpr char constraint[] = "REQUIRE(variable_tensor.seen)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_2pd0619ns6vtd(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE_WRITE, VARIABLE_READ,
    static constexpr char constraint[] = "REQUIRE(variable_tensor.shape == shape)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_12cwj1gynxopa(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE_WRITE,
    static constexpr char constraint[] = "REQUIRE(is_same<variable_tensor.type,in_t>())";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_7uvvy4pqp2pj(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE_READ,
    static constexpr char constraint[] = "REQUIRE(variable_tensor != NULL)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_2wyo0jz6whe2p(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE_READ,
    static constexpr char constraint[] = "REQUIRE(variable_tensor.is_written)";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

void RequireCheck_2btzv7wkv70o0(const regor::Operation *op, [[maybe_unused]] const Context &context)
{
    // Operators: VARIABLE_READ,
    static constexpr char constraint[] = "REQUIRE(is_same<variable_tensor.type,out_t>())";
    bool checkOk = true;
    checkOk = (op != nullptr);  // TODO: Implement check
    if ( !checkOk ) throw std::invalid_argument(constraint);
}

}  // namespace checks
}  // namespace validator
}  // namespace tosa
