//
// SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the License); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an AS IS BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Automatically generated by tosaValidationGenerator for TOSA Specification 1.0.0draft
// Do not edit.

#include "compiler/operation.hpp"
#include "tosa/tosa_argument_checks.hpp"
#include "tosa/tosa_error_checks.hpp"
#include "tosa/tosa_level_checks.hpp"
#include "tosa/tosa_require_checks.hpp"
#include "tosa/tosa_validator.hpp"
using namespace tosa::validator;

using namespace tosa::validator::checks;

#define MAX_RANK (context.level == Level::Level8K ? 6 : (context.level == Level::Levelnone ? 32 : 0))

#define MAX_KERNEL (context.level == Level::Level8K ? 8192 : (context.level == Level::Levelnone ? 2147483647 : 0))

#define MAX_SCALE (context.level == Level::Level8K ? 256 : (context.level == Level::Levelnone ? 2048 : 0))

#define MAX_STRIDE (context.level == Level::Level8K ? 8192 : (context.level == Level::Levelnone ? 2147483647 : 0))

namespace
{
void ValidateOperator_ARGMAX(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "i32_t",
    }; /*Axis in range from 0 to rank(shape1) - 1 shape=-*/
    const Argument nan_mode = {
        Category::Attribute,
        "nan_mode",
        "nan_propagation_mode_t",
    }; /* PROPAGATE or IGNORE. Set to PROPAGATE by default. This attribute affects the floating-point NaN propagation
        approach. This attribute is ignored by non floating-point types. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {0, MAX_RANK - 1}}; /*Output tensor, with rank =
                                                                                         rank(shape1) - 1 shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &nan_mode,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i8_t"},
            {"out_t", "i32_t"},
        },  // signed 8
        {
            {"in_t", "i16_t"},
            {"out_t", "i32_t"},
        },  // signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_gpp861oen43y(op, context);
    LevelCheck_1lz89reckvj8d(op, context);
}

void ValidateOperator_AVG_POOL2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {4, 4}};       /*Input tensor shape=[N,IH,IW,C]*/
    const Argument input_zp = {Category::Input, "input_zp", "in_out_t", {1, 1}}; /*Input tensor zero point. Must be zero
                                                                                    for non-int8 types. shape=[1]*/
    const Argument output_zp = {Category::Input, "output_zp", "in_out_t", {1, 1}}; /*Output tensor zero point. Must be
                                                                                      zero for non-int8 types.
                                                                                      shape=[1]*/
    const Argument kernel = {Category::Attribute, "kernel", "i32_t", {1, 1}};      /*[kernel_y, kernel_x] shape=[2]*/
    const Argument stride = {Category::Attribute, "stride", "i32_t", {1, 1}};      /*[stride_y, stride_x] shape=[2]*/
    const Argument pad = {Category::Attribute, "pad", "i32_t", {1, 1}}; /*[pad_top, pad_bottom, pad_left, pad_right]
                                                                           shape=[4]*/
    const Argument acc_type = {
        Category::Attribute,
        "acc_type",
        "acc_type_t",
    }; /*Enumerated type, must be one of INT32, FP16, FP32 matching the type of acc_t in the Supported Data Types table
        for this operation shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {4, 4}}; /*Output tensor 4D shape=[N,OH,OW,C]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &input_zp,
        &output_zp,
        &kernel,
        &stride,
        &pad,
        &acc_type,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
            {"acc_t", "i32_t"},
        },  // signed 8 with int32 accumulate
        {
            {"in_out_t", "i16_t"},
            {"acc_t", "i32_t"},
        },  // signed 16 with int32 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_2nanft1ivm5fj(op, context);
    ErrorIfCheck_1ga3gcg4zkrkv(op, context);
    ErrorIfCheck_36r4wpx3psd81(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_ojmgqziimenu(op, context);
    ErrorIfCheck_3vqy81ueu5wjk(op, context);
    ErrorIfCheck_125xuezh1964i(op, context);
    ErrorIfCheck_fqta626ku4qe(op, context);
    ErrorIfCheck_ycjhrvf2yigr(op, context);
    ErrorIfCheck_1c57olj698f3d(op, context);
    LevelCheck_2i1ithnrq06wi(op, context);
    LevelCheck_1wobi8axf7z2y(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
}

void ValidateOperator_CONV2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {4, 4}};       /*Input tensor shape=[N,IH,IW,IC]*/
    const Argument weight = {Category::Input, "weight", "weight_t", {4, 4}}; /*Weight kernel size KH x KW
                                                                                shape=[OC,KH,KW,IC]*/
    const Argument bias = {Category::Input, "bias", "out_t", {1, 1}}; /*Per output channel bias data. + Bias data will
                                                                         be broadcast if BC == 1. shape=[BC]*/
    const Argument input_zp = {Category::Input, "input_zp", "in_t", {1, 1}}; /*Input tensor zero point. Must be zero for
                                                                                non-int8 types. shape=[1]*/
    const Argument weight_zp = {Category::Input, "weight_zp", "weight_t", {1, 1}}; /*Weight zero point. Must be zero for
                                                                                      non-int8 types. shape=[1]*/
    const Argument pad = {Category::Attribute, "pad", "i32_t", {1, 1}}; /*[pad_top, pad_bottom, pad_left, pad_right]
                                                                           shape=[4]*/
    const Argument stride = {Category::Attribute, "stride", "i32_t", {1, 1}};     /*[stride_y, stride_x] shape=[2]*/
    const Argument dilation = {Category::Attribute, "dilation", "i32_t", {1, 1}}; /*[dilation_y, dilation_x] shape=[2]*/
    const Argument acc_type = {
        Category::Attribute,
        "acc_type",
        "acc_type_t",
    }; /*Enumerated type, must be one of INT32, INT48, FP16, FP32 matching the type of acc_t in the Supported Data Types
        table for this operation shape=-*/
    const Argument local_bound = {
        Category::Attribute,
        "local_bound",
        "bool_t",
    }; /* This optional attribute affects the floating-point compliance error bound. The default of false allows for
        direct and transform based, fast convolution algorithms. Only set to true if direct dot-product calculation
        precision is required. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {4, 4}}; /*Output tensor shape=[N,OH,OW,OC]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &weight,
        &bias,
        &input_zp,
        &weight_zp,
        &pad,
        &stride,
        &dilation,
        &acc_type,
        &local_bound,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i8_t"},
            {"weight_t", "i8_t"},
            {"out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "i8_t"},
            {"weight_t", "i4_t"},
            {"out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 8x4 with int32 accumulate
        {
            {"in_t", "i16_t"},
            {"weight_t", "i8_t"},
            {"out_t", "i48_t"},
            {"acc_t", "i48_t"},
        },  // signed 16x8 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hrio849y2qnx(op, context);
    ErrorIfCheck_31vgfyg6fi9t6(op, context);
    ErrorIfCheck_ojmgqziimenu(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_3fzsq78v5ypau(op, context);
    ErrorIfCheck_2vhj6e48eyzlr(op, context);
    ErrorIfCheck_147wc580l2tik(op, context);
    ErrorIfCheck_1gr4n0iszdlxr(op, context);
    ErrorIfCheck_2rm8rnsdfn14h(op, context);
    ErrorIfCheck_36emtx7zwkk96(op, context);
    ErrorIfCheck_cr43yjpqkcpd(op, context);
    LevelCheck_1l00wczs5w70i(op, context);
    LevelCheck_1hle41fus7cpl(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
}

void ValidateOperator_CONV3D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {5, 5}};       /*Input tensor shape=[N,ID,IH,IW,IC]*/
    const Argument weight = {Category::Input, "weight", "weight_t", {5, 5}}; /*Weight kernel size KDxKHxKW
                                                                                shape=[OC,KD,KH,KW,IC]*/
    const Argument bias = {Category::Input, "bias", "out_t", {1, 1}}; /*Per output channel bias data. + Bias data will
                                                                         be broadcast if BC == 1. shape=[BC]*/
    const Argument input_zp = {Category::Input, "input_zp", "in_t", {1, 1}}; /*Input tensor zero point. Must be zero for
                                                                                non-int8 types. shape=[1]*/
    const Argument weight_zp = {Category::Input, "weight_zp", "weight_t", {1, 1}}; /*Weight zero point. Must be zero for
                                                                                      non-int8 types. shape=[1]*/
    const Argument pad = {Category::Attribute, "pad", "i32_t", {1, 1}};       /*[pad_d0, pad_d1, pad_top, pad_bottom,
                                                                                 pad_left, pad_right] shape=[6]*/
    const Argument stride = {Category::Attribute, "stride", "i32_t", {1, 1}}; /*[stride_d, stride_y, stride_x]
                                                                                 shape=[3]*/
    const Argument dilation = {Category::Attribute, "dilation", "i32_t", {1, 1}}; /*[dilation_d, dilation_y, dilation_x]
                                                                                     shape=[3]*/
    const Argument acc_type = {
        Category::Attribute,
        "acc_type",
        "acc_type_t",
    }; /*Enumerated type, must be one of INT32, INT48, FP16, FP32 matching the type of acc_t in the Supported Data Types
        table for this operation shape=-*/
    const Argument local_bound = {
        Category::Attribute,
        "local_bound",
        "bool_t",
    }; /* This optional attribute affects the floating-point compliance error bound. The default of false allows for
        direct and transform based, fast convolution algorithms. Only set to true if direct dot-product calculation
        precision is required. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {5, 5}}; /*Output tensor shape=[N,OD,OH,OW,OC]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &weight,
        &bias,
        &input_zp,
        &weight_zp,
        &pad,
        &stride,
        &dilation,
        &acc_type,
        &local_bound,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i8_t"},
            {"weight_t", "i8_t"},
            {"out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "i8_t"},
            {"weight_t", "i4_t"},
            {"out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 8x4 with int32 accumulate
        {
            {"in_t", "i16_t"},
            {"weight_t", "i8_t"},
            {"out_t", "i48_t"},
            {"acc_t", "i48_t"},
        },  // signed 16x8 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hrio849y2qnx(op, context);
    ErrorIfCheck_3m5ijs493bw6j(op, context);
    ErrorIfCheck_341t6ysqc16b2(op, context);
    ErrorIfCheck_uqm570jwaqb6(op, context);
    ErrorIfCheck_34iiwt6o66qfa(op, context);
    ErrorIfCheck_llbd3iugmek0(op, context);
    ErrorIfCheck_2vhj6e48eyzlr(op, context);
    ErrorIfCheck_147wc580l2tik(op, context);
    ErrorIfCheck_1gr4n0iszdlxr(op, context);
    ErrorIfCheck_1w510kxt5b2b2(op, context);
    ErrorIfCheck_27g3t38z1of4h(op, context);
    ErrorIfCheck_2cpco8ykx99sa(op, context);
    LevelCheck_1npkwxnbypn8z(op, context);
    LevelCheck_1l00wczs5w70i(op, context);
    LevelCheck_1hle41fus7cpl(op, context);
    LevelCheck_olu6vs8y9f61(op, context);
    LevelCheck_3l4no1w1u6sq4(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
    LevelCheck_1416gon2u3sue(op, context);
}

void ValidateOperator_DEPTHWISE_CONV2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {4, 4}};       /*Input tensor shape=[N,IH,IW,C]*/
    const Argument weight = {Category::Input, "weight", "weight_t", {4, 4}}; /*Weight kernel size KH x KW
                                                                                shape=[KH,KW,C,M]*/
    const Argument bias = {Category::Input, "bias", "out_t", {1, 1}}; /*Per output channel bias data. + Bias data will
                                                                         be broadcast if BC == 1. shape=[BC]*/
    const Argument input_zp = {Category::Input, "input_zp", "in_t", {1, 1}}; /*Input tensor zero point. Must be zero for
                                                                                non-int8 types. shape=[1]*/
    const Argument weight_zp = {Category::Input, "weight_zp", "weight_t", {1, 1}}; /*Weight zero point. Must be zero for
                                                                                      non-int8 types. shape=[1]*/
    const Argument pad = {Category::Attribute, "pad", "i32_t", {1, 1}}; /*[pad_top, pad_bottom, pad_left, pad_right]
                                                                           shape=[4]*/
    const Argument stride = {Category::Attribute, "stride", "i32_t", {1, 1}};     /*[stride_y, stride_x] shape=[2]*/
    const Argument dilation = {Category::Attribute, "dilation", "i32_t", {1, 1}}; /*[dilation_y, dilation_x] shape=[2]*/
    const Argument acc_type = {
        Category::Attribute,
        "acc_type",
        "acc_type_t",
    }; /*Enumerated type, must be one of INT32, INT48, FP16, FP32 matching the type of acc_t in the Supported Data Types
        table for this operation shape=-*/
    const Argument local_bound = {
        Category::Attribute,
        "local_bound",
        "bool_t",
    }; /* This optional attribute affects the floating-point compliance error bound. The default of false allows for
        direct and transform based, fast convolution algorithms. Only set to true if direct dot-product calculation
        precision is required. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {4, 4}}; /*Output tensor shape=[N,OH,OW,C*M]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &weight,
        &bias,
        &input_zp,
        &weight_zp,
        &pad,
        &stride,
        &dilation,
        &acc_type,
        &local_bound,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i8_t"},
            {"weight_t", "i8_t"},
            {"out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "i8_t"},
            {"weight_t", "i4_t"},
            {"out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 8x4 with int32 accumulate
        {
            {"in_t", "i16_t"},
            {"weight_t", "i8_t"},
            {"out_t", "i48_t"},
            {"acc_t", "i48_t"},
        },  // signed 16x8 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hrio849y2qnx(op, context);
    ErrorIfCheck_3m5ijs493bw6j(op, context);
    ErrorIfCheck_ojmgqziimenu(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_3fzsq78v5ypau(op, context);
    ErrorIfCheck_2vhj6e48eyzlr(op, context);
    ErrorIfCheck_147wc580l2tik(op, context);
    ErrorIfCheck_2d0jmyhr9lscf(op, context);
    ErrorIfCheck_10td4qt70dp3i(op, context);
    ErrorIfCheck_1qxtjwwlh068t(op, context);
    LevelCheck_1l00wczs5w70i(op, context);
    LevelCheck_1hle41fus7cpl(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
}

void ValidateOperator_MATMUL(const regor::Operation *op, const Context &context)
{
    const Argument A = {Category::Input, "A", "in_t", {3, 3}}; /*Input tensor A, N matrices of size HxC shape=[N,H,C]*/
    const Argument B = {Category::Input, "B", "in_t", {3, 3}}; /*Input tensor B, N matrices of size CxW shape=[N,C,W]*/
    const Argument A_zp = {Category::Input, "A_zp", "in_t", {1, 1}};       /*Input tensor A zero point. Must be zero for
                                                                              non-int8 types. shape=[1]*/
    const Argument B_zp = {Category::Input, "B_zp", "in_t", {1, 1}};       /*Input tensor B zero point. Must be zero for
                                                                              non-int8 types. shape=[1]*/
    const Argument output = {Category::Output, "output", "out_t", {3, 3}}; /*Output tensor, N matrices of size HxW
                                                                              shape=[N,H,W]*/
    const std::vector<const Argument *> arguments = {
        &A,
        &B,
        &A_zp,
        &B_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i8_t"},
            {"out_t", "i32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "i16_t"},
            {"out_t", "i48_t"},
        },  // signed 16x16 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_2autvayhidla8(op, context);
    ErrorIfCheck_h1uadv5irsu6(op, context);
    ErrorIfCheck_1kfh97qingywb(op, context);
    ErrorIfCheck_1azcq4511qzyx(op, context);
}

void ValidateOperator_MAX_POOL2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {4, 4}};    /*Input tensor 4D shape=[N,IH,IW,C]*/
    const Argument kernel = {Category::Attribute, "kernel", "i32_t", {1, 1}}; /*[kernel_y, kernel_x] shape=[2]*/
    const Argument stride = {Category::Attribute, "stride", "i32_t", {1, 1}}; /*[stride_y, stride_x] shape=[2]*/
    const Argument pad = {Category::Attribute, "pad", "i32_t", {1, 1}}; /*[pad_top, pad_bottom, pad_left, pad_right]
                                                                           shape=[4]*/
    const Argument nan_mode = {
        Category::Attribute,
        "nan_mode",
        "nan_propagation_mode_t",
    }; /* PROPAGATE or IGNORE. Set to PROPAGATE by default. This attribute affects the floating-point NaN propagation
        approach. This attribute is ignored by non floating-point types. shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {4, 4}}; /*Output tensor 4D shape=[N,OH,OW,C]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &kernel,
        &stride,
        &pad,
        &nan_mode,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_36r4wpx3psd81(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_ojmgqziimenu(op, context);
    ErrorIfCheck_3vqy81ueu5wjk(op, context);
    ErrorIfCheck_125xuezh1964i(op, context);
    ErrorIfCheck_fqta626ku4qe(op, context);
    ErrorIfCheck_ycjhrvf2yigr(op, context);
    ErrorIfCheck_1c57olj698f3d(op, context);
    LevelCheck_2i1ithnrq06wi(op, context);
    LevelCheck_1wobi8axf7z2y(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
}

void ValidateOperator_TRANSPOSE_CONV2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {4, 4}};       /*Input tensor shape=[N,IH,IW,IC]*/
    const Argument weight = {Category::Input, "weight", "weight_t", {4, 4}}; /*Weight kernel size KH x KW
                                                                                shape=[OC,KH,KW,IC]*/
    const Argument bias = {Category::Input, "bias", "out_t", {1, 1}}; /*Per output channel bias data. + Bias data will
                                                                         be broadcast if BC == 1. shape=[BC]*/
    const Argument input_zp = {Category::Input, "input_zp", "in_t", {1, 1}}; /*Input tensor zero point. Must be zero for
                                                                                non-int8 types. shape=[1]*/
    const Argument weight_zp = {Category::Input, "weight_zp", "weight_t", {1, 1}}; /*Weight zero point. Must be zero for
                                                                                      non-int8 types. shape=[1]*/
    const Argument out_pad = {Category::Attribute, "out_pad", "i32_t", {1, 1}};    /*[out_pad_top, out_pad_bottom,
                                                                                      out_pad_left, out_pad_right]
                                                                                      shape=[4]*/
    const Argument stride = {Category::Attribute, "stride", "i32_t", {1, 1}};      /*[stride_y, stride_x] shape=[2]*/
    const Argument acc_type = {
        Category::Attribute,
        "acc_type",
        "acc_type_t",
    }; /*Enumerated type, must be one of INT32, INT48, FP16, FP32 matching the type of acc_t in the Supported Data Types
        table for this operation shape=-*/
    const Argument local_bound = {
        Category::Attribute,
        "local_bound",
        "bool_t",
    }; /* This optional attribute affects the floating-point compliance error bound. The default of false allows for
        direct and transform based, fast convolution algorithms. Only set to true if direct dot-product calculation
        precision is required. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {4, 4}}; /*Output tensor shape=[N,OH,OW,OC]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &weight,
        &bias,
        &input_zp,
        &weight_zp,
        &out_pad,
        &stride,
        &acc_type,
        &local_bound,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i8_t"},
            {"weight_t", "i8_t"},
            {"out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "i8_t"},
            {"weight_t", "i4_t"},
            {"out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 8x4 with int32 accumulate
        {
            {"in_t", "i16_t"},
            {"weight_t", "i8_t"},
            {"out_t", "i48_t"},
            {"acc_t", "i48_t"},
        },  // signed 16x8 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hrio849y2qnx(op, context);
    ErrorIfCheck_3m5ijs493bw6j(op, context);
    ErrorIfCheck_q9dl3x81rc4o(op, context);
    ErrorIfCheck_2rfkujt9lg7eq(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_3nelbnmxyemot(op, context);
    ErrorIfCheck_24conlof4w8eh(op, context);
    ErrorIfCheck_1gr4n0iszdlxr(op, context);
    ErrorIfCheck_2rm8rnsdfn14h(op, context);
    ErrorIfCheck_36emtx7zwkk96(op, context);
    ErrorIfCheck_cr43yjpqkcpd(op, context);
    LevelCheck_17eyg1nicy12g(op, context);
    LevelCheck_6qao6e1mxke0(op, context);
    LevelCheck_pnaf5n03f8jg(op, context);
    LevelCheck_me421i5r5j13(op, context);
    LevelCheck_2ffhdgbz1kvxc(op, context);
    LevelCheck_a0x2apl3zoz(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
}

void ValidateOperator_CLAMP(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape*/
    const Argument min_val = {
        Category::Attribute,
        "min_val",
        "in_out_t",
    }; /*Minimum clip value shape=-*/
    const Argument max_val = {
        Category::Attribute,
        "max_val",
        "in_out_t",
    }; /*Maximum clip value shape=-*/
    const Argument nan_mode = {
        Category::Attribute,
        "nan_mode",
        "nan_propagation_mode_t",
    }; /* PROPAGATE or IGNORE. Set to PROPAGATE by default. This attribute affects the floating-point NaN propagation
        approach. This attribute is ignored by non floating-point types. shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type and
                                                                                        shape as input shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &min_val,
        &max_val,
        &nan_mode,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_xod9coigx1x2(op, context);
    ErrorIfCheck_15y4an3ceern5(op, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_SIGMOID(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {0, MAX_RANK}};    /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type and
                                                                                        shape as input shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_TANH(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {0, MAX_RANK}};    /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type and
                                                                                        shape as input shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_ADD(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_ARITHMETIC_RIGHT_SHIFT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument round = {
        Category::Attribute,
        "round",
        "bool_t",
    }; /*If true then the shift is rounded shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &round,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_3gogyrefl20gp(op, context);
}

void ValidateOperator_BITWISE_AND(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_BITWISE_OR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_BITWISE_XOR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_INTDIV(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_35z4hcgn21c8p(op, context);
}

void ValidateOperator_LOGICAL_AND(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_LOGICAL_LEFT_SHIFT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_3gogyrefl20gp(op, context);
}

void ValidateOperator_LOGICAL_RIGHT_SHIFT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_3gogyrefl20gp(op, context);
}

void ValidateOperator_LOGICAL_OR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_LOGICAL_XOR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_MAXIMUM(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument nan_mode = {
        Category::Attribute,
        "nan_mode",
        "nan_propagation_mode_t",
    }; /* PROPAGATE or IGNORE. Set to PROPAGATE by default. This attribute affects the floating-point NaN propagation
        approach. This attribute is ignored by non floating-point types. shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &nan_mode,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_MINIMUM(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument nan_mode = {
        Category::Attribute,
        "nan_mode",
        "nan_propagation_mode_t",
    }; /* PROPAGATE or IGNORE. Set to PROPAGATE by default. This attribute affects the floating-point NaN propagation
        approach. This attribute is ignored by non floating-point types. shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &nan_mode,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_MUL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                   input1 shape=shape2*/
    const Argument shift = {Category::Input, "shift", "i8_t", {1, 1}}; /*Result right shift (used only when in_t is
                                                                          i32_t) shape=[1]*/
    const Argument output = {Category::Output, "output", "out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &shift,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i8_t"},
            {"out_t", "i32_t"},
        },  // signed 8
        {
            {"in_t", "i16_t"},
            {"out_t", "i32_t"},
        },  // signed 16
        {
            {"in_t", "i32_t"},
            {"out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_2f51h19mqfhr8(op, context);
    RequireCheck_3jqx5d6a2c85r(op, context);
    RequireCheck_1b64l72fvni7o(op, context);
}

void ValidateOperator_POW(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_3otz8rylb4eh1(op, context);
    RequireCheck_2p74g4god707n(op, context);
    RequireCheck_61j2lms4vo0v(op, context);
    RequireCheck_3nkub9jwwaf4h(op, context);
}

void ValidateOperator_SUB(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}}; /*Input tensor with the same rank as
                                                                                       input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_TABLE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_t", {0, MAX_RANK}}; /*Input tensor shape=shape*/
    const Argument table = {Category::Input, "table", "table_t", {1, 1}}; /*Lookup table tensor shape=[TABLE_SIZE]*/
    const Argument output = {Category::Output, "output", "out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &table,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i8_t"},
            {"table_t", "i8_t"},
            {"out_t", "i8_t"},
            {"TABLE_SIZE", "256"},
        },  // signed 8
        {
            {"in_t", "i16_t"},
            {"table_t", "i16_t"},
            {"out_t", "i32_t"},
            {"TABLE_SIZE", "513"},
        },  // signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_3o6eotvyt76cz(op, context);
}

void ValidateOperator_ABS(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_BITWISE_NOT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_CEIL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_CLZ(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_EXP(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_FLOOR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_LOG(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_LOGICAL_NOT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_NEGATE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}}; /*Input tensor shape=shape*/
    const Argument input1_zp = {Category::Input, "input1_zp", "in_out_t", {1, 1}};  /*Input 1 zero point. Must be zero
                                                                                       for non-int8 types. shape=[1]*/
    const Argument output_zp = {Category::Input, "output_zp", "in_out_t", {1, 1}}; /*Output zero point. Must be zero for
                                                                                      non-int8 types. shape=[1]*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input1_zp,
        &output_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
            {"acc_t", "i32_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
            {"acc_t", "i32_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3l2ksvk26m07h(op, context);
    ErrorIfCheck_1ga3gcg4zkrkv(op, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_RECIPROCAL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_RSQRT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_SELECT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "bool_t", {0, MAX_RANK}}; /*Input selector tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_out_t", {0, MAX_RANK}};  /*Input value tensor if input1 is
                                                                                        True shape=shape2*/
    const Argument input3 = {Category::Input, "input3", "in_out_t", {0, MAX_RANK}};  /*Input value tensor if input1 is
                                                                                        False shape=shape3*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type as
                                                                                        input2 and input3 shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &input3,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_192e2vu3t5aqm(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    ErrorIfCheck_3tccsjner0km9(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_EQUAL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_t", {0, MAX_RANK}};   /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_t", {0, MAX_RANK}};   /*Input tensor with the same rank as
                                                                                     input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i32_t"},
            {"out_t", "bool_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_GREATER(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_t", {0, MAX_RANK}};   /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_t", {0, MAX_RANK}};   /*Input tensor with the same rank as
                                                                                     input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i32_t"},
            {"out_t", "bool_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_GREATER_EQUAL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_t", {0, MAX_RANK}};   /*Input tensor shape=shape1*/
    const Argument input2 = {Category::Input, "input2", "in_t", {0, MAX_RANK}};   /*Input tensor with the same rank as
                                                                                     input1 shape=shape2*/
    const Argument output = {Category::Output, "output", "out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i32_t"},
            {"out_t", "bool_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hynqeiugz9lt(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_REDUCE_ALL(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "i32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor. Same rank as the
                                                                                        input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_ANY(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "i32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor. Same rank as the
                                                                                        input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_MAX(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "i32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument nan_mode = {
        Category::Attribute,
        "nan_mode",
        "nan_propagation_mode_t",
    }; /* PROPAGATE or IGNORE. Set to PROPAGATE by default. This attribute affects the floating-point NaN propagation
        approach. This attribute is ignored by non floating-point types. shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor. Same rank as the
                                                                                        input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &nan_mode,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_MIN(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "i32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument nan_mode = {
        Category::Attribute,
        "nan_mode",
        "nan_propagation_mode_t",
    }; /* PROPAGATE or IGNORE. Set to PROPAGATE by default. This attribute affects the floating-point NaN propagation
        approach. This attribute is ignored by non floating-point types. shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor. Same rank as the
                                                                                        input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &nan_mode,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_PRODUCT(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "i32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor. Same rank as the
                                                                                        input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_SUM(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "i32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor. Same rank as the
                                                                                        input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "i32_t"},
            {"acc_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_CONCAT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {1, MAX_RANK}}; /*List of input tensors. All inputs
                                                                                       must have the same rank and data
                                                                                       type shape=shapes1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "i32_t",
    }; /*Axis along which concatenation is to occur, in range from 0 to rank(shape)-1 shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_2d3qdl1f70i6y(op, context);
    ErrorIfCheck_5y7ov1oeymoa(op, context);
    ErrorIfCheck_1aloht2b77zby(op, context);
    ErrorIfCheck_f1kt9a6h7s2p(op, context);
    ErrorIfCheck_302z1f8mq8lg7(op, context);
    LevelCheck_3tcyujqdy8gol(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_PAD(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument padding = {Category::Input, "padding", "shape_t", {1, 1}}; /*Number of pad elements at the start and
                                                                               end of each dimension. The values in
                                                                               padding are interpreted as start, end of
                                                                               each dimension. As an example for rank 2,
                                                                               the values would be interpreted as
                                                                               [start_dim0, end_dim0, start_dim1,
                                                                               end_dim1]. shape=[2*rank(shape1)]*/
    const Argument pad_const = {Category::Input, "pad_const", "in_out_t", {1, 1}};   /*The value to be used as padding.
                                                                                        shape=[1]*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor of same type as the
                                                                                        input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &padding,
        &pad_const,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_14z7y0qe9lwps(op, context);
    ErrorIfCheck_3dvn5k3273lwz(op, context);
    ErrorIfCheck_34zvbtwx1r18j(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_RESHAPE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape1*/
    const Argument shape = {Category::Input, "shape", "shape_t", {1, 1}};            /*shape_t giving the new shape.
                                                                                        shape=[rank(shape)]*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of same type, size
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &shape,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_2a1jpygblc07i(op, context);
    LevelCheck_1lz89reckvj8d(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_REVERSE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "i32_t",
    }; /*Axis to reverse, in range from 0 to rank(shape)-1 shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor. Same shape as
                                                                                        input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3hthyoock2ew5(op, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_SLICE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument start = {Category::Input, "start", "shape_t", {1, 1}}; /*List of integer coordinates, of length equal
                                                                           to the rank of input1. Start coordinate for
                                                                           slicing. shape=[rank(shape1)]*/
    const Argument size = {Category::Input, "size", "shape_t", {1, 1}};   /*List of integer size values, of length equal
                                                                           to the rank of input1. Size of the input to be
                                                                           used.   shape=[rank(shape1)]*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor of same type as the
                                                                                        input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &start,
        &size,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1nifeiq9rvmb8(op, context);
    ErrorIfCheck_21rq6kn6p1yle(op, context);
    ErrorIfCheck_3rghkieqip43o(op, context);
    ErrorIfCheck_1cyv9n59wyyyc(op, context);
    ErrorIfCheck_3oy2tclc6uhsu(op, context);
    ErrorIfCheck_gpp3enlp1ddg(op, context);
    ErrorIfCheck_ix9div4ld46q(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_TILE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument multiples = {Category::Input, "multiples", "shape_t", {1, 1}}; /*Number of times to replicate input1
                                                                                     in each dimension
                                                                                     shape=[rank(shape1)]*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor of same type, rank
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &multiples,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_21rq6kn6p1yle(op, context);
    ErrorIfCheck_3estuseky2gm2(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_TRANSPOSE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {1, MAX_RANK}}; /*Input tensor shape=shape1*/
    const Argument perms = {Category::Attribute, "perms", "i32_t", {1, 1}}; /*List of integers of length equal to the
                                                                             rank of input1. Values must be valid
                                                                             dimensions within shape1, and may not be
                                                                             repeated. shape=[rank(shape1)]*/
    const Argument output = {Category::Output, "output", "in_out_t", {1, MAX_RANK}}; /*Output tensor of same type, rank
                                                                                        as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &perms,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_21rq6kn6p1yle(op, context);
    ErrorIfCheck_2a1jpygblc07i(op, context);
    ErrorIfCheck_5bq1fx1llv8(op, context);
    ErrorIfCheck_ckwpttzajw06(op, context);
    ErrorIfCheck_2n1ratxgd89tx(op, context);
    ErrorIfCheck_aizwrn95lb0l(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_GATHER(const regor::Operation *op, const Context &context)
{
    const Argument values = {Category::Input, "values", "in_out_t", {3, 3}};  /*3D value tensor shape=[N,K,C]*/
    const Argument indices = {Category::Input, "indices", "index_t", {2, 2}}; /*2D index tensor shape=[N,W]*/
    const Argument output = {Category::Output, "output", "in_out_t", {3, 3}}; /*3D output tensor shape=[N,W,C]*/
    const std::vector<const Argument *> arguments = {
        &values,
        &indices,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"index_t", "i32_t"},
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"index_t", "i32_t"},
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"index_t", "i32_t"},
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_294afuxnedk9i(op, context);
    ErrorIfCheck_27p0n0pjt2bd6(op, context);
    ErrorIfCheck_1uwmsen32dse1(op, context);
    RequireCheck_31n0oq4yculbk(op, context);
}

void ValidateOperator_SCATTER(const regor::Operation *op, const Context &context)
{
    const Argument values_in = {Category::Input, "values_in", "in_out_t", {3, 3}}; /*3D values in tensor shape=[N,K,C]*/
    const Argument indices = {Category::Input, "indices", "index_t", {2, 2}};      /*2D index tensor shape=[N,W]*/
    const Argument input = {Category::Input, "input", "in_out_t", {3, 3}};         /*3D input tensor shape=[N,W,C]*/
    const Argument values_out = {Category::Output, "values_out", "in_out_t", {3, 3}}; /*3D output tensor shape=[N,K,C]*/
    const std::vector<const Argument *> arguments = {
        &values_in,
        &indices,
        &input,
        &values_out,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"index_t", "i32_t"},
            {"in_out_t", "i8_t"},
        },  // signed 8
        {
            {"index_t", "i32_t"},
            {"in_out_t", "i16_t"},
        },  // signed 16
        {
            {"index_t", "i32_t"},
            {"in_out_t", "i32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3c5bq3iswjd1x(op, context);
    ErrorIfCheck_53yuoon46swi(op, context);
    ErrorIfCheck_q9pgbwuvutqu(op, context);
    ErrorIfCheck_1qdcccs22lqtr(op, context);
    ErrorIfCheck_2azl8wc8mbsrj(op, context);
    ErrorIfCheck_122a36k26p0au(op, context);
    RequireCheck_31n0oq4yculbk(op, context);
    RequireCheck_2apk8ly9uthz6(op, context);
}

void ValidateOperator_RESIZE(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {4, 4}};    /*Input tensor shape=[N,IH,IW,C]*/
    const Argument scale = {Category::Input, "scale", "shape_t", {1, 1}}; /*[scale_y_n, scale_y_d, scale_x_n, scale_x_d]
                                                                             shape=[4]*/
    const Argument offset = {Category::Input, "offset", "shape_t", {1, 1}}; /*[offset_y, offset_x] shape=[2]*/
    const Argument border = {Category::Input, "border", "shape_t", {1, 1}}; /*[border_y, border_x] shape=[2]*/
    const Argument mode = {
        Category::Attribute,
        "mode",
        "resize_mode_t",
    };                                                                     /*BILINEAR or NEAREST shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {4, 4}}; /*Output tensor shape=[N,OH,OW,C]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &scale,
        &offset,
        &border,
        &mode,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"resize_t", "i16_t"},
            {"in_t", "i8_t"},
            {"out_t", "i32_t"},
        },  // signed 8, bilinear
        {
            {"resize_t", "i16_t"},
            {"in_t", "i8_t"},
            {"out_t", "i8_t"},
        },  // signed 8, nearest
        {
            {"resize_t", "i16_t"},
            {"in_t", "i16_t"},
            {"out_t", "i48_t"},
        },  // signed 16, bilinear
        {
            {"resize_t", "i16_t"},
            {"in_t", "i16_t"},
            {"out_t", "i16_t"},
        },  // signed 16, nearest
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3sfcy967j2w8w(op, context);
    ErrorIfCheck_1obslcewwn583(op, context);
    ErrorIfCheck_3oxfjen91qb6l(op, context);
    ErrorIfCheck_1uo0z247e42af(op, context);
    ErrorIfCheck_1eovh9pyc6tyw(op, context);
    ErrorIfCheck_24jsin2zkf4ug(op, context);
    ErrorIfCheck_12uj5fltk5rbo(op, context);
    ErrorIfCheck_1py9f91imwjxe(op, context);
    ErrorIfCheck_fn614zzdrdfd(op, context);
    ErrorIfCheck_338aejy0aeqeg(op, context);
    ErrorIfCheck_1c57olj698f3d(op, context);
    LevelCheck_1r40jc4ashh6o(op, context);
    LevelCheck_1u7rtl141felu(op, context);
}

void ValidateOperator_CAST(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {0, MAX_RANK}};     /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "out_t", {0, MAX_RANK}}; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "bool_t"},
            {"out_t", "i8_t"},
        },  // bool to signed 8
        {
            {"in_t", "bool_t"},
            {"out_t", "i16_t"},
        },  // bool to signed 16
        {
            {"in_t", "bool_t"},
            {"out_t", "i32_t"},
        },  // bool to signed 32
        {
            {"in_t", "i8_t"},
            {"out_t", "bool_t"},
        },  // signed 8 to bool
        {
            {"in_t", "i8_t"},
            {"out_t", "i16_t"},
        },  // signed 8 to signed 16
        {
            {"in_t", "i8_t"},
            {"out_t", "i32_t"},
        },  // signed 8 to signed 32
        {
            {"in_t", "i16_t"},
            {"out_t", "bool_t"},
        },  // signed 16 to bool
        {
            {"in_t", "i16_t"},
            {"out_t", "i8_t"},
        },  // signed 16 to signed 8
        {
            {"in_t", "i16_t"},
            {"out_t", "i32_t"},
        },  // signed 16 to signed 32
        {
            {"in_t", "i32_t"},
            {"out_t", "bool_t"},
        },  // signed 32 to bool
        {
            {"in_t", "i32_t"},
            {"out_t", "i8_t"},
        },  // signed 32 to signed 8
        {
            {"in_t", "i32_t"},
            {"out_t", "i16_t"},
        },  // signed 32 to signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_RESCALE(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {0, MAX_RANK}};     /*Input tensor shape=shape*/
    const Argument multiplier = {Category::Input, "multiplier", "mul_t", {1, 1}}; /*Scaling multiplier array
                                                                                     shape=[NC]*/
    const Argument shift = {Category::Input, "shift", "i8_t", {1, 1}};            /*Scaling shift array shape=[NC]*/
    const Argument input_zp = {Category::Input, "input_zp", "in_t", {1, 1}}; /*Input tensor zero point. int8/uint8 can
                                                                              have zero point within their valid range.
                                                                              uint16 zero point must be either 0 or
                                                                              32768. All other types must have zero
                                                                              point equal to 0. shape=[1]*/
    const Argument output_zp = {Category::Input, "output_zp", "out_t", {1, 1}}; /*Output tensor zero point.int8/uint8
                                                                                 can have zero point within their valid
                                                                                 range. uint16 zero point must be either
                                                                                 0 or 32768. All other types must have
                                                                                 zero point equal to 0. shape=[1]*/
    const Argument scale32 = {
        Category::Attribute,
        "scale32",
        "bool_t",
    }; /*if (scale32) mul_t=i32_t else mul_t=i16_t shape=-*/
    const Argument rounding_mode = {
        Category::Attribute,
        "rounding_mode",
        "rounding_mode_t",
    }; /*Select rounding mode shape=-*/
    const Argument per_channel = {
        Category::Attribute,
        "per_channel",
        "bool_t",
    }; /*if (per_channel) NC=shape[rank(shape)-1] else NC=1 shape=-*/
    const Argument input_unsigned = {
        Category::Attribute,
        "input_unsigned",
        "bool_t",
    }; /*If True, treat the input values as unsigned. shape=-*/
    const Argument output_unsigned = {
        Category::Attribute,
        "output_unsigned",
        "bool_t",
    }; /*If True, treat the output values as unsigned. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {0, MAX_RANK}}; /*Output tensor with the same shape as
                                                                                     input shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &multiplier,
        &shift,
        &input_zp,
        &output_zp,
        &scale32,
        &rounding_mode,
        &per_channel,
        &input_unsigned,
        &output_unsigned,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "i8_t"},
            {"out_t", "i8_t"},
        },  // 8-bit to 8-bit
        {
            {"in_t", "i8_t"},
            {"out_t", "i16_t"},
        },  // 8-bit to 16-bit
        {
            {"in_t", "i8_t"},
            {"out_t", "i32_t"},
        },  // 8-bit to 32-bit
        {
            {"in_t", "i16_t"},
            {"out_t", "i8_t"},
        },  // 16-bit to 8-bit
        {
            {"in_t", "i16_t"},
            {"out_t", "i16_t"},
        },  // 16-bit to 16-bit
        {
            {"in_t", "i16_t"},
            {"out_t", "i32_t"},
        },  // 16-bit to 32-bit
        {
            {"in_t", "i32_t"},
            {"out_t", "i8_t"},
        },  // 32-bit to 8-bit
        {
            {"in_t", "i32_t"},
            {"out_t", "i16_t"},
        },  // 32-bit to 16-bit
        {
            {"in_t", "i32_t"},
            {"out_t", "i32_t"},
        },  // 32-bit to 32-bit
        {
            {"in_t", "i48_t"},
            {"out_t", "i8_t"},
        },  // 48-bit to 8-bit
        {
            {"in_t", "i48_t"},
            {"out_t", "i16_t"},
        },  // 48-bit to 16-bit
        {
            {"in_t", "i48_t"},
            {"out_t", "i32_t"},
        },  // 48-bit to 32-bit
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_2a4sjfbd544h5(op, context);
    ErrorIfCheck_32ylwe00j5q2l(op, context);
    ErrorIfCheck_3uwlzew8kfq5w(op, context);
    ErrorIfCheck_1sxf726x838dv(op, context);
    ErrorIfCheck_2fl3he9sci345(op, context);
    ErrorIfCheck_1acxf2776vdap(op, context);
    ErrorIfCheck_2ntycki2dof18(op, context);
    ErrorIfCheck_1yv98jo1xcmke(op, context);
    ErrorIfCheck_bkdiivlz937z(op, context);
    ErrorIfCheck_242iuwska81dr(op, context);
    ErrorIfCheck_2vooovn86b8fd(op, context);
    ErrorIfCheck_107z2k4den74o(op, context);
    ErrorIfCheck_38712gnuluf0u(op, context);
    ErrorIfCheck_4alci0dog4gp(op, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    ErrorIfCheck_31ty7f0kcbfxg(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_CONST(const regor::Operation *op, const Context &context)
{
    const Argument values = {Category::Attribute, "values", "out_t", {0, MAX_RANK}}; /*Constant values shape=shape*/
    const Argument output = {Category::Output, "output", "out_t", {0, MAX_RANK}};    /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &values,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"out_t", "bool_t"},
        },  // Boolean
        {
            {"out_t", "i4_t"},
        },  // 4-bit
        {
            {"out_t", "i8_t"},
        },  // 8-bit
        {
            {"out_t", "i16_t"},
        },  // 16-bit
        {
            {"out_t", "i32_t"},
        },  // 32-bit
        {
            {"out_t", "i48_t"},
        },  // 48-bit
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3oet4aggtv528(op, context);
}

void ValidateOperator_IDENTITY(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {Category::Input, "input1", "in_out_t", {0, MAX_RANK}};  /*Input tensor shape=shape*/
    const Argument output = {Category::Output, "output", "in_out_t", {0, MAX_RANK}}; /*Output tensor of the same type,
                                                                                        size as the input tensor
                                                                                        shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "i4_t"},
        },  // 4-bit
        {
            {"in_out_t", "i8_t"},
        },  // 8-bit
        {
            {"in_out_t", "i16_t"},
        },  // 16-bit
        {
            {"in_out_t", "i32_t"},
        },  // 32-bit
        {
            {"in_out_t", "i48_t"},
        },  // 48-bit
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
}

void ValidateOperator_CUSTOM(const regor::Operation *op, const Context &context)
{
    const Argument input_list = {
        Category::Input,
        "input_list",
        "tensor_list_t",
    }; /*List of input tensors shape=-*/
    const Argument operator_name = {
        Category::Attribute,
        "operator_name",
        "String",
    }; /*String which tells the backend which custom operator is being called shape=-*/
    const Argument domain_name = {
        Category::Attribute,
        "domain_name",
        "String",
    }; /*String identifier which can help avoid name collisions on the operator field. Different implementations of a
        given operator would be in different domains. Implementations can choose which domains they want to support.
        shape=-*/
    const Argument implementation_attrs = {
        Category::Attribute,
        "implementation_attrs",
        "String",
    }; /*String value containing implementation specific attributes which apply to the operation shape=-*/
    const Argument output_list = {
        Category::Output,
        "output_list",
        "tensor_list_t",
    }; /*List of output tensors shape=-*/
    const std::vector<const Argument *> arguments = {
        &input_list,
        &operator_name,
        &domain_name,
        &implementation_attrs,
        &output_list,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    LevelCheck_3ufj7d9b3dpok(op, context);
    LevelCheck_2b1mift7kqw7v(op, context);
}

void ValidateOperator_COND_IF(const regor::Operation *op, const Context &context)
{
    const Argument condition = {Category::Input, "condition", "bool_t", {0, MAX_RANK}}; /*Input condition as a size 1
                                                                                           tensor shape=shape*/
    const Argument input_list = {
        Category::Input,
        "input_list",
        "tensor_list_t",
    }; /*List of input tensors shape=-*/
    const Argument then_graph = {
        Category::Attribute,
        "then_graph",
        "tosa_graph_t",
    }; /*TOSA graph to execute if condition is true shape=-*/
    const Argument else_graph = {
        Category::Attribute,
        "else_graph",
        "tosa_graph_t",
    }; /*TOSA graph to execute if condition is false shape=-*/
    const Argument output_list = {
        Category::Output,
        "output_list",
        "tensor_list_t",
    }; /*List of output tensors shape=-*/
    const std::vector<const Argument *> arguments = {
        &condition,
        &input_list,
        &then_graph,
        &else_graph,
        &output_list,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_15kl5g5u1jrhq(op, context);
    ErrorIfCheck_1bm39avugkqqd(op, context);
    ErrorIfCheck_3tv3oatlz37e2(op, context);
    ErrorIfCheck_n7biu53x2n6k(op, context);
    ErrorIfCheck_2fd4dk1zw032u(op, context);
    ErrorIfCheck_omgw2xdm6irr(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    LevelCheck_3ufj7d9b3dpok(op, context);
    LevelCheck_2b1mift7kqw7v(op, context);
}

void ValidateOperator_WHILE_LOOP(const regor::Operation *op, const Context &context)
{
    const Argument input_list = {
        Category::Input,
        "input_list",
        "tensor_list_t",
    }; /*List of input tensors shape=-*/
    const Argument cond_graph = {
        Category::Attribute,
        "cond_graph",
        "tosa_graph_t",
    }; /*TOSA graph to evaluate the condition shape=-*/
    const Argument body_graph = {
        Category::Attribute,
        "body_graph",
        "tosa_graph_t",
    }; /*TOSA graph to execute the loop body shape=-*/
    const Argument output_list = {
        Category::Output,
        "output_list",
        "tensor_list_t",
    }; /*List of output tensors shape=-*/
    const std::vector<const Argument *> arguments = {
        &input_list,
        &cond_graph,
        &body_graph,
        &output_list,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_15kl5g5u1jrhq(op, context);
    ErrorIfCheck_2jyu87hs8upt4(op, context);
    ErrorIfCheck_12uu5ff3t3lv8(op, context);
    ErrorIfCheck_3puzf7van5acf(op, context);
    ErrorIfCheck_8tihij7a5ep0(op, context);
    ErrorIfCheck_3lu68v2531bjz(op, context);
    ErrorIfCheck_1fzl0zyxyd88z(op, context);
    LevelCheck_3ufj7d9b3dpok(op, context);
    LevelCheck_2b1mift7kqw7v(op, context);
}

}  // namespace
namespace tosa
{
namespace validator
{

void ValidateOperator_Version_1_0_0_draft_Profile_PRO_INT(const GraphApi::GraphOperation *graphOp, const Context &context)
{
    const auto *op = static_cast<const regor::Operation *>(graphOp);
    switch ( op->Type() )
    {
        case regor::OpType::ArgMax:
            ValidateOperator_ARGMAX(op, context);
            break;
        case regor::OpType::AvgPool:
            ValidateOperator_AVG_POOL2D(op, context);
            break;
        case regor::OpType::Conv2D:
            ValidateOperator_CONV2D(op, context);
            break;
        case regor::OpType::Conv3D:
            ValidateOperator_CONV3D(op, context);
            break;
        case regor::OpType::DepthwiseConv2D:
            ValidateOperator_DEPTHWISE_CONV2D(op, context);
            break;
        case regor::OpType::MatMul:
            ValidateOperator_MATMUL(op, context);
            break;
        case regor::OpType::MaxPool:
            ValidateOperator_MAX_POOL2D(op, context);
            break;
        case regor::OpType::TransposeConv2D:
            ValidateOperator_TRANSPOSE_CONV2D(op, context);
            break;
        case regor::OpType::Clamp:
            ValidateOperator_CLAMP(op, context);
            break;
        case regor::OpType::Sigmoid:
            ValidateOperator_SIGMOID(op, context);
            break;
        case regor::OpType::Tanh:
            ValidateOperator_TANH(op, context);
            break;
        case regor::OpType::Add:
            ValidateOperator_ADD(op, context);
            break;
        case regor::OpType::Asr:
            ValidateOperator_ARITHMETIC_RIGHT_SHIFT(op, context);
            break;
        case regor::OpType::And:
            ValidateOperator_BITWISE_AND(op, context);
            break;
        case regor::OpType::Or:
            ValidateOperator_BITWISE_OR(op, context);
            break;
        case regor::OpType::Xor:
            ValidateOperator_BITWISE_XOR(op, context);
            break;
        case regor::OpType::Div:
            ValidateOperator_INTDIV(op, context);
            break;
        case regor::OpType::LogicalAnd:
            ValidateOperator_LOGICAL_AND(op, context);
            break;
        case regor::OpType::SHL:
            ValidateOperator_LOGICAL_LEFT_SHIFT(op, context);
            break;
        case regor::OpType::SHR:
            ValidateOperator_LOGICAL_RIGHT_SHIFT(op, context);
            break;
        case regor::OpType::LogicalOr:
            ValidateOperator_LOGICAL_OR(op, context);
            break;
        case regor::OpType::LogicalXor:
            ValidateOperator_LOGICAL_XOR(op, context);
            break;
        case regor::OpType::Maximum:
            ValidateOperator_MAXIMUM(op, context);
            break;
        case regor::OpType::Minimum:
            ValidateOperator_MINIMUM(op, context);
            break;
        case regor::OpType::Mul:
            ValidateOperator_MUL(op, context);
            break;
        case regor::OpType::Pow:
            ValidateOperator_POW(op, context);
            break;
        case regor::OpType::Sub:
            ValidateOperator_SUB(op, context);
            break;
        case regor::OpType::Table:
            ValidateOperator_TABLE(op, context);
            break;
        case regor::OpType::Abs:
            ValidateOperator_ABS(op, context);
            break;
        case regor::OpType::Not:
            ValidateOperator_BITWISE_NOT(op, context);
            break;
        case regor::OpType::Ceil:
            ValidateOperator_CEIL(op, context);
            break;
        case regor::OpType::CLZ:
            ValidateOperator_CLZ(op, context);
            break;
        case regor::OpType::Exp:
            ValidateOperator_EXP(op, context);
            break;
        case regor::OpType::Floor:
            ValidateOperator_FLOOR(op, context);
            break;
        case regor::OpType::Log:
            ValidateOperator_LOG(op, context);
            break;
        case regor::OpType::LogicalNot:
            ValidateOperator_LOGICAL_NOT(op, context);
            break;
        case regor::OpType::Neg:
            ValidateOperator_NEGATE(op, context);
            break;
        case regor::OpType::Reciprocal:
            ValidateOperator_RECIPROCAL(op, context);
            break;
        case regor::OpType::Rsqrt:
            ValidateOperator_RSQRT(op, context);
            break;
        case regor::OpType::Select:
            ValidateOperator_SELECT(op, context);
            break;
        case regor::OpType::Equal:
            ValidateOperator_EQUAL(op, context);
            break;
        case regor::OpType::Greater:
            ValidateOperator_GREATER(op, context);
            break;
        case regor::OpType::GreaterEqual:
            ValidateOperator_GREATER_EQUAL(op, context);
            break;
        case regor::OpType::ReduceAll:
            ValidateOperator_REDUCE_ALL(op, context);
            break;
        case regor::OpType::ReduceAny:
            ValidateOperator_REDUCE_ANY(op, context);
            break;
        case regor::OpType::ReduceMax:
            ValidateOperator_REDUCE_MAX(op, context);
            break;
        case regor::OpType::ReduceMin:
            ValidateOperator_REDUCE_MIN(op, context);
            break;
        case regor::OpType::ReduceProduct:
            ValidateOperator_REDUCE_PRODUCT(op, context);
            break;
        case regor::OpType::ReduceSum:
            ValidateOperator_REDUCE_SUM(op, context);
            break;
        case regor::OpType::Concat:
            ValidateOperator_CONCAT(op, context);
            break;
        case regor::OpType::Pad:
            ValidateOperator_PAD(op, context);
            break;
        case regor::OpType::Reshape:
            ValidateOperator_RESHAPE(op, context);
            break;
        case regor::OpType::Reverse:
            ValidateOperator_REVERSE(op, context);
            break;
        case regor::OpType::Slice:
            ValidateOperator_SLICE(op, context);
            break;
        case regor::OpType::Tile:
            ValidateOperator_TILE(op, context);
            break;
        case regor::OpType::Transpose:
            ValidateOperator_TRANSPOSE(op, context);
            break;
        case regor::OpType::Gather:
            ValidateOperator_GATHER(op, context);
            break;
        case regor::OpType::Scatter:
            ValidateOperator_SCATTER(op, context);
            break;
        case regor::OpType::Resize:
            ValidateOperator_RESIZE(op, context);
            break;
        case regor::OpType::Cast:
            ValidateOperator_CAST(op, context);
            break;
        case regor::OpType::Rescale:
            ValidateOperator_RESCALE(op, context);
            break;
        case regor::OpType::Const:
            ValidateOperator_CONST(op, context);
            break;
        case regor::OpType::Identity:
            ValidateOperator_IDENTITY(op, context);
            break;
        case regor::OpType::Custom:
            ValidateOperator_CUSTOM(op, context);
            break;
        case regor::OpType::If:
            ValidateOperator_COND_IF(op, context);
            break;
        case regor::OpType::While:
            ValidateOperator_WHILE_LOOP(op, context);
            break;
        default:
            throw std::invalid_argument("Unsupported operator");
    }
}

}  // namespace validator
}  // namespace tosa
