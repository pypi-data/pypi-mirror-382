"""
This module dynamically creates and manages unittest classes for testing
various image preprocessing steps. Each class inherits from `TestSingleStep`.

It utilizes dynamic class creation in Python to generate test cases for
different preprocessing steps. Some tests can be skipped based on
configuration flags.

Key Components
--------------
ENABLE_VISUAL_INSPECTION : bool
    A flag to enable or disable tests requiring visual inspection of images.
steps_data : list of tuple
    A collection of tuples (step_class, arguments,
    visual_inspection_always_disable), representing the different image
    preprocessing steps and their parameters.
DynamicTestStep
    A class that dynamically generates test cases for specific image
    preprocessing steps.

Notes
-----
This module accommodates variations in preprocessing steps, recognizing
that not all test cases in `TestSingleStep` are universally applicable.
Some steps may require customized modifications to standard test cases.
"""


import re
import unittest
from unittest import skip

import imlresearch.src.preprocessing.steps as steps
from imlresearch.src.preprocessing.tests.for_steps.single_step_test import (
    TestSingleStep,
)

ENABLE_VISUAL_INSPECTION = True


def create_test_class_for_step(
    step_class, arguments, visual_inspection_always_disable=False
):
    """
    Dynamically creates a test class for a given preprocessing step.

    This function generates a unittest class that tests the provided
    preprocessing step, verifying its execution and the effect on the image.

    Parameters
    ----------
    step_class : class
        The preprocessing step class to test.
    arguments : dict
        The arguments to initialize the preprocessing step.
    visual_inspection_always_disable : bool, optional
        Flag to always disable visual inspection tests, by default False

    Returns
    -------
    type
        A dynamically created test class.
    """

    class DynamicTestStep(TestSingleStep):
        TestStep = step_class
        parameters = arguments

        if visual_inspection_always_disable or not ENABLE_VISUAL_INSPECTION:

            @skip("Visual inspection not enabled")
            def test_processed_image_visualization(self):
                """
                Skips the visualization test if visual inspection is
                disabled.
                """
                pass

        if isinstance(step_class(), steps.DilateErodeSequencer):

            def test_generate_dilation_and_erosion_sequence(self):
                """
                Tests the erosion probability accuracy in sequences generated
                by the DilateErodeSequencer.

                This test calculates the proportion of erosion operations in
                a long sequence generated by the DilateErodeSequencer. It
                compares this proportion to the expected erosion probability.
                """
                iterations = 1000  # Large number for statistical significance
                erosion_probability = 0.8
                result_sequence = step_class(**arguments).generate_sequence(
                    "", iterations, erosion_probability
                )
                erosion_count = len(re.findall(r"e", result_sequence))
                # Check if erosion count is approximately 80% of the sequence
                self.assertAlmostEqual(
                    erosion_count / iterations, erosion_probability, delta=0.1
                )

        if isinstance(step_class(), steps.TypeCaster):

            @skip("No value or shape changes are expected in Type Casting.")
            def test_process_execution(self):
                """ Skips test as no value or shape changes are expected. """
                pass

        if isinstance(step_class(), steps.DummyStep):

            @skip("No value or shape changes are expected in Dummy Step.")
            def test_process_execution(self):
                """ Skips test as no value or shape changes are expected. """
                pass

    name = step_class.name.replace(" ", "")
    DynamicTestStep.__name__ = f"Test{name}"

    return DynamicTestStep


steps_data = [
    (steps.AdaptiveHistogramEqualizer,
        {"clip_limit": 1.0, "tile_gridsize": (5, 5)}),
    (steps.GlobalHistogramEqualizer, {}),
    (steps.GaussianBlurFilter, {"kernel_size": (5, 5), "sigma": 2.0}),
    (steps.MedianBlurFilter, {"kernel_size": 5}),
    (steps.BilateralFilter,
        {"diameter": 9, "sigma_color": 75, "sigma_space": 75}),
    (steps.AverageBlurFilter, {"kernel_size": (8, 8)}),
    (steps.BinaryThresholder, {"thresh": 128, "max_val": 255}),
    (steps.OstuThresholder, {"thresh": 0, "max_val": 255}),
    (steps.AdaptiveThresholder, {"block_size": 15, "c": -2, "max_val": 255}),
    (steps.TruncatedThresholder, {"thresh": 128, "max_val": 255}),
    (steps.ZeroThreshold, {"thresh": 128, "max_val": 255}),
    (steps.ErosionFilter, {"kernel_size": 3, "iterations": 1}),
    (steps.DilationFilter, {"kernel_size": 3, "iterations": 1}),
    (steps.DilateErodeSequencer, {"kernel_size": 5, "sequence": "ded"}),
    (steps.TypeCaster, {"output_dtype": "float16"}, True),
    (steps.MinMaxNormalizer, {}, True),
    (steps.StandardNormalizer, {}, True),
    (steps.MeanNormalizer, {}, True),
    (
        steps.LocalContrastNormalizer,
        {"depth_radius": 5, "bias": 1.0, "alpha": 0.0001, "beta": 0.75},
        True,
    ),
    (steps.ReverseScaler, {"scale_factor": 255}, True),
    (steps.Mirrorer, {"mirror_direction": "horizontal"}),
    (steps.Rotator, {"angle": 180}),
    (steps.DummyStep, {}),
    (steps.Clipper, {"min_value": 0.0, "max_value": 1.0}),
]


def load_multiple_steps_tests():
    """
    Dynamically loads and aggregates test suites for multiple image
    preprocessing steps into a unified test suite.

    This function iterates over a predefined list of image preprocessing steps
    and their corresponding arguments. For each step, it dynamically creates a
    test class using `create_test_class_for_step` and loads the test cases.

    Returns
    -------
    unittest.TestSuite
        A combined test suite aggregating tests for multiple preprocessing
        step test classes.
    """
    test_suites = []
    loader = unittest.TestLoader()
    for step_data in steps_data:
        test_class = create_test_class_for_step(*step_data)
        test_suites.append(loader.loadTestsFromTestCase(test_class))
    test_suite = unittest.TestSuite(test_suites)  # Combine the suites

    return test_suite

if __name__ == "__main__":
    """ Main execution block for running the loaded test suite. """
    runner = unittest.TextTestRunner()
    runner.run(load_multiple_steps_tests())
