\chapter{KTH Forms}

We want to access data from forms in KTH Forms.
For example, Restlabb records student results in KTH Forms.
It would be nice to easily extract those data.
Forms can export data in CSV format, this can easily be printed to stdout in 
the terminal for further processing.

In the long run we'd like to be able to list all the forms a user has access 
to, and use the actual names of the forms.
We also want to add shortcut names to the different forms for easy access.
For now, we simply add each form manually as such; and then print the contents 
of the desired form.


\section{Code overview}

This is an independent module in the [[kthutils]] package: [[kthutils.forms]].
It resides in the [[forms.py]] file.
Since we use [[typer]] we add one function per command as well as option and 
argument definitions for each command.
<<forms.py>>=
import typer
try:
  from typing import Annotated, Any, List, Tuple, Dict
except ImportError:
  from typing_extensions import Annotated, Any, List, Tuple, Dict

<<imports>>
<<constants>>
<<functions>>

cli = typer.Typer(name="forms", help="Access KTH Forms")

<<API for KTH Forms>>

<<option and argument definitions>>
<<command definitions>>

def main():
  cli()

if __name__ == "__main__":
  main()
@

\subsection{Tests}

We add tests for the module in the [[test_forms.py]] file.
<<test forms.py>>=
import pytest
import kthutils.forms
<<test imports>>

<<test setup>>

<<test functions>>
@

To make life easier writing tests, we'll add [[config]] as a shorthand for the 
[[typerconf]] instance of the module.
<<test setup>>=
config = kthutils.forms.typerconf
@

To make the tests independent, we'll adjust the filenames used by [[typerconf]] 
in [[kthutils.forms]].
The simplest solution would have been to replace [[typerconf]] by 
[[typerconf.Config()]].
However, some commands actually need the [[dirs]] attribute, which we won't get 
in that case.
So we'll modify the [[typerconf.dirs]] attribute instead and replace the ones 
we use by temporary directories instead.
This way recurrent tests will not interfere with each other.
<<test setup>>=
class FakeAppDirs:
  def __init__(self):
    self.tmpdir_data = tempfile.TemporaryDirectory()
    self.user_data_dir = pathlib.Path(self.tmpdir_data.name)
    self.tmpdir_config = tempfile.TemporaryDirectory()
    self.user_config_dir = pathlib.Path(self.tmpdir_config.name)

config.dirs = FakeAppDirs()
<<test imports>>=
import pathlib
import tempfile
@

We also want to use Typer's runner to test running the commands, not just the 
functions.
<<test setup>>=
runner = typer.testing.CliRunner()
forms_cli = kthutils.forms.cli
<<test imports>>=
import typer.testing
@


\section{Adding forms}

We add forms manually for now.
So we add a command for adding a form.
<<add command doc>>=
Adds a form to the configuration
<<command definitions>>=
@cli.command(name="add")
def cli_add_form(<<args for add command>>):
  """
  <<add command doc>>
  """
  <<add the form>>
@

We want to add the each form to a dictionary in the configuration:
a name and a URL.
<<args for add command>>=
name: Annotated[FormName, form_name_arg],
url: Annotated[str, form_url_arg]
@

The form name must not contain any periods (dots), due to how the config system 
of [[typerconf]] works.
Consequently, we add a custom parser for the form name which rejects any names 
containing periods by raising a [[typer.BadParameter]] exception.

Since we inherit from [[str]] we must use the [[__new__]] method to create the 
instance.
We can't use [[__init__]] since [[str]] is immutable, and [[__init__]] is 
called after the instance is created.
(It follows that [[__new__]] is a class method, not an instance method.)
<<option and argument definitions>>=
class FormName(str):
  def __new__(cls, value):
    if "." in value:
      raise typer.BadParameter("Name cannot contain '.'")
    return super().__new__(cls, value)

form_name_arg = typer.Argument(help="Name of the form",
                               parser=FormName,
                               autocompletion=get_added_forms)
form_url_arg = typer.Argument(help="URL to the form. This can be any public "
                                   "URL that results in a CSV file. But it "
                                   "automatically logs in for KTH Forms.")
<<imports>>=
import typerconf
<<constants>>=
CONFIG_ADDED_FORMS = "forms.added_forms"
<<add the form>>=
typerconf.set(f"{CONFIG_ADDED_FORMS}.{name}", url)
@

We can thus test this as follows.
<<test functions>>=
def test_add_form():
  result = runner.invoke(forms_cli, [
    "add", "restlabb", "https://..."
  ])
  assert result.exit_code == 0
  assert "restlabb" in config.get(added_forms)
<<test setup>>=
added_forms = kthutils.forms.CONFIG_ADDED_FORMS
@

We also want to test that we can't add a form with a period in the name.
<<test functions>>=
def test_add_form_with_period():
  result = runner.invoke(forms_cli, [
    "add", "restlabb.2023",
    "https://..."
  ])
  assert result.exit_code != 0
  assert "restlabb.2023" not in config.get(added_forms)
@

\subsection{Listing all added forms}

We want to list all the forms we've added.
This is useful for autocompletion if we add a parameter for filtering based on 
prefix.
<<API for KTH Forms>>=
def get_added_forms(prefix: str = "") -> List[str]:
  """
  Returns a list of all the forms added to the configuration that are prefixed 
  by `prefix`. Default prefix is an empty string, which returns all forms.
  """
  forms = typerconf.get(CONFIG_ADDED_FORMS).keys()
  return list(filter(lambda x: x.startswith(prefix), forms))
@

We want to test this as well.
<<test functions>>=
def test_get_added_forms():
  config.set(f"{added_forms}.restlabb", "https://...")
  assert "restlabb" in kthutils.forms.get_added_forms()
  assert "restlabb" in kthutils.forms.get_added_forms("rest")
  assert "nonexisting" not in kthutils.forms.get_added_forms()
@

Now, let's add a CLI command for listing the forms.
<<list command doc>>=
Lists all forms added to the configuration
<<command definitions>>=
@cli.command(name="ls")
def cli_list_forms():
  """
  <<list command doc>>
  """
  for form in get_added_forms():
    print(form)
@


\section{An API for KTH Forms}

Since we must be logged in to access KTH Forms, we want to create a class for 
using.
This class will in turn use the [[weblogin]] package.
<<API for KTH Forms>>=
class FormsSession:
  """
  Maintains a session to the KTH Forms service.
  """

  BASE_URL = <<KTH Forms base URL>>

  def __init__(self, username: str, password: str):
    """
    Creates a new session to the KTH Forms service.

    `username` is the KTH username to use for logging in through 
    https://login.ug.kth.se. `password` is the password to use for logging in.
    """
    <<Forms constructor>>

  <<Forms methods>>
@

Now we can create a session to use for testing.
<<test setup>>=
forms = kthutils.forms.FormsSession(*kthutils.credentials.get_credentials())
<<test imports>>=
import kthutils.credentials
import os
@


\subsection{Logging in}

To trigger the login we must have the correct URL.
<<KTH Forms base URL>>=
"https://www.kth.se/form/admin"
@

We can then create a session using [[weblogin]].
<<Forms constructor>>=
self.__session = weblogin.AutologinSession([
                      weblogin.kth.UGlogin(username, password,
                                           self.BASE_URL)
                    ])
<<imports>>=
import weblogin
import weblogin.kth
@


\subsection{Getting a form}

For now, we'll add a method for getting a form by URL.
It will return a CSV reader for the form.
<<imports>>=
import csv
<<Forms methods>>=
def get_data_by_url(self, url: str) -> Tuple[bytes, str]:
  """
  Gets the form at the given URL and returns it as (content, type) tuple. 
  Content is the raw data of the form, type is the content type of the form.
  """
  response = self.__session.get(url)
  if response.status_code != requests.codes.ok:
    raise ValueError(f"Failed to get form at {url}: {response.text}")

  return response.content, response.headers["Content-Type"]
<<imports>>=
import requests
@

We can test this with a known form.
<<test functions>>=
def test_get_data_by_url():
  data, content_type = forms.get_data_by_url(restlabb_url)
  assert content_type == "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  assert data.startswith(b"PK")
<<test setup>>=
restlabb_url = "https://www.kth.se/form/admin/api/webform/64ec8baa917ea4c31c33267e/answer/export"
@

\subsection{Getting a form in CSV format}

We can add a method for getting a form in CSV format, that is a list of lists 
as would be returned by the [[csv.reader]].
<<Forms methods>>=
def get_csv_by_url(self, url: str) -> List[List[str]]:
  """
  Gets the form at the given URL and returns it as a list of lists.
  """
  data, content_type = self.get_data_by_url(url)

  <<process [[data]] into [[csvdata]]>>

  return list(csvdata)
@

We want to test this method as well.
We'll use the same form as before, this is the form for Restlabb 2023/2024.
The first column is \enquote{Svarsdatum} and the second is \enquote{Kurs}.
We do this test twice to catch any generators not converted to lists.
<<test functions>>=
def test_get_csv_by_url():
  csvdata = forms.get_csv_by_url(restlabb_url)
  assert "Svarsdatum" in csvdata[0] and "Kurs" in csvdata[0]
  assert "Svarsdatum" in csvdata[0] and "Kurs" in csvdata[0]
@

\subsection{Processing the data to CSV}

The data we get can be in either CSV or XLS(X) format.
In the case of KTH Forms, it exports and XLSX file.
<<process [[data]] into [[csvdata]]>>=
if content_type == "text/csv":
  csvdata = csv.reader(data.decode("utf-8").splitlines())
elif "excel" in content_type or "spreadsheet" in content_type:
  <<transform XLSX [[data]] into [[csvdata]]>>
else:
  raise ValueError(f"Form at {url} is not in CSV nor XLS(X) format")
@

There is a key detail in the transformation of XLSX to CSV.
We use the [[openpyxl]] package to read the XLSX file.
Each row that [[openpyxl]] produces is a tuple of cell values, not a list!
The [[csv]] module, on the other hand, works with lists, not tuples.
Hence we must also transform each row into a list.
Another difference is that [[openpyxl]] uses [[None]] for empty cells, while 
[[csv]] uses an empty string.
We must fix this too.
<<transform XLSX [[data]] into [[csvdata]]>>=
datafile = io.BytesIO(data)
<<let [[wb]] contain the workbook of [[datafile]]>>
sheet = wb.active
fix_empty_cells = lambda x: list(map(lambda y: y if y is not None else "", x))
csvdata = list(map(fix_empty_cells, sheet.iter_rows(values_only=True)))
<<imports>>=
import io
import openpyxl
@

Another annoyance with the [[openpyxl]] package is that it prints warnings when 
the file has no stylesheet information.
We're fine with this and there is no problem.
So when we read, we'll turn off the warnings.
<<let [[wb]] contain the workbook of [[datafile]]>>=
with warnings.catch_warnings():
  warnings.simplefilter("ignore")
  wb = openpyxl.load_workbook(datafile)
<<imports>>=
import warnings
@

Finally, to make the data more compatible with the command line, we want to 
clear all [[\n]]s from the data.
<<process [[data]] into [[csvdata]]>>=
csvdata = map(clean_row, csvdata)
<<API for KTH Forms>>=
def clean_row(row: List[str]) -> List[str]:
  """
  Cleans a row of form data by replacing all newline characters by '\n'.
  """
  return list(map(lambda x: x.replace("\n", r"\n"), row))
@


\section{Exporting form data}

We want to export data from a form.
We add a command for this.
<<export command doc>>=
Prints data from a form to stdout in CSV format
<<command definitions>>=
@cli.command(name="export")
def cli_export_form(<<args for export command>>):
  """
  <<export command doc>>
  """
  <<export the form>>
@

We need a name for the form to export.
<<args for export command>>=
name: Annotated[FormName, form_name_arg],
@

We can then get the URL for the form from the configuration and use the 
[[get_form_by_url]] method to get the form.
<<export the form>>=
<<set up [[csvout]] as a CSV writer>>
<<let [[csvdata]] contain the form data>>
<<print all rows in [[csvdata]]>>
@

Let's test this.
<<test functions>>=
def test_cli_export_command():
  <<add restlabb form>>
  result = runner.invoke(forms_cli, [
    "export", "restlabb"
  ])
  assert result.exit_code == 0
  assert "Svarsdatum" in result.stdout
  assert "Bosk" in result.stdout
<<add restlabb form>>=
result = runner.invoke(forms_cli, [
  "add", "restlabb", restlabb_url
])
assert result.exit_code == 0
assert "restlabb" in config.get(added_forms)
@

To get the data, we first need the URL from the configuration.
Then we need the credentials to log into KTH Forms.
We'll create a helper function for this.
<<API for KTH Forms>>=
def export(name: str) -> List[List[str]]:
  """
  Returns data from a form in CSV format (lists of lists)
  """
  url = typerconf.get(f"{CONFIG_ADDED_FORMS}.{name}")
  forms = kthutils.forms.FormsSession(*kthutils.credentials.get_credentials())
  return forms.get_csv_by_url(url)
<<imports>>=
import kthutils.credentials
<<let [[csvdata]] contain the form data>>=
csvdata = export(name)
@

We can test this as well.
We simply test that we get the correct data.
<<test functions>>=
def test_export_function():
  <<add restlabb form>>
  csvdata = kthutils.forms.export("restlabb")
  assert "Svarsdatum" in csvdata[0]
@


We'll print the data as CSV data to stdout.
We'll let the user decide on the delimiter, but we'll default to tab.
<<set up [[csvout]] as a CSV writer>>=
csvout = csv.writer(sys.stdout, delimiter=delimiter)
<<args for export command>>=
delimiter: Annotated[str, delimiter_arg] = "\t",
<<option and argument definitions>>=
delimiter_arg = typer.Option(help="Delimiter to use for the CSV output")
<<imports>>=
import sys
<<print all rows in [[csvdata]]>>=
for row in csvdata:
  csvout.writerow(row)
@

We can test this as well.
<<test functions>>=
def test_export_delimiter():
  <<add restlabb form>>
  result = runner.invoke(forms_cli, [
    "export", "restlabb", "--delimiter", ","
  ])
  assert result.exit_code == 0
  assert "Svarsdatum,Studentens namn" in result.stdout

  result = runner.invoke(forms_cli, [
    "export", "restlabb"
  ])
  assert result.exit_code == 0
  assert "Svarsdatum\tStudentens namn" in result.stdout
@

\section{Turning a form into a generator}

We want to add the command [[next]] (in reference to Python generators) that 
essentially turns a form into a generator.
Whenever run it prints the new rows added to the form since the last time the 
command was run.
<<next command doc>>=
Prints new data from a form to stdout in CSV format
@

The command is very similar to the [[export]] command.
The only difference is the filtering.
<<command definitions>>=
@cli.command(name="next")
def cli_next_form(<<args for export command>>):
  """
  <<next command doc>>
  """
  <<set up [[csvout]] as a CSV writer>>
  <<filter [[csvdata]] to only contain new data>>
  <<print all rows in [[csvdata]]>>
@

To filter the data, we need to know what the export looked like the last time 
we ran the command.
We can store this in a file in the data directory.
Once we've computed the new data, we can store the current data in the file 
instead.
<<API for KTH Forms>>=
def next(name: str) -> List[List[str]]:
  """
  Returns new data (since last run) from a form in CSV format (lists of lists)
  """
  <<let [[prev_csvdata]] contain the previous form data>>
  new_csvdata = export(name)
  csvdata = list(filter(lambda x: x not in prev_csvdata, new_csvdata))
  <<store [[new_csvdata]] as the previous form data>>
  return csvdata
<<filter [[csvdata]] to only contain new data>>=
csvdata = next(name)
@

We use the [[dirs.user_data_dir]] function from [[typerconf]] to get the data 
directory.
Then we simply use a file [[next.{name}.csv]] to store the data.
We need the [[name]] to keep track of the state of different forms.
If the file doesn't exist when reading, it's the first time we run [[next]] and 
we have an empty list.
<<let [[prev_csvdata]] contain the previous form data>>=
data_dir = pathlib.Path(typerconf.dirs.user_data_dir)
prev_csvdata = []
prev_csvfile = data_dir / f"next.{name}.csv"
if prev_csvfile.exists():
  with prev_csvfile.open("r") as f:
    prev_csvdata = list(csv.reader(f))
<<imports>>=
import pathlib
@

When we want to write the file, we must ensure the directory exists.
We do this on [[prev_csvfile]] rather than [[data_dir]].
The reason is that, like this we can handle names ([[name]]) containing [[/]], 
such as [[restlabb23/24]] without changing it into something like 
[[restlabb23-24]]---thus avoiding the collision between those two mapping to 
the same name.
The consequence is that we create an extra directory, but that's fine---no one 
is supposed to look in there anyway.
<<store [[new_csvdata]] as the previous form data>>=
if not prev_csvfile.parent.exists():
  prev_csvfile.parent.mkdir(parents=True)
with prev_csvfile.open("w") as f:
  csv.writer(f).writerows(new_csvdata)
@

Let's test it.
We'll need to have a custom directory to test this properly, we need one to 
override the [[user_data_dir]] of the [[typerconf]] instance for the [[forms]] 
module.
We already did this above, but we need to do it again between each test here.
This also means that we must readd the form each time, since we also add a new 
config doing this.
<<test functions>>=
def test_next_command():
  <<reset [[config.dirs]]>>
  <<add restlabb form>>
  <<add test form>>
  <<test the next command>>

def test_next_function():
  <<reset [[config.dirs]]>>
  <<add restlabb form>>
  <<add test form>>
  <<test the next function>>
<<reset [[config.dirs]]>>=
config.dirs = FakeAppDirs()
<<add test form>>=
result = runner.invoke(forms_cli, [
  "add", "test",
  "https://www.kth.se/form/admin/api/webform/65bbb936dcba25abb5f696da/answer/export"
])
@

Now it's just to test the command.
We note that we should run it twice, the second time, the result should be 
empty.
<<test the next command>>=
result = runner.invoke(forms_cli, [
  "next", "restlabb"
])
assert result.exit_code == 0
assert "Svarsdatum" in result.stdout
assert "Bosk" in result.stdout

result = runner.invoke(forms_cli, [
  "next", "restlabb"
])
assert result.exit_code == 0
assert "Svarsdatum" not in result.stdout
assert "Bosk" not in result.stdout
@

We do similarly for the next function.
<<test the next function>>=
csvdata = kthutils.forms.next("restlabb")
assert "Svarsdatum" in csvdata[0]
csvdata = kthutils.forms.next("restlabb")
assert not csvdata
@

But now we also want to try this with the test form.
We want to see that running next on one form doesn't affect the other.
<<test the next function>>=
csvdata = kthutils.forms.next("test")
assert "Name" in csvdata[0] and "Daniel" in csvdata[1]
csvdata = kthutils.forms.next("restlabb")
assert not csvdata
csvdata = kthutils.forms.next("test")
assert not csvdata
@


\section{Rewriting the form data}

We want to be able to rewrite the form data into a more structured format.
We'll add a command [[rewrite]] for this.
<<rewrite command doc>>=
Rewrites data from a form and prints it to stdout
@

\subsection{Problem overview}

We're particularly interested in rewriting the rows of the form from Restlabb 
into a [[canvaslms]] line to execute.
They have the following columns:
\begin{enumerate}
\item Svarsdatum
\item Studentens namn
\item\label{StudentLogin} Studentens kth-mail
\item\label{Course} Kurs
\item\label{CourseResponsible} Kursledare
\item\label{Module} Moment
\item\label{Comments} Kommentarer
\item Rapporterat i Canvas?
\item Assistent
\item Inloggad användare
\item Användarnamn
\item\label{GraderLogin} E-post
\end{enumerate}

We don't really care for most of those columns.
Those that are interesting are
\cref{StudentLogin,Course,CourseResponsible,Module,Comments,GraderLogin}.
\Cref{StudentLogin,GraderLogin} are the KTH mail of the student and the grader, 
both are on the form username@kth.se.
The course (\cref{Course}) varies, but looks something like \enquote{DD1310 
Cmast ht23}.
The module (\Cref{Module}) and comments (\Cref{Comments}) are the main columns 
of interest.
It can look something like this:
\blockquote{P-uppgift betyg A/D	Sen redovisning, om det är tillåtet att 
presentera högre betyg Pupp så sent, tycker jag att studenten borde få ett A. 
Annars blir det ett D.}

Now, we'd like to turn that into a line like this:
\begin{minted}{bash}
echo Moment: P-uppgift betyg A/D
echo Kommentarer: Sen redovisning, om det är tillåtet att presentera högre betyg 
echo Pupp så sent, tycker jag att studenten borde få ett A. Annars blir det ett D.
canvaslms grade -c DD1310 -a redovisning -u student@kth.se \
  -g A -m "OK grader@kth.se" \
\end{minted}

The course code we can regex out of there easily: [[[A-Z]{2}\d{3,4}[A-Z]?]].
The same for the student's and the grader's KTH emails (usernames), no regex 
needed even, just to get those columns.
The grade and assignment (second line in command line), however, must both be 
parsed out of the comment column.

The assignment can be translated by a translation [[s/P-uppgift/redovisning/]].
We can find the grade by matching [[betyg ([A-F])]] and use group 1.
Both are usually in the module column (\cref{Module}).

We present some more examples of module--comment pairs in 
\cref{ModuleCommentExamples}.
\begin{table}
\caption{\label{ModuleCommentExamples} Examples of module--comment pairs}
\centering
\begin{tabular}{lp{0.6\columnwidth}}
{Moment} & {Kommentarer} \\
\toprule
Labb 5 del 1&\\
P-uppgift Godkänd betyg D&Kursen verkar ha ändrat kurskod och DD1315 är något annat nu. Redovisningen tillhör den DD1315 som gavs ht21.\\
P-uppgift betyg E&\\
Labb 3&Tidigare blivit godkänd på muntlig redovisning men inte i canvas. Jag har tagit redovisning igen och det är godkänt. Han kan inte lämna in i canvas igen ser det ut som.\\
Projektspecifikation Godkänd&\\
p-uppgift betyg E&Bråttom\\
Lab 3&\\
Granskning&\\
\bottomrule
\end{tabular}
\end{table}
This leaves us with some more translations to do.
We want to translate these names into the correct names of the assignments in 
Canvas.
We can see some examples in \cref{AssignmentNames}.
\begin{table}
\caption{\label{AssignmentNames} Examples of assignment names}
\centering
\begin{tabular}{ll}
{LADOK module} & {Assignment} \\
\toprule
LAB1&Laboration (3) upprepningar, listor och moduler\\
LAB1&Laboration (6) filhantering\\
LAB3&Projektspecifikation\\
LAB3&Projektgranskning\\
LAB3&Projektredovisning\\
\bottomrule
\end{tabular}
\end{table}
This leaves us with the following regex suggestions:
\begin{itemize}
\item [[s/[Pp]-?upp(gift)?/redovisning/]]
\item [[s/[Ll]ab(b|oration) (\d+)/Laboration..\2./]]
\item [[s/.*[Ss]pec.*/spec/]]
\item [[s/.*[Gg]ranskning.*/granskning/]]
\end{itemize}

\subsection{Solution overview}

We can use Python's named format substitutions and the [[re]] module as a base 
for the solution.
We can use a system of named rewrites.
We can store the rewrites and the rewriting options in the configuration.

Python supports named format substitutions:
\begin{minted}{python}
>>> "test {a} = {b}".format(a=1, b=2)
'test 1 = 2'
>>> d = {"a": 1, "b": 2}
>>> f = "test {a} = {b}"
>>> f.format(**d)
'test 1 = 2'
\end{minted}
This means that we can have a base string with named substitutions and then let 
the use specify the values for the substitutions.
Each such named substitution can then be a regex substitution using [[re.sub]] 
on the row in the form data.

Then we can do something along the lines of the following to achieve what we 
outlined above.
We'll write a shell script [[<<restlabbsetup.sh>>]] that can be used to set the 
configuration.

The first line clears the entire restlabb configuration, we do this in case we 
re-run these lines when we've updated the config.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb -s ""
@

We then want to have the overall format string.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.format_string -s "
echo 'Time:         {time}'
echo 'Course:       {course}'
echo 'Module:       {module}'
echo 'Student:      {student}'
echo 'Comments:     {comments}'
echo 'Grader:       {grader}'
echo 'In Canvas:    {in_canvas}'
if [ '{in_canvas}' = 'Ja' ]; then
  echo 'Already in Canvas.'
else
  canvaslms grade \\
    -c '{course_nick}{year}' \\
    -a '{assignment}' \\
    -u '{student}' \\
    -g '{grade}' \\
    -m 'OK {grader}'
fi
echo 'Canvas:'
canvaslms submissions \\
  -c '{course_nick}{year}' \\
  -a '{assignment}' \\
  -u '{student}'
echo
canvaslms results \\
  -c '{course_nick}{year}' \\
  -A '{assignment_group}' \\
  -u '{student}' \\
| sed -E 's/ ?[HV]T[0-9]{{2}}( \(.*\))?//' \\
| ladok report -fv
echo
"
@

Now we need to define the substitutions used in the format string above.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.time.column -s 0
kthutils config forms.rewriter.restlabb.substitutions.module.column -s 5
kthutils config forms.rewriter.restlabb.substitutions.comments.column -s 6
kthutils config forms.rewriter.restlabb.substitutions.course.column -s 3
@ These just copy the values from the column verbatim.

Next, let's illustrate how we extract the course code---although we don't use 
it for now.
This we can extract from the course column, we'll need a regex substitution to 
filter out the course code in particular.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.course_code.column -s 3
kthutils config forms.rewriter.restlabb.substitutions.course_code.regex \
  -s "s/^.*([A-Z]{2}\d{3,4}[A-Z]?).*$/\1/"
@

We also want to extract the semester from that column, and turn it into 
capitals.
We give a list of rewrites, one for each semester.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.semester.column -s 3
kthutils config forms.rewriter.restlabb.substitutions.semester.regex \
  -s "s/^.*[Hh][Tt](\d{2}).*$/HT\1/" \
  -s "s/^.*[Vv][Tt](\d{2}).*$/VT\1/"
@ We used two regexes to ensure that we rewrite both HT and VT to the correct 
case.

However, we can do a bit better.
We can actually rewrite to the normal nicknames that we use for the courses:
DD1310 HT24 CMAST should become prgm24.
We can do this with a simple substitution, we treat the nick and year 
separately, as can be seen in the format string above.

When we rewrite the nick, we do it with a list of regexes---one for each 
course.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.course_nick.column -s 3
kthutils config forms.rewriter.restlabb.substitutions.course_nick.regex \
  -s "s/^.*DD1310.*(CMAST|[SC]ITEH?)?.*$/prgm/" \
  -s "s/^.*DD1317.*(prgi)?.*$/prgi/"
@

Now, let's turn to that year.
We can extract the year from the course column, same as we did for the semester 
above.
However, some TAs write HT24 (most), some HT2024 (Edvin).
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.year.column -s 3
kthutils config forms.rewriter.restlabb.substitutions.year.regex \
  -s "s/^.*([HhVv][Tt][- ]*|prg[im])(?:20)?(\d{2}).*$/\2/"
@

We also want to extract the grader, or rather, the grader's (KTH) email.
The same for the student.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.grader.column -s 11
kthutils config forms.rewriter.restlabb.substitutions.grader.regex \
  -s "s/^.*?([A-Za-z0-9]+@kth.se).* $/\1/"
kthutils config forms.rewriter.restlabb.substitutions.student.column -s 2
kthutils config forms.rewriter.restlabb.substitutions.student.regex \
  -s "s/^.*?([A-Za-z0-9]+@kth.se).*$/\1/"
@

Also, we want to extract if the grader already put the result into Canvas or 
not.
This has its own column.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.in_canvas.column -s 7
@

The grade is a bit trickier to extract.
It's in the module column.
Usually the TAs write something like ``P-uppgift betyg A/D'' or ``Projekt, A''.
We try to extract the grade from that.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.grade.column -s 5
kthutils config forms.rewriter.restlabb.substitutions.grade.regex \
  -s "s/.*([Bb]etyg|,)?\b([A-F])(\b.*)?$/\2/" \
  -s "s/.*(EJ GODKÄN[TD]|[Ee]j godkän[dt]).*$/F/"
@ For P/F assignments, the TAs usually don't write any grade.
They just write ``granskning''.
For this, we have a default grade, in case the substitution doesn't match 
anything.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.grade.no_match_default \
  -s P
@

The trickiest part, though, is the assignment.
This must also be extracted from the module column.
Let's start with the easy ones.
The more challenging here is the project.
We don't want to match the project when the TA wrote ``Projektgranskning'' or 
``P-uppgiftsgranskning'', then we just want ``granskning''.
But for ``Projekt'', we actually want to match that as ``redovisning''.
We use a negative lookahead assertion for this ([[(?!...)]]).
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.assignment.column -s 5
kthutils config forms.rewriter.restlabb.substitutions.assignment.regex \
  -s 's/.*[Pp](.?[Uu]ppgift|rojekt)[s ]?(?![sg]).*/redovisning/' \
  -s 's/.*[Ss][Pp][Ee][Cc].*/spec/' \
  -s 's/.*[Gg](ransk|RANSK).*/granskning/' \
  <<regexes for labs>>
@

The labs are a bit more tricky.
Here the TAs usually write something like ``Labb 3'' or ``Lab 3''.
They might also write ``Labb 1\&2\&3'' or ``Lab 1-3''.

We can match all kinds of variations of the word for labb as follows.
We never want to get the group here, so we use a non-capturing group 
([[(?:...)]]).
<<lab spelling>>=
.*[Ll]ab(?:b|oration)?
@

The range is rather straight forward.
We can just take the range and put it in a regex [[[...]]].
<<regexes for labs>>=
-s 's/<<lab spelling>> *(\d-\d)\D*.*/Laboration..[\1]./' \
@

For the combined labs, we match the conjunctions.
We also match spacing around the conjunctions, if any.
(The same as above, we use non-capturing groups.)
<<conjunctions>>=
\s*(?:[,&+]| och | å )\s*
@

The idea is to use two consecutive regexes, separated by [[;]].
(This has the same meaning as with [[sed]], see 
page~\pageref{ParseSubstPatterns}.)
The first will rewrite the lab part:
[[Labb 1&2&3]] to [[Laboration .(1\&2\&4).]].
The second will rewrite the conjunctions:
all [[&]] to [[|]], that is the [[<<conjunctions>>]].
<<regexes for labs>>=
-s '<<rewrite lab>>; <<rewrite conjunctions>>'
@

When we rewrite the lab, we want to capture any numbers and conjunctions.
<<rewrite lab>>=
s/<<lab spelling>> *(\d+(?:<<conjunctions>>\d+)*)\D*.*/Laboration .(\1)./
@

When we rewrite the conjunctions, we simply want to replace them by the 
disjunction ([[|]]).
However, since these conjunctions are for the lab numbers,
we want to match---but not rewrite---the numbers as well.
Otherwise we'll rewrite conjunctions in all kinds of settings.
<<rewrite conjunctions>>=
s/(?<=\d)<<conjunctions>>(?=\d)/|/
@

We note that the last pattern also captures single labs.
Since the (non-capturing) group around the conjunctions has [[*]], we also 
capture labs using no conjunctions.

Finally, the last thing we want to do is to take the assignment and turn it 
into the correct assignment group---that is, labs to LAB1 and project-related 
assignments to LAB3.
<<restlabbsetup.sh>>=
kthutils config forms.rewriter.restlabb.substitutions.assignment_group.column -s 5
kthutils config forms.rewriter.restlabb.substitutions.assignment_group.regex \
  -s "s/.*[Ll]ab(b|oration).*/LAB1/" \
  -s "s/.*[Pp]-?(upp(gift)?|UPP(GIFT)?|rojekt|ROJEKT).*/LAB3/" \
  -s "s/.*[Ss][Pp][Ee][Cc].*/LAB3/" \
  -s "s/.*[Gg](ransk|RANSK).*/LAB3/" \
  -s "s/.*[Rr](edovisn|EDOVISN).*/LAB3/"
@

\subsection{The [[rewriter]] subcommands}

We add a group of commands for the rewriter system, [[rewriter]].
So we add the rewriter commands to [[rewriter]] instead of [[cli]].
<<command definitions>>=
rewriter = typer.Typer(name="rewriter", help="Rewriter for form data")
cli.add_typer(rewriter)
@

We want a command to run the rewriter, we want another to add a 
rewriter\footnote{%
  We haven't implemented the command to add a rewriter yet.
  For now, we must do as we did above ([[<<restlabbsetup.sh>>]]), that is, add 
  the rewriter to the configuration manually.
}.
The command to add a rewriter is just a more usable way than to add the values 
to the config directly (as suggested above).

This way, we can have rewriter for the restlabb form and turn it into result 
reporting commands.
We'll have a bash script that will be run by Cron.
We must source our [[.profile]] to ensure everything works as usual.
<<restlabb.sh>>=
#!/bin/bash

source ${HOME}/.profile
@

We always name the restlabb forms as [[restlabb{AC_YEAR}]],
where [[AC_YEAR]] is the academic year (e.g., 24/25).
We switch academic year during summer.
Particularly, when we hit July, we want to look forward.
Then we also get a reminder early on to add the new form.

One thing to remember here is to remove the leading zero from the month.
Otherwise the [[test]] program will interpret the month as octal.
<<restlabb.sh>>=
YEAR=$(date +%y)
MONTH=$(date +%m | sed "s/^0//")  # Remove leading zero
if [[ $MONTH -lt 7 ]]; then
  AC_YEAR="$((YEAR-1))/${YEAR}"
else
  AC_YEAR="${YEAR}/$((YEAR+1))"
fi
@

Next we extract the new values since the last run (using the [[next]] command) 
and [[grep]] for the relevant lines:
namely those mentioning me or any of my courses.
Finally, we rewrite those lines using the rewriter named [[restlabb]], that we 
configured above (in [[restlabbsetup.sh>>]]).
<<restlabb.sh>>=
kthutils forms next restlabb${AC_YEAR} \
| grep -E "(Bosk|DD1310.*(CMAST|[CS]ITEH?)|DD131[57].*CINEK)" \
| kthutils forms rewriter rewrite restlabb
@


\subsection{Rewriting the form data}

Let's start with the command to rewrite the form data.
<<rewrite command doc>>=
Rewrites data from a form using a rewriter and prints it to stdout in a more 
structured format
<<command definitions>>=
@rewriter.command(name="rewrite")
def rewriter_rewrite_form(<<args for rewrite command>>):
  """
  <<rewrite command doc>>
  """
  <<read [[csvdata]] from the form>>
  <<get [[rewriter]] from the configuration>>
  for row in csvdata:
    print(rewrite_row(row, rewriter))
@

\subsubsection{Getting the rewriter}

We can get the rewriter from the configuration.
If we fetch it by name, we get a dictionary that we can pass to the function 
that contains all the data needed.
<<get [[rewriter]] from the configuration>>=
rewriter = typerconf.get(f"{CONFIG_REWRITERS}.{rewriter}")
<<constants>>=
CONFIG_REWRITERS = "forms.rewriter"
@

Thus we need the user to provide [[rewriter]] as an argument.
<<args for rewrite command>>=
rewriter: Annotated[FormName, rewriter_arg],
<<option and argument definitions>>=
rewriter_arg = typer.Argument(help="Name of the rewriter",
                              parser=FormName,
                              autocompletion=get_added_rewriters)
@

We also need a function to list all the added rewriters to handle the 
autocompletion.
<<API for KTH Forms>>=
def get_added_rewriters(prefix: str = "") -> List[str]:
  """
  Returns a list of all the rewriters added to the configuration that are 
  prefixed by `prefix`. Default prefix is an empty string, which returns all 
  rewriters.
  """
  rewriters = typerconf.get(CONFIG_REWRITERS).keys()
  return list(filter(lambda x: x.startswith(prefix), rewriters))
@


\subsubsection{Reading the form data}

To read the form data, we have three options: we can use either the [[export]] 
or the [[next]] command, or we can read the form data from stdin.
We make the form name an optional argument, defaulting to stdin.
<<args for rewrite command>>=
form: Annotated[FormName, opt_form_name_arg] = None,
<<option and argument definitions>>=
opt_form_name_arg = typer.Argument(help="Name of the form, if not provided, "
                                        "read from data from stdin",
                                   parser=FormName,
                                   autocompletion=get_added_forms)
@

If we want to read the [[csvdata]] from the form using the [[export]] or the 
[[next]] command, we must let the user decide which command to use.
<<args for rewrite command>>=
source: Annotated[Source, source_opt] = "next",
<<option and argument definitions>>=
class Source(str, Enum):
  export = "export"
  next = "next"

source_opt = typer.Option(help="Source of the form data, either "
                               "the export or next command.",
                          case_sensitive=False)
<<imports>>=
from enum import Enum
@

We can then read the form data.
<<read [[csvdata]] from the form>>=
if form is None:
  <<read [[csvdata]] from stdin>>
elif source == Source.export:
  csvdata = export(form)
elif source == Source.next:
  csvdata = next(form)
else:
  raise typer.BadParameter(f"Unknown source: {source}")
@

If we read from stdin, we can use the [[csv.reader]] to read the data.
We also want to control the delimiter, so we need to add an option for that.
<<read [[csvdata]] from stdin>>=
csvdata = list(csv.reader(sys.stdin, delimiter=delimiter))
<<args for rewrite command>>=
delimiter: Annotated[str, delimiter_arg] = "\t",
@

\subsubsection{Rewriting a row}

Now we want to do the actual rewriting.
<<API for KTH Forms>>=
def rewrite_row(row: List[str], rewriter: Dict[str, Any]) -> str:
  """
  Rewrites a row of form data using the rewriter and returns it as a string.
  """
  format_string = rewriter["format_string"]
  <<create [[substitutions]] from [[row]] and [[rewriter]]>>
  return format_string.format(**substitutions)
@

The [[rewriter]] that we get will have the following form.
\begin{minted}{python}
{
  "format_string": "# Moment: {moment}\n# Kommentarer: {comments}\n"
                   "canvaslms grade -c '{course}' -u '{student}' "
                   "-m 'OK {grader}' -g '{grade}' -a '{assignment}'",
  "substitutions": {
    "moment": {"column": 5},
    "comments": {"column": 6},
    "course": {"column": 3, "regex": "s/.*([A-Z]{2}\\d{3,4}[A-Z]?).*/\\1/"},
    "student": {"column": 2, "regex": "s/.*?([a-z]+@kth.se).*/\\1/"},
    "grader": {"column": 11, "regex": "s/.*?([a-z]+@kth.se).*/\\1/"},
    "grade": {
      "column": 5,
      "regex": "s/.*[Bb]etyg ([A-F]).*/\\1/",
      "no_match_default": "P"
    },
    "assignment": {"column": 5, "regex": [
        "s/.*[Pp]-?upp(gift)?.*/redovisning/",
        "s/.*[Ll]ab(b|oration)? (\\d+).*/Laboration..\\2./",
        "s/.*spec.*/spec/",
        "s/.*[Gg]ransk.*/granskning/"
    ]}
  }
}
\end{minted}

We can then create the substitutions from the row and the rewriter.
Each substitution has the following format:
\begin{description}
\item[column] The column whose data that the substitution (regex) should be 
applied to.
If the column is not present, we use all the columns and join them by a tab 
character.
\item[regex] The regex to apply to the data in the column.
This should have the form [[s/regex/replacement/]].
The [[/]] can be any character, same as in [[sed]].
\end{description}
<<create [[substitutions]] from [[row]] and [[rewriter]]>>=
substitutions = {}
for variable, var_subst in rewriter["substitutions"].items():
  if "column" in var_subst:
    <<make [[data]] contain the columns from [[row]]>>
  else:
    data = "\t".join(row)

  try:
    if not isinstance(var_subst["regex"], list):
      regexes = [var_subst["regex"]]
    else:
      regexes = var_subst["regex"]
  except KeyError:
    substitutions[variable] = data
    continue

  regex_results = []
  for regex in regexes:
    <<apply [[regex]] to [[data]] and store the result in [[regex_results]]>>

  <<update [[substitutions]] with [[regex_results]]>>
@

<<make [[data]] contain the columns from [[row]]>>=
column = var_subst["column"]
if ":" in column:
  if column.count(":") == 2:
    try:
      start, end, step = map(int, column.split(":"))
    <<handle that the user specified non-int slices>>
    s = slice(start, end, step)
  elif column.count(":") == 1:
    try:
      start, end = map(int, column.split(":"))
    <<handle that the user specified non-int slices>>
    s = slice(start, end)
  else:
    raise ValueError(f"{variable}.column = {column} has too many colons.")
  data = "\t".join(row[s])
else:
  try:
    data = row[int(column)]
  <<handle that the user-specified column is out of range>>
  <<handle that the user-specified column is not an int>>
@

If there is an error, we must make it a useful message to the user, since they 
have to fix it.
<<handle that the user-specified column is out of range>>=
except IndexError:
  raise ValueError(f"{variable}.column = {column} is "
                   f"out of range, row has {len(row)} columns: {row}.")
<<handle that the user-specified column is not an int>>=
except ValueError as err:
  raise ValueError(f"{variable}.column = {column} is not an int: {err}")
<<handle that the user specified non-int slices>>=
except ValueError as err:
  raise ValueError(f"{variable}.column = {column} is not a valid slice: {err}")
@

We can then apply the regexes to the data and store the result in the 
[[substitutions]] dictionary.
The regex that we get can be a list of regexes, using [[sed]] syntax.
Meaning that we can get something like
[[s/match/replacement/; s/match/replacement/; ...]],
rather than just one of them.
Just as with [[sed]], we apply each regex in order through a pipe.
The second regex applies to the result of the first, etc.
<<apply [[regex]] to [[data]] and store the result in [[regex_results]]>>=
subst_patterns = parse_subst_pattern(regex)
value = data
for subst_pattern in subst_patterns:
  try:
    value = substitute(subst_pattern, value)
  except ValueError as err:
    raise ValueError(f"{variable}.regex: {subst_pattern} is invalid: {err}")
<<update [[regex_results]] with [[value]]>>
<<functions>>=
def substitute(subst_pattern, data):
  """
  Takes a substitution pattern `subst_pattern` (`s/match/replacement/`) and
  returns the result of applying it to `data`.
  """
  <<check that [[subst_pattern]] is value, raise [[ValueError]] if not>>
  <<break out [[pattern]] and [[replacement]] from [[subst_pattern]]>>
  return re.sub(pattern, replacement, data)
<<imports>>=
import re
@

We want to apply each regex on the data and add each result.
Consider the following example:
\begin{minted}{text}
projektspec + p-uppgift betyg D
\end{minted}
We want both the specification and the project assignments to be included in 
the result, not just one of them.
Hence, we need to add each result to the list [[regex_results]].
However, if there is no match, [[value]] will equal [[data]] and we don't want 
to add that.
We also don't want to add the same result twice.
<<update [[regex_results]] with [[value]]>>=
if value != data and value not in regex_results:
  regex_results.append(value)
@

If there are more than one result, we want to turn it into a regex group.
We need opening and closing parentheses and a pipe character between each 
result.
If there are no results from the regex rewrites, we use the original data.
<<update [[substitutions]] with [[regex_results]]>>=
num_results = len(regex_results)
if num_results == 1:
  substitutions[variable] = regex_results[0]
elif num_results < 1:
  <<update [[substitutions]] with [[data]] if no results>>
else:
  substitutions[variable] = f"({'|'.join(regex_results)})"
@

If there are not any results from the regex rewrites, we use the original data.
However, in some cases, we want to replace it by a constant.
For instance, sometimes the restlabb TA just writes the name of the lab when 
the student has passed it.
In those cases we won't get any rewrite on the grade, but we don't want to use 
the data, since that's the name of the lab.
We use a special attribute for this in the [[var_subst]] dictionary.
<<update [[substitutions]] with [[data]] if no results>>=
if "no_match_default" in var_subst:
  substitutions[variable] = var_subst["no_match_default"]
else:
  substitutions[variable] = data
@

Now, let's return to parsing the substitution patterns.
We want to split the substitution patterns into a list of patterns.
Instinctively, we can do this by splitting on [[;]].
However, the user is likely to use [[;]] in the regexes, so we need to be 
careful.

The syntax of a substitution pattern is [[s/match/replacement/]].
We can use any character as the separator, but [[/]] is the most common.
We assume that the use will use a character that will \emph{not be in the 
pattern}, to avoid having to escape it in the pattern.
This assumption allows us to ignore looking for escaped separators.
<<check that [[subst_pattern]] is value, raise [[ValueError]] if not>>=
if subst_pattern[0] != "s" and subst_pattern.count(subst_pattern[1]) < 3:
  subst_char = subst_pattern[1]
  raise ValueError(f"'{subst_pattern}' is invalid: must be of form "
                   f"'s{subst_char}match{subst_char}replacement{subst_char}'")
<<break out [[pattern]] and [[replacement]] from [[subst_pattern]]>>=
_, pattern, replacement, _ = subst_pattern.split(subst_pattern[1])
@

\label{ParseSubstPatterns}%
Time to parse a series of these patterns.
We'll go through the string and look for starts and ends:
[[sX]] starts and [[X;]] ends, where [[X]] can be any character.
We should also ensure we find [[X]] somewhere in the middle too.
We'll use a regex for this.
<<functions>>=
def parse_subst_pattern(subst_pattern: str) -> List[str]:
  """
  Parses a substitution pattern `subst_pattern`, for example

    `s/match/replacement/; s/match/replacement/; ...`

  and returns a list of the patterns.
  """
  patterns = []
  <<let [[regex]] be the regex for finding substitution patterns>>
  for pattern in re.finditer(regex, subst_pattern):
    subst_char = pattern.group(1)
    match = pattern.group(2)
    replacement = pattern.group(3)
    patterns.append(f"s{subst_char}{match}{subst_char}{replacement}{subst_char}")
  return patterns
@

Let's look at the details of the regex.
<<let [[regex]] be the regex for finding substitution patterns>>=
regex = r"s(.)(.*?)(?<!\\)\1(.*?)(?<!\\)\1(?:; *|$)"
@ The important details are the following:
\begin{itemize}
  \item Use a non-greedy match ([[.*?]], the [[?]] has this effect) for the 
  match and replacement.
  If not, we'll match from the first into the second (or last) pattern.
  \item We use a negative lookbehind assertion ([[(?<!\\)]]) to ensure that the 
  separator isn't escaped.
  This is to avoid matching on [[\/]] and the like.
  \item We use a non-capturing group for the separator and the end of the 
  pattern ([[(?:; *|$)]]) to ensure that we match on either the separator 
  ([[;]]) or the end of the string.
\end{itemize}
