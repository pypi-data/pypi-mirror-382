from collections.abc import Mapping, Sequence
import enum
from typing import Annotated, overload

from numpy.typing import NDArray

from . import graphs as graphs, nodes as nodes


MIN_FORMAT_VERSION: int = 8

MAX_FORMAT_VERSION: int = 21

LIBRARY_VERSION_MAJOR: int = 0

LIBRARY_VERSION_MINOR: int = 1

LIBRARY_VERSION_PATCH: int = 0

LIBRARY_VERSION_NUMBER: int = 100

class NodeID:
    pass

class GraphID:
    pass

class Type(enum.Enum):
    Serial = 1

    Struct = 2

    Numeric = 4

    String = 8

class TypeMask(enum.Flag):
    Serial = 1

    Struct = 2

    Numeric = 4

    String = 8

    Any = 15

class CParam(enum.Enum):
    StickyParameters = 1

    CompressionLevel = 2

    DecompressionLevel = 3

    FormatVersion = 4

    PermissiveCompression = 5

    CompressedChecksum = 6

    ContentChecksum = 7

    MinStreamSize = 11

class DParam(enum.Enum):
    StickyParameters = 1

    CheckCompressedChecksum = 2

    CheckContentChecksum = 3

class Buffer:
    @property
    def type(self) -> Type: ...

    @property
    def elt_width(self) -> int: ...

    @property
    def num_elts(self) -> int: ...

    @property
    def content_size(self) -> int: ...

    def as_nparray(self) -> Annotated[NDArray, dict(order='C', device='cpu', writable=False)]: ...

    def as_pytensor(self) -> Annotated[NDArray, dict(order='C', device='cpu', writable=False)]: ...

    def as_dltensor(self) -> Annotated[NDArray, dict(order='C', device='cpu', writable=False)]: ...

    def as_bytes(self) -> bytes: ...

class Input:
    def __init__(self, type: Type, data: Annotated[NDArray, dict(order='C', device='cpu', writable=False)], lengths: Annotated[NDArray, dict(shape=(None,), order='C', device='cpu', writable=False)] | None = None) -> None: ...

    @property
    def type(self) -> Type: ...

    @property
    def num_elts(self) -> int: ...

    @property
    def elt_width(self) -> int: ...

    @property
    def content_size(self) -> int: ...

    def get_int_metadata(self, arg: int, /) -> int | None: ...

    def set_int_metadata(self, arg0: int, arg1: int, /) -> None: ...

    @property
    def content(self) -> Buffer: ...

    @property
    def string_lens(self) -> Buffer: ...

class MutBuffer:
    @property
    def type(self) -> Type: ...

    @property
    def elt_width(self) -> int: ...

    @property
    def num_elts(self) -> int: ...

    @property
    def content_size(self) -> int: ...

    def as_nparray(self) -> Annotated[NDArray, dict(order='C', device='cpu')]: ...

    def as_pytensor(self) -> Annotated[NDArray, dict(order='C', device='cpu')]: ...

    def as_dltensor(self) -> Annotated[NDArray, dict(order='C', device='cpu')]: ...

class Output:
    def __init__(self, type: Type, data: Annotated[NDArray, dict(order='C', device='cpu')], lengths: Annotated[NDArray, dict(shape=(None,), order='C', device='cpu')] | None = None) -> None: ...

    @property
    def type(self) -> Type: ...

    @property
    def num_elts(self) -> int: ...

    @property
    def elt_width(self) -> int: ...

    @property
    def content_size(self) -> int: ...

    @property
    def elts_capacity(self) -> int: ...

    @property
    def content_capacity(self) -> int: ...

    def reserve_string_lens(self, arg: int, /) -> None: ...

    def get_int_metadata(self, arg: int, /) -> int | None: ...

    def set_int_metadata(self, arg0: int, arg1: int, /) -> None: ...

    def commit(self, arg: int, /) -> None: ...

    @property
    def content(self) -> Buffer: ...

    @property
    def mut_content(self) -> MutBuffer: ...

    @property
    def string_lens(self) -> Buffer: ...

    @property
    def mut_string_lens(self) -> MutBuffer: ...

class NodeParameters:
    def __init__(self) -> None: ...

    @property
    def name(self) -> str | None: ...

    @name.setter
    def name(self, arg: str, /) -> None: ...

    @property
    def local_params(self) -> LocalParams | None: ...

    @local_params.setter
    def local_params(self, arg: LocalParams, /) -> None: ...

class GraphParameters:
    def __init__(self) -> None: ...

    @property
    def name(self) -> str | None: ...

    @name.setter
    def name(self, arg: str, /) -> None: ...

    @property
    def custom_graphs(self) -> list[GraphID] | None: ...

    @custom_graphs.setter
    def custom_graphs(self, arg: Sequence[GraphID], /) -> None: ...

    @property
    def custom_nodes(self) -> list[NodeID] | None: ...

    @custom_nodes.setter
    def custom_nodes(self, arg: Sequence[NodeID], /) -> None: ...

    @property
    def local_params(self) -> LocalParams | None: ...

    @local_params.setter
    def local_params(self, arg: LocalParams, /) -> None: ...

class Compressor:
    def __init__(self) -> None: ...

    def set_parameter(self, arg0: CParam, arg1: int, /) -> None: ...

    def get_parameter(self, arg: CParam, /) -> int: ...

    def build_static_graph(self, head_node: NodeID, successor_graphs: Sequence[GraphID], *, name: str | None = None, local_params: LocalParams | None = None) -> GraphID: ...

    def parameterize_node(self, node: NodeID, *, name: str | None = None, local_params: LocalParams | None = None) -> NodeID: ...

    def parameterize_graph(self, graph: GraphID, *, name: str | None = None, custom_graphs: Sequence[GraphID] | None = None, custom_nodes: Sequence[NodeID] | None = None, local_params: LocalParams | None = None) -> GraphID: ...

    def register_custom_encoder(self, arg: CustomEncoder, /) -> NodeID: ...

    def register_function_graph(self, arg: FunctionGraph, /) -> GraphID: ...

    def register_selector_graph(self, arg: Selector, /) -> GraphID: ...

    def get_node(self, name: str) -> NodeID | None: ...

    def get_graph(self, name: str) -> GraphID | None: ...

    def select_starting_graph(self, graph: GraphID) -> None: ...

    def serialize(self) -> bytes: ...

    def serialize_to_json(self) -> str: ...

    def deserialize(self, serialized: bytes) -> None: ...

    def get_unmet_dependencies(self, serialized: bytes) -> Compressor.UnmetDependencies: ...

    class UnmetDependencies:
        @property
        def graph_names(self) -> list[str]: ...

        @property
        def node_names(self) -> list[str]: ...

class CCtx:
    def __init__(self) -> None: ...

    def ref_compressor(self, arg: Compressor, /) -> None: ...

    def set_parameter(self, arg0: CParam, arg1: int, /) -> None: ...

    def get_parameter(self, arg: CParam, /) -> int: ...

    def reset_parameters(self) -> None: ...

    def select_starting_graph(self, compressor: Compressor, graph: GraphID, *, name: str | None = None, custom_graphs: Sequence[GraphID] | None = None, custom_nodes: Sequence[NodeID] | None = None, local_params: LocalParams | None = None) -> None: ...

    def compress(self, arg: Sequence[Input], /) -> bytes: ...

class DCtx:
    def __init__(self) -> None: ...

    def set_parameter(self, arg0: DParam, arg1: int, /) -> None: ...

    def get_parameter(self, arg: DParam, /) -> int: ...

    def reset_parameters(self) -> None: ...

    def decompress(self, arg: bytes, /) -> list[Output]: ...

    def register_custom_decoder(self, arg: CustomDecoder, /) -> None: ...

class FrameInfo:
    def __init__(self, arg: bytes, /) -> None: ...

    @property
    def num_outputs(self) -> int: ...

    def output_type(self, index: int) -> Type: ...

    def output_content_size(self, index: int) -> int: ...

class MultiInputCodecDescription:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, *, id: int, name: str | None = None, input_types: Sequence[Type], last_input_is_variable: bool = False, singleton_output_types: Sequence[Type], variable_output_types: Sequence[Type] = []) -> None: ...

    @property
    def id(self) -> int: ...

    @id.setter
    def id(self, arg: int, /) -> None: ...

    @property
    def name(self) -> str | None: ...

    @name.setter
    def name(self, arg: str, /) -> None: ...

    @property
    def input_types(self) -> list[Type]: ...

    @input_types.setter
    def input_types(self, arg: Sequence[Type], /) -> None: ...

    @property
    def last_input_is_variable(self) -> bool: ...

    @last_input_is_variable.setter
    def last_input_is_variable(self, arg: bool, /) -> None: ...

    @property
    def singleton_output_types(self) -> list[Type]: ...

    @singleton_output_types.setter
    def singleton_output_types(self, arg: Sequence[Type], /) -> None: ...

    @property
    def variable_output_types(self) -> list[Type]: ...

    @variable_output_types.setter
    def variable_output_types(self, arg: Sequence[Type], /) -> None: ...

class EncoderState:
    @property
    def inputs(self) -> list[Input]: ...

    def create_output(self, arg0: int, arg1: int, arg2: int, /) -> Output: ...

    def get_cparam(self, arg: CParam, /) -> int: ...

    def get_local_int_param(self, arg: int, /) -> int | None: ...

    def get_local_param(self, arg: int, /) -> bytes | None: ...

    def send_codec_header(self, arg: bytes, /) -> None: ...

class CustomEncoder:
    def __init__(self) -> None: ...

    def multi_input_description(self) -> MultiInputCodecDescription: ...

    def encode(self, arg: EncoderState, /) -> None: ...

class DecoderState:
    @property
    def singleton_inputs(self) -> list[Input]: ...

    @property
    def variable_inputs(self) -> list[Input]: ...

    def create_output(self, arg0: int, arg1: int, arg2: int, /) -> Output: ...

    @property
    def codec_header(self) -> bytes: ...

class CustomDecoder:
    def __init__(self) -> None: ...

    def multi_input_description(self) -> MultiInputCodecDescription: ...

    def decode(self, arg: DecoderState, /) -> None: ...

class Edge:
    @property
    def input(self) -> Input: ...

    def run_node(self, node: NodeID, *, name: str | None = None, params: LocalParams | None = None) -> list[Edge]: ...

    @staticmethod
    def run_multi_input_node(inputs: Sequence[Edge], node: NodeID, *, name: str | None = None, local_params: LocalParams | None = None) -> list[Edge]: ...

    def set_int_metadata(self, key: int, value: int) -> None: ...

    def set_destination(self, graph: GraphID, *, name: str | None = None, custom_graphs: Sequence[GraphID] | None = None, custom_nodes: Sequence[NodeID] | None = None, local_params: LocalParams | None = None) -> None: ...

    @staticmethod
    def set_multi_input_destination(inputs: Sequence[Edge], graph: GraphID, *, name: str | None = None, custom_graphs: Sequence[GraphID] | None = None, custom_nodes: Sequence[NodeID] | None = None, local_params: LocalParams | None = None) -> None: ...

class GraphState:
    @property
    def edges(self) -> list[Edge]: ...

    @property
    def custom_graphs(self) -> list[GraphID]: ...

    @property
    def custom_nodes(self) -> list[NodeID]: ...

    def get_cparam(self, param: CParam) -> int: ...

    def get_local_int_param(self, key: int) -> int | None: ...

    def get_local_param(self, key: int) -> bytes | None: ...

    def is_node_supported(self, node: NodeID) -> bool: ...

class FunctionGraphDescription:
    def __init__(self, *, name: str | None = None, input_type_masks: Sequence[TypeMask], last_input_is_variable: bool = False, custom_graphs: Sequence[GraphID] = [], custom_nodes: Sequence[NodeID] = [], local_params: LocalParams | None = None) -> None: ...

    @property
    def name(self) -> str | None: ...

    @name.setter
    def name(self, arg: str, /) -> None: ...

    @property
    def input_type_masks(self) -> list[TypeMask]: ...

    @input_type_masks.setter
    def input_type_masks(self, arg: Sequence[TypeMask], /) -> None: ...

    @property
    def last_input_is_variable(self) -> bool: ...

    @last_input_is_variable.setter
    def last_input_is_variable(self, arg: bool, /) -> None: ...

    @property
    def custom_graphs(self) -> list[GraphID]: ...

    @custom_graphs.setter
    def custom_graphs(self, arg: Sequence[GraphID], /) -> None: ...

    @property
    def custom_nodes(self) -> list[NodeID]: ...

    @custom_nodes.setter
    def custom_nodes(self, arg: Sequence[NodeID], /) -> None: ...

    @property
    def local_params(self) -> LocalParams | None: ...

    @local_params.setter
    def local_params(self, arg: LocalParams, /) -> None: ...

class FunctionGraph:
    def __init__(self) -> None: ...

    def function_graph_description(self) -> FunctionGraphDescription: ...

    def graph(self, state: GraphState) -> None: ...

class SelectorState:
    @property
    def custom_graphs(self) -> list[GraphID]: ...

    def get_cparam(self, param: CParam) -> int: ...

    def get_local_int_param(self, key: int) -> int | None: ...

    def get_local_param(self, key: int) -> bytes | None: ...

    def parameterize_destination(self, *, name: str | None = None, custom_graphs: Sequence[GraphID] | None = None, custom_nodes: Sequence[NodeID] | None = None, local_params: LocalParams | None = None) -> None: ...

class SelectorDescription:
    def __init__(self, *, name: str | None = None, input_type_mask: TypeMask, custom_graphs: Sequence[GraphID] = [], local_params: LocalParams | None = None) -> None: ...

    @property
    def name(self) -> str | None: ...

    @name.setter
    def name(self, arg: str, /) -> None: ...

    @property
    def input_type_masks(self) -> TypeMask: ...

    @input_type_masks.setter
    def input_type_masks(self, arg: TypeMask, /) -> None: ...

    @property
    def custom_graphs(self) -> list[GraphID]: ...

    @custom_graphs.setter
    def custom_graphs(self, arg: Sequence[GraphID], /) -> None: ...

    @property
    def local_params(self) -> LocalParams | None: ...

    @local_params.setter
    def local_params(self, arg: LocalParams, /) -> None: ...

class Selector:
    def __init__(self) -> None: ...

    def selector_description(self) -> SelectorDescription: ...

    def select(self, state: SelectorState, input: Input) -> GraphID: ...

class LocalParams:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, params: Mapping[int, int | bytes]) -> None: ...

    def add_param(self, key: int, value: int | bytes) -> None: ...

    def get_params(self) -> dict[int, int | bytes]: ...
