"""Provides classes for saving data generated by a process model."""

from abc import ABC, abstractmethod
import asyncio
from asyncio.tasks import Task
from collections import defaultdict, deque
import typing as _t

from plugboard.component import Component
from plugboard.component.io_controller import IOController
from plugboard.exceptions import IOSetupError
from plugboard.schemas import ComponentArgsDict


class DataWriterArgsSpec(ComponentArgsDict):
    """Specification of the `DataWriter` constructor arguments.

    Attributes:
        field_names: The names of the fields to write to the data source.
        chunk_size: Optional; The size of the data chunk to read from the DataFrame.
    """

    field_names: list[str]
    chunk_size: _t.NotRequired[int | None]


class DataWriter(Component, ABC):
    """Abstract base class for writing data."""

    io = IOController()

    def __init__(
        self,
        field_names: list[str],
        chunk_size: _t.Optional[int] = None,
        **kwargs: _t.Unpack[ComponentArgsDict],
    ) -> None:
        """Instantiates the `DataWriter`.

        Args:
            field_names: The names of the fields to write to the data source.
            chunk_size: The size of the data chunk to read from the DataFrame.
            **kwargs: Additional keyword arguments for [`Component`][plugboard.component.Component].
        """
        super().__init__(**kwargs)
        self._buffer: dict[str, deque] = defaultdict(deque)
        self._chunk_size = chunk_size
        self.io = IOController(
            inputs=field_names,
            outputs=None,
            input_events=self.__class__.io.input_events,
            output_events=self.__class__.io.output_events,
            namespace=self.name,
            component=self,
        )
        self._task: _t.Optional[Task] = None

    def __init_subclass__(cls, *args: _t.Any, **kwargs: _t.Any) -> None:
        try:
            return super().__init_subclass__(*args, **kwargs)
        except IOSetupError:
            # Concrete subclasses of the abstract data io classes represent a special case for io
            # setup. They receive io args at run time, not declaration time, so skip error.
            pass

    @abstractmethod
    async def _save(self, data: _t.Any) -> None:
        """Saves a chunk of data to the underlying source."""
        pass

    @abstractmethod
    async def _convert(self, data: dict[str, deque]) -> _t.Any:
        """Converts the data from `dict[str, deque]` into a format required for saving."""
        pass

    def _bind_inputs(self) -> None:
        """Binds input fields to component fields and append to internal buffer."""
        super()._bind_inputs()
        for field in self.io.inputs:
            value = getattr(self, field, None)
            self._buffer[field].append(value)

    async def _save_chunk(self) -> None:
        """Write data from the buffer."""
        if self._task is not None:
            await self._task
        # Create task to save next chunk of data
        chunk = await self._convert(self._buffer)
        self._task = asyncio.create_task(self._save(chunk))
        self._buffer = defaultdict(deque)

    async def step(self) -> None:
        """Trigger save when buffer is at target size."""
        if self._chunk_size and len(self._buffer[self.io.inputs[0]]) >= self._chunk_size:
            await self._save_chunk()

    async def run(self) -> None:
        """Runs the `DataWriter`."""
        await super().run()
        # Flush any remaining data in the buffer after completion
        await self._save_chunk()
        if self._task is not None:
            await self._task
