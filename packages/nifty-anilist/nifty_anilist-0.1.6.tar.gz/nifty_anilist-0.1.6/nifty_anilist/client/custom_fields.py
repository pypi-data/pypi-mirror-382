# Generated by ariadne-codegen

from typing import Any, Dict, List, Optional, Union

from . import (
    ActivitySort,
    ActivityType,
    AiringSort,
    CharacterRole,
    CharacterSort,
    LikeableType,
    MediaFormat,
    MediaListSort,
    MediaListStatus,
    MediaSeason,
    MediaSort,
    MediaSource,
    MediaStatus,
    MediaTrendSort,
    MediaType,
    NotificationType,
    RecommendationSort,
    ReviewSort,
    ScoreFormat,
    SiteTrendSort,
    StaffLanguage,
    StaffSort,
    StudioSort,
    ThreadCommentSort,
    ThreadSort,
    UserSort,
    UserStatisticsSort,
)
from .base_operation import GraphQLField
from .custom_typing_fields import (
    ActivityLikeNotificationGraphQLField,
    ActivityMentionNotificationGraphQLField,
    ActivityMessageNotificationGraphQLField,
    ActivityReplyGraphQLField,
    ActivityReplyLikeNotificationGraphQLField,
    ActivityReplyNotificationGraphQLField,
    ActivityReplySubscribedNotificationGraphQLField,
    ActivityUnionUnion,
    AiringNotificationGraphQLField,
    AiringProgressionGraphQLField,
    AiringScheduleConnectionGraphQLField,
    AiringScheduleEdgeGraphQLField,
    AiringScheduleGraphQLField,
    AniChartUserGraphQLField,
    CharacterConnectionGraphQLField,
    CharacterEdgeGraphQLField,
    CharacterGraphQLField,
    CharacterImageGraphQLField,
    CharacterNameGraphQLField,
    DeletedGraphQLField,
    FavouritesGraphQLField,
    FollowingNotificationGraphQLField,
    FormatStatsGraphQLField,
    FuzzyDateGraphQLField,
    GenreStatsGraphQLField,
    ListActivityGraphQLField,
    ListActivityOptionGraphQLField,
    ListScoreStatsGraphQLField,
    MediaConnectionGraphQLField,
    MediaCoverImageGraphQLField,
    MediaDataChangeNotificationGraphQLField,
    MediaDeletionNotificationGraphQLField,
    MediaEdgeGraphQLField,
    MediaExternalLinkGraphQLField,
    MediaGraphQLField,
    MediaListCollectionGraphQLField,
    MediaListGraphQLField,
    MediaListGroupGraphQLField,
    MediaListOptionsGraphQLField,
    MediaListTypeOptionsGraphQLField,
    MediaMergeNotificationGraphQLField,
    MediaRankGraphQLField,
    MediaStatsGraphQLField,
    MediaStreamingEpisodeGraphQLField,
    MediaTagGraphQLField,
    MediaTitleGraphQLField,
    MediaTrailerGraphQLField,
    MediaTrendConnectionGraphQLField,
    MediaTrendEdgeGraphQLField,
    MediaTrendGraphQLField,
    MessageActivityGraphQLField,
    NotificationOptionGraphQLField,
    NotificationUnionUnion,
    PageGraphQLField,
    PageInfoGraphQLField,
    ParsedMarkdownGraphQLField,
    RecommendationConnectionGraphQLField,
    RecommendationEdgeGraphQLField,
    RecommendationGraphQLField,
    RelatedMediaAdditionNotificationGraphQLField,
    ReviewConnectionGraphQLField,
    ReviewEdgeGraphQLField,
    ReviewGraphQLField,
    ScoreDistributionGraphQLField,
    SiteStatisticsGraphQLField,
    SiteTrendConnectionGraphQLField,
    SiteTrendEdgeGraphQLField,
    SiteTrendGraphQLField,
    StaffConnectionGraphQLField,
    StaffEdgeGraphQLField,
    StaffGraphQLField,
    StaffImageGraphQLField,
    StaffNameGraphQLField,
    StaffRoleTypeGraphQLField,
    StaffStatsGraphQLField,
    StatusDistributionGraphQLField,
    StudioConnectionGraphQLField,
    StudioEdgeGraphQLField,
    StudioGraphQLField,
    StudioStatsGraphQLField,
    TagStatsGraphQLField,
    TextActivityGraphQLField,
    ThreadCategoryGraphQLField,
    ThreadCommentGraphQLField,
    ThreadCommentLikeNotificationGraphQLField,
    ThreadCommentMentionNotificationGraphQLField,
    ThreadCommentReplyNotificationGraphQLField,
    ThreadCommentSubscribedNotificationGraphQLField,
    ThreadGraphQLField,
    ThreadLikeNotificationGraphQLField,
    UserActivityHistoryGraphQLField,
    UserAvatarGraphQLField,
    UserCountryStatisticGraphQLField,
    UserFormatStatisticGraphQLField,
    UserGenreStatisticGraphQLField,
    UserGraphQLField,
    UserLengthStatisticGraphQLField,
    UserOptionsGraphQLField,
    UserPreviousNameGraphQLField,
    UserReleaseYearStatisticGraphQLField,
    UserScoreStatisticGraphQLField,
    UserStaffStatisticGraphQLField,
    UserStartYearStatisticGraphQLField,
    UserStatisticsGraphQLField,
    UserStatisticTypesGraphQLField,
    UserStatsGraphQLField,
    UserStatusStatisticGraphQLField,
    UserStudioStatisticGraphQLField,
    UserTagStatisticGraphQLField,
    UserVoiceActorStatisticGraphQLField,
    YearStatsGraphQLField,
)


class ActivityLikeNotificationFields(GraphQLField):
    id: "ActivityLikeNotificationGraphQLField" = ActivityLikeNotificationGraphQLField(
        "id"
    )
    user_id: "ActivityLikeNotificationGraphQLField" = (
        ActivityLikeNotificationGraphQLField("userId")
    )
    type: "ActivityLikeNotificationGraphQLField" = ActivityLikeNotificationGraphQLField(
        "type"
    )
    activity_id: "ActivityLikeNotificationGraphQLField" = (
        ActivityLikeNotificationGraphQLField("activityId")
    )
    context: "ActivityLikeNotificationGraphQLField" = (
        ActivityLikeNotificationGraphQLField("context")
    )
    created_at: "ActivityLikeNotificationGraphQLField" = (
        ActivityLikeNotificationGraphQLField("createdAt")
    )
    activity: "ActivityUnionUnion" = ActivityUnionUnion("activity")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ActivityLikeNotificationGraphQLField, "ActivityUnionUnion", "UserFields"
        ],
    ) -> "ActivityLikeNotificationFields":
        """Subfields should come from the ActivityLikeNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityLikeNotificationFields":
        self._alias = alias
        return self


class ActivityMentionNotificationFields(GraphQLField):
    id: "ActivityMentionNotificationGraphQLField" = (
        ActivityMentionNotificationGraphQLField("id")
    )
    user_id: "ActivityMentionNotificationGraphQLField" = (
        ActivityMentionNotificationGraphQLField("userId")
    )
    type: "ActivityMentionNotificationGraphQLField" = (
        ActivityMentionNotificationGraphQLField("type")
    )
    activity_id: "ActivityMentionNotificationGraphQLField" = (
        ActivityMentionNotificationGraphQLField("activityId")
    )
    context: "ActivityMentionNotificationGraphQLField" = (
        ActivityMentionNotificationGraphQLField("context")
    )
    created_at: "ActivityMentionNotificationGraphQLField" = (
        ActivityMentionNotificationGraphQLField("createdAt")
    )
    activity: "ActivityUnionUnion" = ActivityUnionUnion("activity")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ActivityMentionNotificationGraphQLField, "ActivityUnionUnion", "UserFields"
        ],
    ) -> "ActivityMentionNotificationFields":
        """Subfields should come from the ActivityMentionNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityMentionNotificationFields":
        self._alias = alias
        return self


class ActivityMessageNotificationFields(GraphQLField):
    id: "ActivityMessageNotificationGraphQLField" = (
        ActivityMessageNotificationGraphQLField("id")
    )
    user_id: "ActivityMessageNotificationGraphQLField" = (
        ActivityMessageNotificationGraphQLField("userId")
    )
    type: "ActivityMessageNotificationGraphQLField" = (
        ActivityMessageNotificationGraphQLField("type")
    )
    activity_id: "ActivityMessageNotificationGraphQLField" = (
        ActivityMessageNotificationGraphQLField("activityId")
    )
    context: "ActivityMessageNotificationGraphQLField" = (
        ActivityMessageNotificationGraphQLField("context")
    )
    created_at: "ActivityMessageNotificationGraphQLField" = (
        ActivityMessageNotificationGraphQLField("createdAt")
    )

    @classmethod
    def message(cls) -> "MessageActivityFields":
        return MessageActivityFields("message")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ActivityMessageNotificationGraphQLField,
            "MessageActivityFields",
            "UserFields",
        ],
    ) -> "ActivityMessageNotificationFields":
        """Subfields should come from the ActivityMessageNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityMessageNotificationFields":
        self._alias = alias
        return self


class ActivityReplyFields(GraphQLField):
    id: "ActivityReplyGraphQLField" = ActivityReplyGraphQLField("id")
    user_id: "ActivityReplyGraphQLField" = ActivityReplyGraphQLField("userId")
    activity_id: "ActivityReplyGraphQLField" = ActivityReplyGraphQLField("activityId")

    @classmethod
    def text(cls, *, as_html: Optional[bool] = None) -> "ActivityReplyGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ActivityReplyGraphQLField("text", arguments=cleared_arguments)

    like_count: "ActivityReplyGraphQLField" = ActivityReplyGraphQLField("likeCount")
    is_liked: "ActivityReplyGraphQLField" = ActivityReplyGraphQLField("isLiked")
    created_at: "ActivityReplyGraphQLField" = ActivityReplyGraphQLField("createdAt")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    @classmethod
    def likes(cls) -> "UserFields":
        return UserFields("likes")

    def fields(
        self, *subfields: Union[ActivityReplyGraphQLField, "UserFields"]
    ) -> "ActivityReplyFields":
        """Subfields should come from the ActivityReplyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityReplyFields":
        self._alias = alias
        return self


class ActivityReplyLikeNotificationFields(GraphQLField):
    id: "ActivityReplyLikeNotificationGraphQLField" = (
        ActivityReplyLikeNotificationGraphQLField("id")
    )
    user_id: "ActivityReplyLikeNotificationGraphQLField" = (
        ActivityReplyLikeNotificationGraphQLField("userId")
    )
    type: "ActivityReplyLikeNotificationGraphQLField" = (
        ActivityReplyLikeNotificationGraphQLField("type")
    )
    activity_id: "ActivityReplyLikeNotificationGraphQLField" = (
        ActivityReplyLikeNotificationGraphQLField("activityId")
    )
    context: "ActivityReplyLikeNotificationGraphQLField" = (
        ActivityReplyLikeNotificationGraphQLField("context")
    )
    created_at: "ActivityReplyLikeNotificationGraphQLField" = (
        ActivityReplyLikeNotificationGraphQLField("createdAt")
    )
    activity: "ActivityUnionUnion" = ActivityUnionUnion("activity")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ActivityReplyLikeNotificationGraphQLField,
            "ActivityUnionUnion",
            "UserFields",
        ],
    ) -> "ActivityReplyLikeNotificationFields":
        """Subfields should come from the ActivityReplyLikeNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityReplyLikeNotificationFields":
        self._alias = alias
        return self


class ActivityReplyNotificationFields(GraphQLField):
    id: "ActivityReplyNotificationGraphQLField" = ActivityReplyNotificationGraphQLField(
        "id"
    )
    user_id: "ActivityReplyNotificationGraphQLField" = (
        ActivityReplyNotificationGraphQLField("userId")
    )
    type: "ActivityReplyNotificationGraphQLField" = (
        ActivityReplyNotificationGraphQLField("type")
    )
    activity_id: "ActivityReplyNotificationGraphQLField" = (
        ActivityReplyNotificationGraphQLField("activityId")
    )
    context: "ActivityReplyNotificationGraphQLField" = (
        ActivityReplyNotificationGraphQLField("context")
    )
    created_at: "ActivityReplyNotificationGraphQLField" = (
        ActivityReplyNotificationGraphQLField("createdAt")
    )
    activity: "ActivityUnionUnion" = ActivityUnionUnion("activity")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ActivityReplyNotificationGraphQLField, "ActivityUnionUnion", "UserFields"
        ],
    ) -> "ActivityReplyNotificationFields":
        """Subfields should come from the ActivityReplyNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityReplyNotificationFields":
        self._alias = alias
        return self


class ActivityReplySubscribedNotificationFields(GraphQLField):
    id: "ActivityReplySubscribedNotificationGraphQLField" = (
        ActivityReplySubscribedNotificationGraphQLField("id")
    )
    user_id: "ActivityReplySubscribedNotificationGraphQLField" = (
        ActivityReplySubscribedNotificationGraphQLField("userId")
    )
    type: "ActivityReplySubscribedNotificationGraphQLField" = (
        ActivityReplySubscribedNotificationGraphQLField("type")
    )
    activity_id: "ActivityReplySubscribedNotificationGraphQLField" = (
        ActivityReplySubscribedNotificationGraphQLField("activityId")
    )
    context: "ActivityReplySubscribedNotificationGraphQLField" = (
        ActivityReplySubscribedNotificationGraphQLField("context")
    )
    created_at: "ActivityReplySubscribedNotificationGraphQLField" = (
        ActivityReplySubscribedNotificationGraphQLField("createdAt")
    )
    activity: "ActivityUnionUnion" = ActivityUnionUnion("activity")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ActivityReplySubscribedNotificationGraphQLField,
            "ActivityUnionUnion",
            "UserFields",
        ],
    ) -> "ActivityReplySubscribedNotificationFields":
        """Subfields should come from the ActivityReplySubscribedNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ActivityReplySubscribedNotificationFields":
        self._alias = alias
        return self


class AiringNotificationFields(GraphQLField):
    id: "AiringNotificationGraphQLField" = AiringNotificationGraphQLField("id")
    type: "AiringNotificationGraphQLField" = AiringNotificationGraphQLField("type")
    anime_id: "AiringNotificationGraphQLField" = AiringNotificationGraphQLField(
        "animeId"
    )
    episode: "AiringNotificationGraphQLField" = AiringNotificationGraphQLField(
        "episode"
    )
    contexts: "AiringNotificationGraphQLField" = AiringNotificationGraphQLField(
        "contexts"
    )
    created_at: "AiringNotificationGraphQLField" = AiringNotificationGraphQLField(
        "createdAt"
    )

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    def fields(
        self, *subfields: Union[AiringNotificationGraphQLField, "MediaFields"]
    ) -> "AiringNotificationFields":
        """Subfields should come from the AiringNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AiringNotificationFields":
        self._alias = alias
        return self


class AiringProgressionFields(GraphQLField):
    episode: "AiringProgressionGraphQLField" = AiringProgressionGraphQLField("episode")
    score: "AiringProgressionGraphQLField" = AiringProgressionGraphQLField("score")
    watching: "AiringProgressionGraphQLField" = AiringProgressionGraphQLField(
        "watching"
    )

    def fields(
        self, *subfields: AiringProgressionGraphQLField
    ) -> "AiringProgressionFields":
        """Subfields should come from the AiringProgressionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AiringProgressionFields":
        self._alias = alias
        return self


class AiringScheduleFields(GraphQLField):
    id: "AiringScheduleGraphQLField" = AiringScheduleGraphQLField("id")
    airing_at: "AiringScheduleGraphQLField" = AiringScheduleGraphQLField("airingAt")
    time_until_airing: "AiringScheduleGraphQLField" = AiringScheduleGraphQLField(
        "timeUntilAiring"
    )
    episode: "AiringScheduleGraphQLField" = AiringScheduleGraphQLField("episode")
    media_id: "AiringScheduleGraphQLField" = AiringScheduleGraphQLField("mediaId")

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    def fields(
        self, *subfields: Union[AiringScheduleGraphQLField, "MediaFields"]
    ) -> "AiringScheduleFields":
        """Subfields should come from the AiringScheduleFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AiringScheduleFields":
        self._alias = alias
        return self


class AiringScheduleConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "AiringScheduleEdgeFields":
        return AiringScheduleEdgeFields("edges")

    @classmethod
    def nodes(cls) -> "AiringScheduleFields":
        return AiringScheduleFields("nodes")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    def fields(
        self,
        *subfields: Union[
            AiringScheduleConnectionGraphQLField,
            "AiringScheduleEdgeFields",
            "AiringScheduleFields",
            "PageInfoFields",
        ],
    ) -> "AiringScheduleConnectionFields":
        """Subfields should come from the AiringScheduleConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AiringScheduleConnectionFields":
        self._alias = alias
        return self


class AiringScheduleEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "AiringScheduleFields":
        return AiringScheduleFields("node")

    id: "AiringScheduleEdgeGraphQLField" = AiringScheduleEdgeGraphQLField("id")

    def fields(
        self, *subfields: Union[AiringScheduleEdgeGraphQLField, "AiringScheduleFields"]
    ) -> "AiringScheduleEdgeFields":
        """Subfields should come from the AiringScheduleEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AiringScheduleEdgeFields":
        self._alias = alias
        return self


class AniChartUserFields(GraphQLField):
    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    settings: "AniChartUserGraphQLField" = AniChartUserGraphQLField("settings")
    highlights: "AniChartUserGraphQLField" = AniChartUserGraphQLField("highlights")

    def fields(
        self, *subfields: Union[AniChartUserGraphQLField, "UserFields"]
    ) -> "AniChartUserFields":
        """Subfields should come from the AniChartUserFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AniChartUserFields":
        self._alias = alias
        return self


class CharacterFields(GraphQLField):
    id: "CharacterGraphQLField" = CharacterGraphQLField("id")

    @classmethod
    def name(cls) -> "CharacterNameFields":
        return CharacterNameFields("name")

    @classmethod
    def image(cls) -> "CharacterImageFields":
        return CharacterImageFields("image")

    @classmethod
    def description(cls, *, as_html: Optional[bool] = None) -> "CharacterGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CharacterGraphQLField("description", arguments=cleared_arguments)

    gender: "CharacterGraphQLField" = CharacterGraphQLField("gender")

    @classmethod
    def date_of_birth(cls) -> "FuzzyDateFields":
        return FuzzyDateFields("dateOfBirth")

    age: "CharacterGraphQLField" = CharacterGraphQLField("age")
    blood_type: "CharacterGraphQLField" = CharacterGraphQLField("bloodType")
    is_favourite: "CharacterGraphQLField" = CharacterGraphQLField("isFavourite")
    is_favourite_blocked: "CharacterGraphQLField" = CharacterGraphQLField(
        "isFavouriteBlocked"
    )
    site_url: "CharacterGraphQLField" = CharacterGraphQLField("siteUrl")

    @classmethod
    def media(
        cls,
        *,
        sort: Optional[List[MediaSort]] = None,
        type: Optional[MediaType] = None,
        on_list: Optional[bool] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "MediaConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[MediaSort]", "value": sort},
            "type": {"type": "MediaType", "value": type},
            "onList": {"type": "Boolean", "value": on_list},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaConnectionFields("media", arguments=cleared_arguments)

    updated_at: "CharacterGraphQLField" = CharacterGraphQLField("updatedAt")
    favourites: "CharacterGraphQLField" = CharacterGraphQLField("favourites")
    mod_notes: "CharacterGraphQLField" = CharacterGraphQLField("modNotes")

    def fields(
        self,
        *subfields: Union[
            CharacterGraphQLField,
            "CharacterImageFields",
            "CharacterNameFields",
            "FuzzyDateFields",
            "MediaConnectionFields",
        ],
    ) -> "CharacterFields":
        """Subfields should come from the CharacterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CharacterFields":
        self._alias = alias
        return self


class CharacterConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "CharacterEdgeFields":
        return CharacterEdgeFields("edges")

    @classmethod
    def nodes(cls) -> "CharacterFields":
        return CharacterFields("nodes")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    def fields(
        self,
        *subfields: Union[
            CharacterConnectionGraphQLField,
            "CharacterEdgeFields",
            "CharacterFields",
            "PageInfoFields",
        ],
    ) -> "CharacterConnectionFields":
        """Subfields should come from the CharacterConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CharacterConnectionFields":
        self._alias = alias
        return self


class CharacterEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "CharacterFields":
        return CharacterFields("node")

    id: "CharacterEdgeGraphQLField" = CharacterEdgeGraphQLField("id")
    role: "CharacterEdgeGraphQLField" = CharacterEdgeGraphQLField("role")
    name: "CharacterEdgeGraphQLField" = CharacterEdgeGraphQLField("name")

    @classmethod
    def voice_actors(
        cls,
        *,
        language: Optional[StaffLanguage] = None,
        sort: Optional[List[StaffSort]] = None,
    ) -> "StaffFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "language": {"type": "StaffLanguage", "value": language},
            "sort": {"type": "[StaffSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StaffFields("voiceActors", arguments=cleared_arguments)

    @classmethod
    def voice_actor_roles(
        cls,
        *,
        language: Optional[StaffLanguage] = None,
        sort: Optional[List[StaffSort]] = None,
    ) -> "StaffRoleTypeFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "language": {"type": "StaffLanguage", "value": language},
            "sort": {"type": "[StaffSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StaffRoleTypeFields("voiceActorRoles", arguments=cleared_arguments)

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    favourite_order: "CharacterEdgeGraphQLField" = CharacterEdgeGraphQLField(
        "favouriteOrder"
    )

    def fields(
        self,
        *subfields: Union[
            CharacterEdgeGraphQLField,
            "CharacterFields",
            "MediaFields",
            "StaffFields",
            "StaffRoleTypeFields",
        ],
    ) -> "CharacterEdgeFields":
        """Subfields should come from the CharacterEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CharacterEdgeFields":
        self._alias = alias
        return self


class CharacterImageFields(GraphQLField):
    large: "CharacterImageGraphQLField" = CharacterImageGraphQLField("large")
    medium: "CharacterImageGraphQLField" = CharacterImageGraphQLField("medium")

    def fields(self, *subfields: CharacterImageGraphQLField) -> "CharacterImageFields":
        """Subfields should come from the CharacterImageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CharacterImageFields":
        self._alias = alias
        return self


class CharacterNameFields(GraphQLField):
    first: "CharacterNameGraphQLField" = CharacterNameGraphQLField("first")
    middle: "CharacterNameGraphQLField" = CharacterNameGraphQLField("middle")
    last: "CharacterNameGraphQLField" = CharacterNameGraphQLField("last")
    full: "CharacterNameGraphQLField" = CharacterNameGraphQLField("full")
    native: "CharacterNameGraphQLField" = CharacterNameGraphQLField("native")
    alternative: "CharacterNameGraphQLField" = CharacterNameGraphQLField("alternative")
    alternative_spoiler: "CharacterNameGraphQLField" = CharacterNameGraphQLField(
        "alternativeSpoiler"
    )
    user_preferred: "CharacterNameGraphQLField" = CharacterNameGraphQLField(
        "userPreferred"
    )

    def fields(self, *subfields: CharacterNameGraphQLField) -> "CharacterNameFields":
        """Subfields should come from the CharacterNameFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CharacterNameFields":
        self._alias = alias
        return self


class DeletedFields(GraphQLField):
    deleted: "DeletedGraphQLField" = DeletedGraphQLField("deleted")

    def fields(self, *subfields: DeletedGraphQLField) -> "DeletedFields":
        """Subfields should come from the DeletedFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeletedFields":
        self._alias = alias
        return self


class FavouritesFields(GraphQLField):
    @classmethod
    def anime(
        cls, *, page: Optional[int] = None, per_page: Optional[int] = None
    ) -> "MediaConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaConnectionFields("anime", arguments=cleared_arguments)

    @classmethod
    def manga(
        cls, *, page: Optional[int] = None, per_page: Optional[int] = None
    ) -> "MediaConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaConnectionFields("manga", arguments=cleared_arguments)

    @classmethod
    def characters(
        cls, *, page: Optional[int] = None, per_page: Optional[int] = None
    ) -> "CharacterConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CharacterConnectionFields("characters", arguments=cleared_arguments)

    @classmethod
    def staff(
        cls, *, page: Optional[int] = None, per_page: Optional[int] = None
    ) -> "StaffConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StaffConnectionFields("staff", arguments=cleared_arguments)

    @classmethod
    def studios(
        cls, *, page: Optional[int] = None, per_page: Optional[int] = None
    ) -> "StudioConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StudioConnectionFields("studios", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            FavouritesGraphQLField,
            "CharacterConnectionFields",
            "MediaConnectionFields",
            "StaffConnectionFields",
            "StudioConnectionFields",
        ],
    ) -> "FavouritesFields":
        """Subfields should come from the FavouritesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FavouritesFields":
        self._alias = alias
        return self


class FollowingNotificationFields(GraphQLField):
    id: "FollowingNotificationGraphQLField" = FollowingNotificationGraphQLField("id")
    user_id: "FollowingNotificationGraphQLField" = FollowingNotificationGraphQLField(
        "userId"
    )
    type: "FollowingNotificationGraphQLField" = FollowingNotificationGraphQLField(
        "type"
    )
    context: "FollowingNotificationGraphQLField" = FollowingNotificationGraphQLField(
        "context"
    )
    created_at: "FollowingNotificationGraphQLField" = FollowingNotificationGraphQLField(
        "createdAt"
    )

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self, *subfields: Union[FollowingNotificationGraphQLField, "UserFields"]
    ) -> "FollowingNotificationFields":
        """Subfields should come from the FollowingNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FollowingNotificationFields":
        self._alias = alias
        return self


class FormatStatsFields(GraphQLField):
    format: "FormatStatsGraphQLField" = FormatStatsGraphQLField("format")
    amount: "FormatStatsGraphQLField" = FormatStatsGraphQLField("amount")

    def fields(self, *subfields: FormatStatsGraphQLField) -> "FormatStatsFields":
        """Subfields should come from the FormatStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FormatStatsFields":
        self._alias = alias
        return self


class FuzzyDateFields(GraphQLField):
    year: "FuzzyDateGraphQLField" = FuzzyDateGraphQLField("year")
    month: "FuzzyDateGraphQLField" = FuzzyDateGraphQLField("month")
    day: "FuzzyDateGraphQLField" = FuzzyDateGraphQLField("day")

    def fields(self, *subfields: FuzzyDateGraphQLField) -> "FuzzyDateFields":
        """Subfields should come from the FuzzyDateFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FuzzyDateFields":
        self._alias = alias
        return self


class GenreStatsFields(GraphQLField):
    genre: "GenreStatsGraphQLField" = GenreStatsGraphQLField("genre")
    amount: "GenreStatsGraphQLField" = GenreStatsGraphQLField("amount")
    mean_score: "GenreStatsGraphQLField" = GenreStatsGraphQLField("meanScore")
    time_watched: "GenreStatsGraphQLField" = GenreStatsGraphQLField("timeWatched")

    def fields(self, *subfields: GenreStatsGraphQLField) -> "GenreStatsFields":
        """Subfields should come from the GenreStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GenreStatsFields":
        self._alias = alias
        return self


class ListActivityFields(GraphQLField):
    id: "ListActivityGraphQLField" = ListActivityGraphQLField("id")
    user_id: "ListActivityGraphQLField" = ListActivityGraphQLField("userId")
    type: "ListActivityGraphQLField" = ListActivityGraphQLField("type")
    reply_count: "ListActivityGraphQLField" = ListActivityGraphQLField("replyCount")
    status: "ListActivityGraphQLField" = ListActivityGraphQLField("status")
    progress: "ListActivityGraphQLField" = ListActivityGraphQLField("progress")
    is_locked: "ListActivityGraphQLField" = ListActivityGraphQLField("isLocked")
    is_subscribed: "ListActivityGraphQLField" = ListActivityGraphQLField("isSubscribed")
    like_count: "ListActivityGraphQLField" = ListActivityGraphQLField("likeCount")
    is_liked: "ListActivityGraphQLField" = ListActivityGraphQLField("isLiked")
    is_pinned: "ListActivityGraphQLField" = ListActivityGraphQLField("isPinned")
    site_url: "ListActivityGraphQLField" = ListActivityGraphQLField("siteUrl")
    created_at: "ListActivityGraphQLField" = ListActivityGraphQLField("createdAt")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    @classmethod
    def replies(cls) -> "ActivityReplyFields":
        return ActivityReplyFields("replies")

    @classmethod
    def likes(cls) -> "UserFields":
        return UserFields("likes")

    def fields(
        self,
        *subfields: Union[
            ListActivityGraphQLField, "ActivityReplyFields", "MediaFields", "UserFields"
        ],
    ) -> "ListActivityFields":
        """Subfields should come from the ListActivityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ListActivityFields":
        self._alias = alias
        return self


class ListActivityOptionFields(GraphQLField):
    disabled: "ListActivityOptionGraphQLField" = ListActivityOptionGraphQLField(
        "disabled"
    )
    type: "ListActivityOptionGraphQLField" = ListActivityOptionGraphQLField("type")

    def fields(
        self, *subfields: ListActivityOptionGraphQLField
    ) -> "ListActivityOptionFields":
        """Subfields should come from the ListActivityOptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ListActivityOptionFields":
        self._alias = alias
        return self


class ListScoreStatsFields(GraphQLField):
    mean_score: "ListScoreStatsGraphQLField" = ListScoreStatsGraphQLField("meanScore")
    standard_deviation: "ListScoreStatsGraphQLField" = ListScoreStatsGraphQLField(
        "standardDeviation"
    )

    def fields(self, *subfields: ListScoreStatsGraphQLField) -> "ListScoreStatsFields":
        """Subfields should come from the ListScoreStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ListScoreStatsFields":
        self._alias = alias
        return self


class MediaFields(GraphQLField):
    id: "MediaGraphQLField" = MediaGraphQLField("id")
    id_mal: "MediaGraphQLField" = MediaGraphQLField("idMal")

    @classmethod
    def title(cls) -> "MediaTitleFields":
        return MediaTitleFields("title")

    type: "MediaGraphQLField" = MediaGraphQLField("type")
    format: "MediaGraphQLField" = MediaGraphQLField("format")

    @classmethod
    def status(cls, *, version: Optional[int] = None) -> "MediaGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "version": {"type": "Int", "value": version}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaGraphQLField("status", arguments=cleared_arguments)

    @classmethod
    def description(cls, *, as_html: Optional[bool] = None) -> "MediaGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaGraphQLField("description", arguments=cleared_arguments)

    @classmethod
    def start_date(cls) -> "FuzzyDateFields":
        return FuzzyDateFields("startDate")

    @classmethod
    def end_date(cls) -> "FuzzyDateFields":
        return FuzzyDateFields("endDate")

    season: "MediaGraphQLField" = MediaGraphQLField("season")
    season_year: "MediaGraphQLField" = MediaGraphQLField("seasonYear")
    season_int: "MediaGraphQLField" = MediaGraphQLField("seasonInt")
    episodes: "MediaGraphQLField" = MediaGraphQLField("episodes")
    duration: "MediaGraphQLField" = MediaGraphQLField("duration")
    chapters: "MediaGraphQLField" = MediaGraphQLField("chapters")
    volumes: "MediaGraphQLField" = MediaGraphQLField("volumes")
    country_of_origin: "MediaGraphQLField" = MediaGraphQLField("countryOfOrigin")
    is_licensed: "MediaGraphQLField" = MediaGraphQLField("isLicensed")

    @classmethod
    def source(cls, *, version: Optional[int] = None) -> "MediaGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "version": {"type": "Int", "value": version}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaGraphQLField("source", arguments=cleared_arguments)

    hashtag: "MediaGraphQLField" = MediaGraphQLField("hashtag")

    @classmethod
    def trailer(cls) -> "MediaTrailerFields":
        return MediaTrailerFields("trailer")

    updated_at: "MediaGraphQLField" = MediaGraphQLField("updatedAt")

    @classmethod
    def cover_image(cls) -> "MediaCoverImageFields":
        return MediaCoverImageFields("coverImage")

    banner_image: "MediaGraphQLField" = MediaGraphQLField("bannerImage")
    genres: "MediaGraphQLField" = MediaGraphQLField("genres")
    synonyms: "MediaGraphQLField" = MediaGraphQLField("synonyms")
    average_score: "MediaGraphQLField" = MediaGraphQLField("averageScore")
    mean_score: "MediaGraphQLField" = MediaGraphQLField("meanScore")
    popularity: "MediaGraphQLField" = MediaGraphQLField("popularity")
    is_locked: "MediaGraphQLField" = MediaGraphQLField("isLocked")
    trending: "MediaGraphQLField" = MediaGraphQLField("trending")
    favourites: "MediaGraphQLField" = MediaGraphQLField("favourites")

    @classmethod
    def tags(cls) -> "MediaTagFields":
        return MediaTagFields("tags")

    @classmethod
    def relations(cls) -> "MediaConnectionFields":
        return MediaConnectionFields("relations")

    @classmethod
    def characters(
        cls,
        *,
        sort: Optional[List[CharacterSort]] = None,
        role: Optional[CharacterRole] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "CharacterConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[CharacterSort]", "value": sort},
            "role": {"type": "CharacterRole", "value": role},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CharacterConnectionFields("characters", arguments=cleared_arguments)

    @classmethod
    def staff(
        cls,
        *,
        sort: Optional[List[StaffSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "StaffConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[StaffSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StaffConnectionFields("staff", arguments=cleared_arguments)

    @classmethod
    def studios(
        cls, *, sort: Optional[List[StudioSort]] = None, is_main: Optional[bool] = None
    ) -> "StudioConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[StudioSort]", "value": sort},
            "isMain": {"type": "Boolean", "value": is_main},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StudioConnectionFields("studios", arguments=cleared_arguments)

    is_favourite: "MediaGraphQLField" = MediaGraphQLField("isFavourite")
    is_favourite_blocked: "MediaGraphQLField" = MediaGraphQLField("isFavouriteBlocked")
    is_adult: "MediaGraphQLField" = MediaGraphQLField("isAdult")

    @classmethod
    def next_airing_episode(cls) -> "AiringScheduleFields":
        return AiringScheduleFields("nextAiringEpisode")

    @classmethod
    def airing_schedule(
        cls,
        *,
        not_yet_aired: Optional[bool] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "AiringScheduleConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "notYetAired": {"type": "Boolean", "value": not_yet_aired},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return AiringScheduleConnectionFields(
            "airingSchedule", arguments=cleared_arguments
        )

    @classmethod
    def trends(
        cls,
        *,
        sort: Optional[List[MediaTrendSort]] = None,
        releasing: Optional[bool] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "MediaTrendConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[MediaTrendSort]", "value": sort},
            "releasing": {"type": "Boolean", "value": releasing},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaTrendConnectionFields("trends", arguments=cleared_arguments)

    @classmethod
    def external_links(cls) -> "MediaExternalLinkFields":
        return MediaExternalLinkFields("externalLinks")

    @classmethod
    def streaming_episodes(cls) -> "MediaStreamingEpisodeFields":
        return MediaStreamingEpisodeFields("streamingEpisodes")

    @classmethod
    def rankings(cls) -> "MediaRankFields":
        return MediaRankFields("rankings")

    @classmethod
    def media_list_entry(cls) -> "MediaListFields":
        return MediaListFields("mediaListEntry")

    @classmethod
    def reviews(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[ReviewSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "ReviewConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[ReviewSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ReviewConnectionFields("reviews", arguments=cleared_arguments)

    @classmethod
    def recommendations(
        cls,
        *,
        sort: Optional[List[RecommendationSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "RecommendationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[RecommendationSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecommendationConnectionFields(
            "recommendations", arguments=cleared_arguments
        )

    @classmethod
    def stats(cls) -> "MediaStatsFields":
        return MediaStatsFields("stats")

    site_url: "MediaGraphQLField" = MediaGraphQLField("siteUrl")
    auto_create_forum_thread: "MediaGraphQLField" = MediaGraphQLField(
        "autoCreateForumThread"
    )
    is_recommendation_blocked: "MediaGraphQLField" = MediaGraphQLField(
        "isRecommendationBlocked"
    )
    is_review_blocked: "MediaGraphQLField" = MediaGraphQLField("isReviewBlocked")
    mod_notes: "MediaGraphQLField" = MediaGraphQLField("modNotes")

    def fields(
        self,
        *subfields: Union[
            MediaGraphQLField,
            "AiringScheduleConnectionFields",
            "AiringScheduleFields",
            "CharacterConnectionFields",
            "FuzzyDateFields",
            "MediaConnectionFields",
            "MediaCoverImageFields",
            "MediaExternalLinkFields",
            "MediaListFields",
            "MediaRankFields",
            "MediaStatsFields",
            "MediaStreamingEpisodeFields",
            "MediaTagFields",
            "MediaTitleFields",
            "MediaTrailerFields",
            "MediaTrendConnectionFields",
            "RecommendationConnectionFields",
            "ReviewConnectionFields",
            "StaffConnectionFields",
            "StudioConnectionFields",
        ],
    ) -> "MediaFields":
        """Subfields should come from the MediaFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaFields":
        self._alias = alias
        return self


class MediaConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "MediaEdgeFields":
        return MediaEdgeFields("edges")

    @classmethod
    def nodes(cls) -> "MediaFields":
        return MediaFields("nodes")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    def fields(
        self,
        *subfields: Union[
            MediaConnectionGraphQLField,
            "MediaEdgeFields",
            "MediaFields",
            "PageInfoFields",
        ],
    ) -> "MediaConnectionFields":
        """Subfields should come from the MediaConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaConnectionFields":
        self._alias = alias
        return self


class MediaCoverImageFields(GraphQLField):
    extra_large: "MediaCoverImageGraphQLField" = MediaCoverImageGraphQLField(
        "extraLarge"
    )
    large: "MediaCoverImageGraphQLField" = MediaCoverImageGraphQLField("large")
    medium: "MediaCoverImageGraphQLField" = MediaCoverImageGraphQLField("medium")
    color: "MediaCoverImageGraphQLField" = MediaCoverImageGraphQLField("color")

    def fields(
        self, *subfields: MediaCoverImageGraphQLField
    ) -> "MediaCoverImageFields":
        """Subfields should come from the MediaCoverImageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaCoverImageFields":
        self._alias = alias
        return self


class MediaDataChangeNotificationFields(GraphQLField):
    id: "MediaDataChangeNotificationGraphQLField" = (
        MediaDataChangeNotificationGraphQLField("id")
    )
    type: "MediaDataChangeNotificationGraphQLField" = (
        MediaDataChangeNotificationGraphQLField("type")
    )
    media_id: "MediaDataChangeNotificationGraphQLField" = (
        MediaDataChangeNotificationGraphQLField("mediaId")
    )
    context: "MediaDataChangeNotificationGraphQLField" = (
        MediaDataChangeNotificationGraphQLField("context")
    )
    reason: "MediaDataChangeNotificationGraphQLField" = (
        MediaDataChangeNotificationGraphQLField("reason")
    )
    created_at: "MediaDataChangeNotificationGraphQLField" = (
        MediaDataChangeNotificationGraphQLField("createdAt")
    )

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    def fields(
        self, *subfields: Union[MediaDataChangeNotificationGraphQLField, "MediaFields"]
    ) -> "MediaDataChangeNotificationFields":
        """Subfields should come from the MediaDataChangeNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaDataChangeNotificationFields":
        self._alias = alias
        return self


class MediaDeletionNotificationFields(GraphQLField):
    id: "MediaDeletionNotificationGraphQLField" = MediaDeletionNotificationGraphQLField(
        "id"
    )
    type: "MediaDeletionNotificationGraphQLField" = (
        MediaDeletionNotificationGraphQLField("type")
    )
    deleted_media_title: "MediaDeletionNotificationGraphQLField" = (
        MediaDeletionNotificationGraphQLField("deletedMediaTitle")
    )
    context: "MediaDeletionNotificationGraphQLField" = (
        MediaDeletionNotificationGraphQLField("context")
    )
    reason: "MediaDeletionNotificationGraphQLField" = (
        MediaDeletionNotificationGraphQLField("reason")
    )
    created_at: "MediaDeletionNotificationGraphQLField" = (
        MediaDeletionNotificationGraphQLField("createdAt")
    )

    def fields(
        self, *subfields: MediaDeletionNotificationGraphQLField
    ) -> "MediaDeletionNotificationFields":
        """Subfields should come from the MediaDeletionNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaDeletionNotificationFields":
        self._alias = alias
        return self


class MediaEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "MediaFields":
        return MediaFields("node")

    id: "MediaEdgeGraphQLField" = MediaEdgeGraphQLField("id")

    @classmethod
    def relation_type(cls, *, version: Optional[int] = None) -> "MediaEdgeGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "version": {"type": "Int", "value": version}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaEdgeGraphQLField("relationType", arguments=cleared_arguments)

    is_main_studio: "MediaEdgeGraphQLField" = MediaEdgeGraphQLField("isMainStudio")

    @classmethod
    def characters(cls) -> "CharacterFields":
        return CharacterFields("characters")

    character_role: "MediaEdgeGraphQLField" = MediaEdgeGraphQLField("characterRole")
    character_name: "MediaEdgeGraphQLField" = MediaEdgeGraphQLField("characterName")
    role_notes: "MediaEdgeGraphQLField" = MediaEdgeGraphQLField("roleNotes")
    dub_group: "MediaEdgeGraphQLField" = MediaEdgeGraphQLField("dubGroup")
    staff_role: "MediaEdgeGraphQLField" = MediaEdgeGraphQLField("staffRole")

    @classmethod
    def voice_actors(
        cls,
        *,
        language: Optional[StaffLanguage] = None,
        sort: Optional[List[StaffSort]] = None,
    ) -> "StaffFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "language": {"type": "StaffLanguage", "value": language},
            "sort": {"type": "[StaffSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StaffFields("voiceActors", arguments=cleared_arguments)

    @classmethod
    def voice_actor_roles(
        cls,
        *,
        language: Optional[StaffLanguage] = None,
        sort: Optional[List[StaffSort]] = None,
    ) -> "StaffRoleTypeFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "language": {"type": "StaffLanguage", "value": language},
            "sort": {"type": "[StaffSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StaffRoleTypeFields("voiceActorRoles", arguments=cleared_arguments)

    favourite_order: "MediaEdgeGraphQLField" = MediaEdgeGraphQLField("favouriteOrder")

    def fields(
        self,
        *subfields: Union[
            MediaEdgeGraphQLField,
            "CharacterFields",
            "MediaFields",
            "StaffFields",
            "StaffRoleTypeFields",
        ],
    ) -> "MediaEdgeFields":
        """Subfields should come from the MediaEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaEdgeFields":
        self._alias = alias
        return self


class MediaExternalLinkFields(GraphQLField):
    id: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField("id")
    url: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField("url")
    site: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField("site")
    site_id: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField("siteId")
    type: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField("type")
    language: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField(
        "language"
    )
    color: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField("color")
    icon: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField("icon")
    notes: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField("notes")
    is_disabled: "MediaExternalLinkGraphQLField" = MediaExternalLinkGraphQLField(
        "isDisabled"
    )

    def fields(
        self, *subfields: MediaExternalLinkGraphQLField
    ) -> "MediaExternalLinkFields":
        """Subfields should come from the MediaExternalLinkFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaExternalLinkFields":
        self._alias = alias
        return self


class MediaListFields(GraphQLField):
    id: "MediaListGraphQLField" = MediaListGraphQLField("id")
    user_id: "MediaListGraphQLField" = MediaListGraphQLField("userId")
    media_id: "MediaListGraphQLField" = MediaListGraphQLField("mediaId")
    status: "MediaListGraphQLField" = MediaListGraphQLField("status")

    @classmethod
    def score(cls, *, format: Optional[ScoreFormat] = None) -> "MediaListGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "format": {"type": "ScoreFormat", "value": format}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaListGraphQLField("score", arguments=cleared_arguments)

    progress: "MediaListGraphQLField" = MediaListGraphQLField("progress")
    progress_volumes: "MediaListGraphQLField" = MediaListGraphQLField("progressVolumes")
    repeat: "MediaListGraphQLField" = MediaListGraphQLField("repeat")
    priority: "MediaListGraphQLField" = MediaListGraphQLField("priority")
    private: "MediaListGraphQLField" = MediaListGraphQLField("private")
    notes: "MediaListGraphQLField" = MediaListGraphQLField("notes")
    hidden_from_status_lists: "MediaListGraphQLField" = MediaListGraphQLField(
        "hiddenFromStatusLists"
    )

    @classmethod
    def custom_lists(
        cls, *, as_array: Optional[bool] = None
    ) -> "MediaListGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asArray": {"type": "Boolean", "value": as_array}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaListGraphQLField("customLists", arguments=cleared_arguments)

    advanced_scores: "MediaListGraphQLField" = MediaListGraphQLField("advancedScores")

    @classmethod
    def started_at(cls) -> "FuzzyDateFields":
        return FuzzyDateFields("startedAt")

    @classmethod
    def completed_at(cls) -> "FuzzyDateFields":
        return FuzzyDateFields("completedAt")

    updated_at: "MediaListGraphQLField" = MediaListGraphQLField("updatedAt")
    created_at: "MediaListGraphQLField" = MediaListGraphQLField("createdAt")

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            MediaListGraphQLField, "FuzzyDateFields", "MediaFields", "UserFields"
        ],
    ) -> "MediaListFields":
        """Subfields should come from the MediaListFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaListFields":
        self._alias = alias
        return self


class MediaListCollectionFields(GraphQLField):
    @classmethod
    def lists(cls) -> "MediaListGroupFields":
        return MediaListGroupFields("lists")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    has_next_chunk: "MediaListCollectionGraphQLField" = MediaListCollectionGraphQLField(
        "hasNextChunk"
    )

    @classmethod
    def status_lists(cls, *, as_array: Optional[bool] = None) -> "MediaListFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "asArray": {"type": "Boolean", "value": as_array}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaListFields("statusLists", arguments=cleared_arguments)

    @classmethod
    def custom_lists(cls, *, as_array: Optional[bool] = None) -> "MediaListFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "asArray": {"type": "Boolean", "value": as_array}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaListFields("customLists", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            MediaListCollectionGraphQLField,
            "MediaListFields",
            "MediaListGroupFields",
            "UserFields",
        ],
    ) -> "MediaListCollectionFields":
        """Subfields should come from the MediaListCollectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaListCollectionFields":
        self._alias = alias
        return self


class MediaListGroupFields(GraphQLField):
    @classmethod
    def entries(cls) -> "MediaListFields":
        return MediaListFields("entries")

    name: "MediaListGroupGraphQLField" = MediaListGroupGraphQLField("name")
    is_custom_list: "MediaListGroupGraphQLField" = MediaListGroupGraphQLField(
        "isCustomList"
    )
    is_split_completed_list: "MediaListGroupGraphQLField" = MediaListGroupGraphQLField(
        "isSplitCompletedList"
    )
    status: "MediaListGroupGraphQLField" = MediaListGroupGraphQLField("status")

    def fields(
        self, *subfields: Union[MediaListGroupGraphQLField, "MediaListFields"]
    ) -> "MediaListGroupFields":
        """Subfields should come from the MediaListGroupFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaListGroupFields":
        self._alias = alias
        return self


class MediaListOptionsFields(GraphQLField):
    score_format: "MediaListOptionsGraphQLField" = MediaListOptionsGraphQLField(
        "scoreFormat"
    )
    row_order: "MediaListOptionsGraphQLField" = MediaListOptionsGraphQLField("rowOrder")
    use_legacy_lists: "MediaListOptionsGraphQLField" = MediaListOptionsGraphQLField(
        "useLegacyLists"
    )

    @classmethod
    def anime_list(cls) -> "MediaListTypeOptionsFields":
        return MediaListTypeOptionsFields("animeList")

    @classmethod
    def manga_list(cls) -> "MediaListTypeOptionsFields":
        return MediaListTypeOptionsFields("mangaList")

    shared_theme: "MediaListOptionsGraphQLField" = MediaListOptionsGraphQLField(
        "sharedTheme"
    )
    shared_theme_enabled: "MediaListOptionsGraphQLField" = MediaListOptionsGraphQLField(
        "sharedThemeEnabled"
    )

    def fields(
        self,
        *subfields: Union[MediaListOptionsGraphQLField, "MediaListTypeOptionsFields"],
    ) -> "MediaListOptionsFields":
        """Subfields should come from the MediaListOptionsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaListOptionsFields":
        self._alias = alias
        return self


class MediaListTypeOptionsFields(GraphQLField):
    section_order: "MediaListTypeOptionsGraphQLField" = (
        MediaListTypeOptionsGraphQLField("sectionOrder")
    )
    split_completed_section_by_format: "MediaListTypeOptionsGraphQLField" = (
        MediaListTypeOptionsGraphQLField("splitCompletedSectionByFormat")
    )
    theme: "MediaListTypeOptionsGraphQLField" = MediaListTypeOptionsGraphQLField(
        "theme"
    )
    custom_lists: "MediaListTypeOptionsGraphQLField" = MediaListTypeOptionsGraphQLField(
        "customLists"
    )
    advanced_scoring: "MediaListTypeOptionsGraphQLField" = (
        MediaListTypeOptionsGraphQLField("advancedScoring")
    )
    advanced_scoring_enabled: "MediaListTypeOptionsGraphQLField" = (
        MediaListTypeOptionsGraphQLField("advancedScoringEnabled")
    )

    def fields(
        self, *subfields: MediaListTypeOptionsGraphQLField
    ) -> "MediaListTypeOptionsFields":
        """Subfields should come from the MediaListTypeOptionsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaListTypeOptionsFields":
        self._alias = alias
        return self


class MediaMergeNotificationFields(GraphQLField):
    id: "MediaMergeNotificationGraphQLField" = MediaMergeNotificationGraphQLField("id")
    type: "MediaMergeNotificationGraphQLField" = MediaMergeNotificationGraphQLField(
        "type"
    )
    media_id: "MediaMergeNotificationGraphQLField" = MediaMergeNotificationGraphQLField(
        "mediaId"
    )
    deleted_media_titles: "MediaMergeNotificationGraphQLField" = (
        MediaMergeNotificationGraphQLField("deletedMediaTitles")
    )
    context: "MediaMergeNotificationGraphQLField" = MediaMergeNotificationGraphQLField(
        "context"
    )
    reason: "MediaMergeNotificationGraphQLField" = MediaMergeNotificationGraphQLField(
        "reason"
    )
    created_at: "MediaMergeNotificationGraphQLField" = (
        MediaMergeNotificationGraphQLField("createdAt")
    )

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    def fields(
        self, *subfields: Union[MediaMergeNotificationGraphQLField, "MediaFields"]
    ) -> "MediaMergeNotificationFields":
        """Subfields should come from the MediaMergeNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaMergeNotificationFields":
        self._alias = alias
        return self


class MediaRankFields(GraphQLField):
    id: "MediaRankGraphQLField" = MediaRankGraphQLField("id")
    rank: "MediaRankGraphQLField" = MediaRankGraphQLField("rank")
    type: "MediaRankGraphQLField" = MediaRankGraphQLField("type")
    format: "MediaRankGraphQLField" = MediaRankGraphQLField("format")
    year: "MediaRankGraphQLField" = MediaRankGraphQLField("year")
    season: "MediaRankGraphQLField" = MediaRankGraphQLField("season")
    all_time: "MediaRankGraphQLField" = MediaRankGraphQLField("allTime")
    context: "MediaRankGraphQLField" = MediaRankGraphQLField("context")

    def fields(self, *subfields: MediaRankGraphQLField) -> "MediaRankFields":
        """Subfields should come from the MediaRankFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaRankFields":
        self._alias = alias
        return self


class MediaStatsFields(GraphQLField):
    @classmethod
    def score_distribution(cls) -> "ScoreDistributionFields":
        return ScoreDistributionFields("scoreDistribution")

    @classmethod
    def status_distribution(cls) -> "StatusDistributionFields":
        return StatusDistributionFields("statusDistribution")

    @classmethod
    def airing_progression(cls) -> "AiringProgressionFields":
        return AiringProgressionFields("airingProgression")

    def fields(
        self,
        *subfields: Union[
            MediaStatsGraphQLField,
            "AiringProgressionFields",
            "ScoreDistributionFields",
            "StatusDistributionFields",
        ],
    ) -> "MediaStatsFields":
        """Subfields should come from the MediaStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaStatsFields":
        self._alias = alias
        return self


class MediaStreamingEpisodeFields(GraphQLField):
    title: "MediaStreamingEpisodeGraphQLField" = MediaStreamingEpisodeGraphQLField(
        "title"
    )
    thumbnail: "MediaStreamingEpisodeGraphQLField" = MediaStreamingEpisodeGraphQLField(
        "thumbnail"
    )
    url: "MediaStreamingEpisodeGraphQLField" = MediaStreamingEpisodeGraphQLField("url")
    site: "MediaStreamingEpisodeGraphQLField" = MediaStreamingEpisodeGraphQLField(
        "site"
    )

    def fields(
        self, *subfields: MediaStreamingEpisodeGraphQLField
    ) -> "MediaStreamingEpisodeFields":
        """Subfields should come from the MediaStreamingEpisodeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaStreamingEpisodeFields":
        self._alias = alias
        return self


class MediaTagFields(GraphQLField):
    id: "MediaTagGraphQLField" = MediaTagGraphQLField("id")
    name: "MediaTagGraphQLField" = MediaTagGraphQLField("name")
    description: "MediaTagGraphQLField" = MediaTagGraphQLField("description")
    category: "MediaTagGraphQLField" = MediaTagGraphQLField("category")
    rank: "MediaTagGraphQLField" = MediaTagGraphQLField("rank")
    is_general_spoiler: "MediaTagGraphQLField" = MediaTagGraphQLField(
        "isGeneralSpoiler"
    )
    is_media_spoiler: "MediaTagGraphQLField" = MediaTagGraphQLField("isMediaSpoiler")
    is_adult: "MediaTagGraphQLField" = MediaTagGraphQLField("isAdult")
    user_id: "MediaTagGraphQLField" = MediaTagGraphQLField("userId")

    def fields(self, *subfields: MediaTagGraphQLField) -> "MediaTagFields":
        """Subfields should come from the MediaTagFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaTagFields":
        self._alias = alias
        return self


class MediaTitleFields(GraphQLField):
    @classmethod
    def romaji(cls, *, stylised: Optional[bool] = None) -> "MediaTitleGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "stylised": {"type": "Boolean", "value": stylised}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaTitleGraphQLField("romaji", arguments=cleared_arguments)

    @classmethod
    def english(cls, *, stylised: Optional[bool] = None) -> "MediaTitleGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "stylised": {"type": "Boolean", "value": stylised}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaTitleGraphQLField("english", arguments=cleared_arguments)

    @classmethod
    def native(cls, *, stylised: Optional[bool] = None) -> "MediaTitleGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "stylised": {"type": "Boolean", "value": stylised}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaTitleGraphQLField("native", arguments=cleared_arguments)

    user_preferred: "MediaTitleGraphQLField" = MediaTitleGraphQLField("userPreferred")

    def fields(self, *subfields: MediaTitleGraphQLField) -> "MediaTitleFields":
        """Subfields should come from the MediaTitleFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaTitleFields":
        self._alias = alias
        return self


class MediaTrailerFields(GraphQLField):
    id: "MediaTrailerGraphQLField" = MediaTrailerGraphQLField("id")
    site: "MediaTrailerGraphQLField" = MediaTrailerGraphQLField("site")
    thumbnail: "MediaTrailerGraphQLField" = MediaTrailerGraphQLField("thumbnail")

    def fields(self, *subfields: MediaTrailerGraphQLField) -> "MediaTrailerFields":
        """Subfields should come from the MediaTrailerFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaTrailerFields":
        self._alias = alias
        return self


class MediaTrendFields(GraphQLField):
    media_id: "MediaTrendGraphQLField" = MediaTrendGraphQLField("mediaId")
    date: "MediaTrendGraphQLField" = MediaTrendGraphQLField("date")
    trending: "MediaTrendGraphQLField" = MediaTrendGraphQLField("trending")
    average_score: "MediaTrendGraphQLField" = MediaTrendGraphQLField("averageScore")
    popularity: "MediaTrendGraphQLField" = MediaTrendGraphQLField("popularity")
    in_progress: "MediaTrendGraphQLField" = MediaTrendGraphQLField("inProgress")
    releasing: "MediaTrendGraphQLField" = MediaTrendGraphQLField("releasing")
    episode: "MediaTrendGraphQLField" = MediaTrendGraphQLField("episode")

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    def fields(
        self, *subfields: Union[MediaTrendGraphQLField, "MediaFields"]
    ) -> "MediaTrendFields":
        """Subfields should come from the MediaTrendFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaTrendFields":
        self._alias = alias
        return self


class MediaTrendConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "MediaTrendEdgeFields":
        return MediaTrendEdgeFields("edges")

    @classmethod
    def nodes(cls) -> "MediaTrendFields":
        return MediaTrendFields("nodes")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    def fields(
        self,
        *subfields: Union[
            MediaTrendConnectionGraphQLField,
            "MediaTrendEdgeFields",
            "MediaTrendFields",
            "PageInfoFields",
        ],
    ) -> "MediaTrendConnectionFields":
        """Subfields should come from the MediaTrendConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaTrendConnectionFields":
        self._alias = alias
        return self


class MediaTrendEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "MediaTrendFields":
        return MediaTrendFields("node")

    def fields(
        self, *subfields: Union[MediaTrendEdgeGraphQLField, "MediaTrendFields"]
    ) -> "MediaTrendEdgeFields":
        """Subfields should come from the MediaTrendEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MediaTrendEdgeFields":
        self._alias = alias
        return self


class MessageActivityFields(GraphQLField):
    id: "MessageActivityGraphQLField" = MessageActivityGraphQLField("id")
    recipient_id: "MessageActivityGraphQLField" = MessageActivityGraphQLField(
        "recipientId"
    )
    messenger_id: "MessageActivityGraphQLField" = MessageActivityGraphQLField(
        "messengerId"
    )
    type: "MessageActivityGraphQLField" = MessageActivityGraphQLField("type")
    reply_count: "MessageActivityGraphQLField" = MessageActivityGraphQLField(
        "replyCount"
    )

    @classmethod
    def message(
        cls, *, as_html: Optional[bool] = None
    ) -> "MessageActivityGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MessageActivityGraphQLField("message", arguments=cleared_arguments)

    is_locked: "MessageActivityGraphQLField" = MessageActivityGraphQLField("isLocked")
    is_subscribed: "MessageActivityGraphQLField" = MessageActivityGraphQLField(
        "isSubscribed"
    )
    like_count: "MessageActivityGraphQLField" = MessageActivityGraphQLField("likeCount")
    is_liked: "MessageActivityGraphQLField" = MessageActivityGraphQLField("isLiked")
    is_private: "MessageActivityGraphQLField" = MessageActivityGraphQLField("isPrivate")
    site_url: "MessageActivityGraphQLField" = MessageActivityGraphQLField("siteUrl")
    created_at: "MessageActivityGraphQLField" = MessageActivityGraphQLField("createdAt")

    @classmethod
    def recipient(cls) -> "UserFields":
        return UserFields("recipient")

    @classmethod
    def messenger(cls) -> "UserFields":
        return UserFields("messenger")

    @classmethod
    def replies(cls) -> "ActivityReplyFields":
        return ActivityReplyFields("replies")

    @classmethod
    def likes(cls) -> "UserFields":
        return UserFields("likes")

    def fields(
        self,
        *subfields: Union[
            MessageActivityGraphQLField, "ActivityReplyFields", "UserFields"
        ],
    ) -> "MessageActivityFields":
        """Subfields should come from the MessageActivityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MessageActivityFields":
        self._alias = alias
        return self


class NotificationOptionFields(GraphQLField):
    type: "NotificationOptionGraphQLField" = NotificationOptionGraphQLField("type")
    enabled: "NotificationOptionGraphQLField" = NotificationOptionGraphQLField(
        "enabled"
    )

    def fields(
        self, *subfields: NotificationOptionGraphQLField
    ) -> "NotificationOptionFields":
        """Subfields should come from the NotificationOptionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NotificationOptionFields":
        self._alias = alias
        return self


class PageFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    @classmethod
    def users(
        cls,
        *,
        id: Optional[int] = None,
        name: Optional[str] = None,
        is_moderator: Optional[bool] = None,
        search: Optional[str] = None,
        sort: Optional[List[UserSort]] = None,
    ) -> "UserFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "name": {"type": "String", "value": name},
            "isModerator": {"type": "Boolean", "value": is_moderator},
            "search": {"type": "String", "value": search},
            "sort": {"type": "[UserSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserFields("users", arguments=cleared_arguments)

    @classmethod
    def media(
        cls,
        *,
        id: Optional[int] = None,
        id_mal: Optional[int] = None,
        start_date: Optional[Any] = None,
        end_date: Optional[Any] = None,
        season: Optional[MediaSeason] = None,
        season_year: Optional[int] = None,
        type: Optional[MediaType] = None,
        format: Optional[MediaFormat] = None,
        status: Optional[MediaStatus] = None,
        episodes: Optional[int] = None,
        duration: Optional[int] = None,
        chapters: Optional[int] = None,
        volumes: Optional[int] = None,
        is_adult: Optional[bool] = None,
        genre: Optional[str] = None,
        tag: Optional[str] = None,
        minimum_tag_rank: Optional[int] = None,
        tag_category: Optional[str] = None,
        on_list: Optional[bool] = None,
        licensed_by: Optional[str] = None,
        licensed_by_id: Optional[int] = None,
        average_score: Optional[int] = None,
        popularity: Optional[int] = None,
        source: Optional[MediaSource] = None,
        country_of_origin: Optional[Any] = None,
        is_licensed: Optional[bool] = None,
        search: Optional[str] = None,
        id_not: Optional[int] = None,
        id_in: Optional[List[int]] = None,
        id_not_in: Optional[List[int]] = None,
        id_mal_not: Optional[int] = None,
        id_mal_in: Optional[List[int]] = None,
        id_mal_not_in: Optional[List[int]] = None,
        start_date_greater: Optional[Any] = None,
        start_date_lesser: Optional[Any] = None,
        start_date_like: Optional[str] = None,
        end_date_greater: Optional[Any] = None,
        end_date_lesser: Optional[Any] = None,
        end_date_like: Optional[str] = None,
        format_in: Optional[List[MediaFormat]] = None,
        format_not: Optional[MediaFormat] = None,
        format_not_in: Optional[List[MediaFormat]] = None,
        status_in: Optional[List[MediaStatus]] = None,
        status_not: Optional[MediaStatus] = None,
        status_not_in: Optional[List[MediaStatus]] = None,
        episodes_greater: Optional[int] = None,
        episodes_lesser: Optional[int] = None,
        duration_greater: Optional[int] = None,
        duration_lesser: Optional[int] = None,
        chapters_greater: Optional[int] = None,
        chapters_lesser: Optional[int] = None,
        volumes_greater: Optional[int] = None,
        volumes_lesser: Optional[int] = None,
        genre_in: Optional[List[str]] = None,
        genre_not_in: Optional[List[str]] = None,
        tag_in: Optional[List[str]] = None,
        tag_not_in: Optional[List[str]] = None,
        tag_category_in: Optional[List[str]] = None,
        tag_category_not_in: Optional[List[str]] = None,
        licensed_by_in: Optional[List[str]] = None,
        licensed_by_id_in: Optional[List[int]] = None,
        average_score_not: Optional[int] = None,
        average_score_greater: Optional[int] = None,
        average_score_lesser: Optional[int] = None,
        popularity_not: Optional[int] = None,
        popularity_greater: Optional[int] = None,
        popularity_lesser: Optional[int] = None,
        source_in: Optional[List[MediaSource]] = None,
        sort: Optional[List[MediaSort]] = None,
    ) -> "MediaFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "idMal": {"type": "Int", "value": id_mal},
            "startDate": {"type": "FuzzyDateInt", "value": start_date},
            "endDate": {"type": "FuzzyDateInt", "value": end_date},
            "season": {"type": "MediaSeason", "value": season},
            "seasonYear": {"type": "Int", "value": season_year},
            "type": {"type": "MediaType", "value": type},
            "format": {"type": "MediaFormat", "value": format},
            "status": {"type": "MediaStatus", "value": status},
            "episodes": {"type": "Int", "value": episodes},
            "duration": {"type": "Int", "value": duration},
            "chapters": {"type": "Int", "value": chapters},
            "volumes": {"type": "Int", "value": volumes},
            "isAdult": {"type": "Boolean", "value": is_adult},
            "genre": {"type": "String", "value": genre},
            "tag": {"type": "String", "value": tag},
            "minimumTagRank": {"type": "Int", "value": minimum_tag_rank},
            "tagCategory": {"type": "String", "value": tag_category},
            "onList": {"type": "Boolean", "value": on_list},
            "licensedBy": {"type": "String", "value": licensed_by},
            "licensedById": {"type": "Int", "value": licensed_by_id},
            "averageScore": {"type": "Int", "value": average_score},
            "popularity": {"type": "Int", "value": popularity},
            "source": {"type": "MediaSource", "value": source},
            "countryOfOrigin": {"type": "CountryCode", "value": country_of_origin},
            "isLicensed": {"type": "Boolean", "value": is_licensed},
            "search": {"type": "String", "value": search},
            "id_not": {"type": "Int", "value": id_not},
            "id_in": {"type": "[Int]", "value": id_in},
            "id_not_in": {"type": "[Int]", "value": id_not_in},
            "idMal_not": {"type": "Int", "value": id_mal_not},
            "idMal_in": {"type": "[Int]", "value": id_mal_in},
            "idMal_not_in": {"type": "[Int]", "value": id_mal_not_in},
            "startDate_greater": {"type": "FuzzyDateInt", "value": start_date_greater},
            "startDate_lesser": {"type": "FuzzyDateInt", "value": start_date_lesser},
            "startDate_like": {"type": "String", "value": start_date_like},
            "endDate_greater": {"type": "FuzzyDateInt", "value": end_date_greater},
            "endDate_lesser": {"type": "FuzzyDateInt", "value": end_date_lesser},
            "endDate_like": {"type": "String", "value": end_date_like},
            "format_in": {"type": "[MediaFormat]", "value": format_in},
            "format_not": {"type": "MediaFormat", "value": format_not},
            "format_not_in": {"type": "[MediaFormat]", "value": format_not_in},
            "status_in": {"type": "[MediaStatus]", "value": status_in},
            "status_not": {"type": "MediaStatus", "value": status_not},
            "status_not_in": {"type": "[MediaStatus]", "value": status_not_in},
            "episodes_greater": {"type": "Int", "value": episodes_greater},
            "episodes_lesser": {"type": "Int", "value": episodes_lesser},
            "duration_greater": {"type": "Int", "value": duration_greater},
            "duration_lesser": {"type": "Int", "value": duration_lesser},
            "chapters_greater": {"type": "Int", "value": chapters_greater},
            "chapters_lesser": {"type": "Int", "value": chapters_lesser},
            "volumes_greater": {"type": "Int", "value": volumes_greater},
            "volumes_lesser": {"type": "Int", "value": volumes_lesser},
            "genre_in": {"type": "[String]", "value": genre_in},
            "genre_not_in": {"type": "[String]", "value": genre_not_in},
            "tag_in": {"type": "[String]", "value": tag_in},
            "tag_not_in": {"type": "[String]", "value": tag_not_in},
            "tagCategory_in": {"type": "[String]", "value": tag_category_in},
            "tagCategory_not_in": {"type": "[String]", "value": tag_category_not_in},
            "licensedBy_in": {"type": "[String]", "value": licensed_by_in},
            "licensedById_in": {"type": "[Int]", "value": licensed_by_id_in},
            "averageScore_not": {"type": "Int", "value": average_score_not},
            "averageScore_greater": {"type": "Int", "value": average_score_greater},
            "averageScore_lesser": {"type": "Int", "value": average_score_lesser},
            "popularity_not": {"type": "Int", "value": popularity_not},
            "popularity_greater": {"type": "Int", "value": popularity_greater},
            "popularity_lesser": {"type": "Int", "value": popularity_lesser},
            "source_in": {"type": "[MediaSource]", "value": source_in},
            "sort": {"type": "[MediaSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaFields("media", arguments=cleared_arguments)

    @classmethod
    def characters(
        cls,
        *,
        id: Optional[int] = None,
        is_birthday: Optional[bool] = None,
        search: Optional[str] = None,
        id_not: Optional[int] = None,
        id_in: Optional[List[int]] = None,
        id_not_in: Optional[List[int]] = None,
        sort: Optional[List[CharacterSort]] = None,
    ) -> "CharacterFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "isBirthday": {"type": "Boolean", "value": is_birthday},
            "search": {"type": "String", "value": search},
            "id_not": {"type": "Int", "value": id_not},
            "id_in": {"type": "[Int]", "value": id_in},
            "id_not_in": {"type": "[Int]", "value": id_not_in},
            "sort": {"type": "[CharacterSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CharacterFields("characters", arguments=cleared_arguments)

    @classmethod
    def staff(
        cls,
        *,
        id: Optional[int] = None,
        is_birthday: Optional[bool] = None,
        search: Optional[str] = None,
        id_not: Optional[int] = None,
        id_in: Optional[List[int]] = None,
        id_not_in: Optional[List[int]] = None,
        sort: Optional[List[StaffSort]] = None,
    ) -> "StaffFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "isBirthday": {"type": "Boolean", "value": is_birthday},
            "search": {"type": "String", "value": search},
            "id_not": {"type": "Int", "value": id_not},
            "id_in": {"type": "[Int]", "value": id_in},
            "id_not_in": {"type": "[Int]", "value": id_not_in},
            "sort": {"type": "[StaffSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StaffFields("staff", arguments=cleared_arguments)

    @classmethod
    def studios(
        cls,
        *,
        id: Optional[int] = None,
        search: Optional[str] = None,
        id_not: Optional[int] = None,
        id_in: Optional[List[int]] = None,
        id_not_in: Optional[List[int]] = None,
        sort: Optional[List[StudioSort]] = None,
    ) -> "StudioFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "search": {"type": "String", "value": search},
            "id_not": {"type": "Int", "value": id_not},
            "id_in": {"type": "[Int]", "value": id_in},
            "id_not_in": {"type": "[Int]", "value": id_not_in},
            "sort": {"type": "[StudioSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StudioFields("studios", arguments=cleared_arguments)

    @classmethod
    def media_list(
        cls,
        *,
        id: Optional[int] = None,
        user_id: Optional[int] = None,
        user_name: Optional[str] = None,
        type: Optional[MediaType] = None,
        status: Optional[MediaListStatus] = None,
        media_id: Optional[int] = None,
        is_following: Optional[bool] = None,
        notes: Optional[str] = None,
        started_at: Optional[Any] = None,
        completed_at: Optional[Any] = None,
        compare_with_auth_list: Optional[bool] = None,
        user_id_in: Optional[List[int]] = None,
        status_in: Optional[List[MediaListStatus]] = None,
        status_not_in: Optional[List[MediaListStatus]] = None,
        status_not: Optional[MediaListStatus] = None,
        media_id_in: Optional[List[int]] = None,
        media_id_not_in: Optional[List[int]] = None,
        notes_like: Optional[str] = None,
        started_at_greater: Optional[Any] = None,
        started_at_lesser: Optional[Any] = None,
        started_at_like: Optional[str] = None,
        completed_at_greater: Optional[Any] = None,
        completed_at_lesser: Optional[Any] = None,
        completed_at_like: Optional[str] = None,
        sort: Optional[List[MediaListSort]] = None,
    ) -> "MediaListFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "userId": {"type": "Int", "value": user_id},
            "userName": {"type": "String", "value": user_name},
            "type": {"type": "MediaType", "value": type},
            "status": {"type": "MediaListStatus", "value": status},
            "mediaId": {"type": "Int", "value": media_id},
            "isFollowing": {"type": "Boolean", "value": is_following},
            "notes": {"type": "String", "value": notes},
            "startedAt": {"type": "FuzzyDateInt", "value": started_at},
            "completedAt": {"type": "FuzzyDateInt", "value": completed_at},
            "compareWithAuthList": {"type": "Boolean", "value": compare_with_auth_list},
            "userId_in": {"type": "[Int]", "value": user_id_in},
            "status_in": {"type": "[MediaListStatus]", "value": status_in},
            "status_not_in": {"type": "[MediaListStatus]", "value": status_not_in},
            "status_not": {"type": "MediaListStatus", "value": status_not},
            "mediaId_in": {"type": "[Int]", "value": media_id_in},
            "mediaId_not_in": {"type": "[Int]", "value": media_id_not_in},
            "notes_like": {"type": "String", "value": notes_like},
            "startedAt_greater": {"type": "FuzzyDateInt", "value": started_at_greater},
            "startedAt_lesser": {"type": "FuzzyDateInt", "value": started_at_lesser},
            "startedAt_like": {"type": "String", "value": started_at_like},
            "completedAt_greater": {
                "type": "FuzzyDateInt",
                "value": completed_at_greater,
            },
            "completedAt_lesser": {
                "type": "FuzzyDateInt",
                "value": completed_at_lesser,
            },
            "completedAt_like": {"type": "String", "value": completed_at_like},
            "sort": {"type": "[MediaListSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaListFields("mediaList", arguments=cleared_arguments)

    @classmethod
    def airing_schedules(
        cls,
        *,
        id: Optional[int] = None,
        media_id: Optional[int] = None,
        episode: Optional[int] = None,
        airing_at: Optional[int] = None,
        not_yet_aired: Optional[bool] = None,
        id_not: Optional[int] = None,
        id_in: Optional[List[int]] = None,
        id_not_in: Optional[List[int]] = None,
        media_id_not: Optional[int] = None,
        media_id_in: Optional[List[int]] = None,
        media_id_not_in: Optional[List[int]] = None,
        episode_not: Optional[int] = None,
        episode_in: Optional[List[int]] = None,
        episode_not_in: Optional[List[int]] = None,
        episode_greater: Optional[int] = None,
        episode_lesser: Optional[int] = None,
        airing_at_greater: Optional[int] = None,
        airing_at_lesser: Optional[int] = None,
        sort: Optional[List[AiringSort]] = None,
    ) -> "AiringScheduleFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "mediaId": {"type": "Int", "value": media_id},
            "episode": {"type": "Int", "value": episode},
            "airingAt": {"type": "Int", "value": airing_at},
            "notYetAired": {"type": "Boolean", "value": not_yet_aired},
            "id_not": {"type": "Int", "value": id_not},
            "id_in": {"type": "[Int]", "value": id_in},
            "id_not_in": {"type": "[Int]", "value": id_not_in},
            "mediaId_not": {"type": "Int", "value": media_id_not},
            "mediaId_in": {"type": "[Int]", "value": media_id_in},
            "mediaId_not_in": {"type": "[Int]", "value": media_id_not_in},
            "episode_not": {"type": "Int", "value": episode_not},
            "episode_in": {"type": "[Int]", "value": episode_in},
            "episode_not_in": {"type": "[Int]", "value": episode_not_in},
            "episode_greater": {"type": "Int", "value": episode_greater},
            "episode_lesser": {"type": "Int", "value": episode_lesser},
            "airingAt_greater": {"type": "Int", "value": airing_at_greater},
            "airingAt_lesser": {"type": "Int", "value": airing_at_lesser},
            "sort": {"type": "[AiringSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return AiringScheduleFields("airingSchedules", arguments=cleared_arguments)

    @classmethod
    def media_trends(
        cls,
        *,
        media_id: Optional[int] = None,
        date: Optional[int] = None,
        trending: Optional[int] = None,
        average_score: Optional[int] = None,
        popularity: Optional[int] = None,
        episode: Optional[int] = None,
        releasing: Optional[bool] = None,
        media_id_not: Optional[int] = None,
        media_id_in: Optional[List[int]] = None,
        media_id_not_in: Optional[List[int]] = None,
        date_greater: Optional[int] = None,
        date_lesser: Optional[int] = None,
        trending_greater: Optional[int] = None,
        trending_lesser: Optional[int] = None,
        trending_not: Optional[int] = None,
        average_score_greater: Optional[int] = None,
        average_score_lesser: Optional[int] = None,
        average_score_not: Optional[int] = None,
        popularity_greater: Optional[int] = None,
        popularity_lesser: Optional[int] = None,
        popularity_not: Optional[int] = None,
        episode_greater: Optional[int] = None,
        episode_lesser: Optional[int] = None,
        episode_not: Optional[int] = None,
        sort: Optional[List[MediaTrendSort]] = None,
    ) -> "MediaTrendFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "mediaId": {"type": "Int", "value": media_id},
            "date": {"type": "Int", "value": date},
            "trending": {"type": "Int", "value": trending},
            "averageScore": {"type": "Int", "value": average_score},
            "popularity": {"type": "Int", "value": popularity},
            "episode": {"type": "Int", "value": episode},
            "releasing": {"type": "Boolean", "value": releasing},
            "mediaId_not": {"type": "Int", "value": media_id_not},
            "mediaId_in": {"type": "[Int]", "value": media_id_in},
            "mediaId_not_in": {"type": "[Int]", "value": media_id_not_in},
            "date_greater": {"type": "Int", "value": date_greater},
            "date_lesser": {"type": "Int", "value": date_lesser},
            "trending_greater": {"type": "Int", "value": trending_greater},
            "trending_lesser": {"type": "Int", "value": trending_lesser},
            "trending_not": {"type": "Int", "value": trending_not},
            "averageScore_greater": {"type": "Int", "value": average_score_greater},
            "averageScore_lesser": {"type": "Int", "value": average_score_lesser},
            "averageScore_not": {"type": "Int", "value": average_score_not},
            "popularity_greater": {"type": "Int", "value": popularity_greater},
            "popularity_lesser": {"type": "Int", "value": popularity_lesser},
            "popularity_not": {"type": "Int", "value": popularity_not},
            "episode_greater": {"type": "Int", "value": episode_greater},
            "episode_lesser": {"type": "Int", "value": episode_lesser},
            "episode_not": {"type": "Int", "value": episode_not},
            "sort": {"type": "[MediaTrendSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaTrendFields("mediaTrends", arguments=cleared_arguments)

    @classmethod
    def notifications(
        cls,
        *,
        type: Optional[NotificationType] = None,
        reset_notification_count: Optional[bool] = None,
        type_in: Optional[List[NotificationType]] = None,
    ) -> "NotificationUnionUnion":
        arguments: Dict[str, Dict[str, Any]] = {
            "type": {"type": "NotificationType", "value": type},
            "resetNotificationCount": {
                "type": "Boolean",
                "value": reset_notification_count,
            },
            "type_in": {"type": "[NotificationType]", "value": type_in},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NotificationUnionUnion("notifications", arguments=cleared_arguments)

    @classmethod
    def followers(
        cls, user_id: int, *, sort: Optional[List[UserSort]] = None
    ) -> "UserFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "userId": {"type": "Int!", "value": user_id},
            "sort": {"type": "[UserSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserFields("followers", arguments=cleared_arguments)

    @classmethod
    def following(
        cls, user_id: int, *, sort: Optional[List[UserSort]] = None
    ) -> "UserFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "userId": {"type": "Int!", "value": user_id},
            "sort": {"type": "[UserSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserFields("following", arguments=cleared_arguments)

    @classmethod
    def activities(
        cls,
        *,
        id: Optional[int] = None,
        user_id: Optional[int] = None,
        messenger_id: Optional[int] = None,
        media_id: Optional[int] = None,
        type: Optional[ActivityType] = None,
        is_following: Optional[bool] = None,
        has_replies: Optional[bool] = None,
        has_replies_or_type_text: Optional[bool] = None,
        created_at: Optional[int] = None,
        id_not: Optional[int] = None,
        id_in: Optional[List[int]] = None,
        id_not_in: Optional[List[int]] = None,
        user_id_not: Optional[int] = None,
        user_id_in: Optional[List[int]] = None,
        user_id_not_in: Optional[List[int]] = None,
        messenger_id_not: Optional[int] = None,
        messenger_id_in: Optional[List[int]] = None,
        messenger_id_not_in: Optional[List[int]] = None,
        media_id_not: Optional[int] = None,
        media_id_in: Optional[List[int]] = None,
        media_id_not_in: Optional[List[int]] = None,
        type_not: Optional[ActivityType] = None,
        type_in: Optional[List[ActivityType]] = None,
        type_not_in: Optional[List[ActivityType]] = None,
        created_at_greater: Optional[int] = None,
        created_at_lesser: Optional[int] = None,
        sort: Optional[List[ActivitySort]] = None,
    ) -> "ActivityUnionUnion":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "userId": {"type": "Int", "value": user_id},
            "messengerId": {"type": "Int", "value": messenger_id},
            "mediaId": {"type": "Int", "value": media_id},
            "type": {"type": "ActivityType", "value": type},
            "isFollowing": {"type": "Boolean", "value": is_following},
            "hasReplies": {"type": "Boolean", "value": has_replies},
            "hasRepliesOrTypeText": {
                "type": "Boolean",
                "value": has_replies_or_type_text,
            },
            "createdAt": {"type": "Int", "value": created_at},
            "id_not": {"type": "Int", "value": id_not},
            "id_in": {"type": "[Int]", "value": id_in},
            "id_not_in": {"type": "[Int]", "value": id_not_in},
            "userId_not": {"type": "Int", "value": user_id_not},
            "userId_in": {"type": "[Int]", "value": user_id_in},
            "userId_not_in": {"type": "[Int]", "value": user_id_not_in},
            "messengerId_not": {"type": "Int", "value": messenger_id_not},
            "messengerId_in": {"type": "[Int]", "value": messenger_id_in},
            "messengerId_not_in": {"type": "[Int]", "value": messenger_id_not_in},
            "mediaId_not": {"type": "Int", "value": media_id_not},
            "mediaId_in": {"type": "[Int]", "value": media_id_in},
            "mediaId_not_in": {"type": "[Int]", "value": media_id_not_in},
            "type_not": {"type": "ActivityType", "value": type_not},
            "type_in": {"type": "[ActivityType]", "value": type_in},
            "type_not_in": {"type": "[ActivityType]", "value": type_not_in},
            "createdAt_greater": {"type": "Int", "value": created_at_greater},
            "createdAt_lesser": {"type": "Int", "value": created_at_lesser},
            "sort": {"type": "[ActivitySort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ActivityUnionUnion("activities", arguments=cleared_arguments)

    @classmethod
    def activity_replies(
        cls, *, id: Optional[int] = None, activity_id: Optional[int] = None
    ) -> "ActivityReplyFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "activityId": {"type": "Int", "value": activity_id},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ActivityReplyFields("activityReplies", arguments=cleared_arguments)

    @classmethod
    def threads(
        cls,
        *,
        id: Optional[int] = None,
        user_id: Optional[int] = None,
        reply_user_id: Optional[int] = None,
        subscribed: Optional[bool] = None,
        category_id: Optional[int] = None,
        media_category_id: Optional[int] = None,
        search: Optional[str] = None,
        id_in: Optional[List[int]] = None,
        sort: Optional[List[ThreadSort]] = None,
    ) -> "ThreadFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "userId": {"type": "Int", "value": user_id},
            "replyUserId": {"type": "Int", "value": reply_user_id},
            "subscribed": {"type": "Boolean", "value": subscribed},
            "categoryId": {"type": "Int", "value": category_id},
            "mediaCategoryId": {"type": "Int", "value": media_category_id},
            "search": {"type": "String", "value": search},
            "id_in": {"type": "[Int]", "value": id_in},
            "sort": {"type": "[ThreadSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ThreadFields("threads", arguments=cleared_arguments)

    @classmethod
    def thread_comments(
        cls,
        *,
        id: Optional[int] = None,
        thread_id: Optional[int] = None,
        user_id: Optional[int] = None,
        sort: Optional[List[ThreadCommentSort]] = None,
    ) -> "ThreadCommentFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "threadId": {"type": "Int", "value": thread_id},
            "userId": {"type": "Int", "value": user_id},
            "sort": {"type": "[ThreadCommentSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ThreadCommentFields("threadComments", arguments=cleared_arguments)

    @classmethod
    def reviews(
        cls,
        *,
        id: Optional[int] = None,
        media_id: Optional[int] = None,
        user_id: Optional[int] = None,
        media_type: Optional[MediaType] = None,
        sort: Optional[List[ReviewSort]] = None,
    ) -> "ReviewFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "mediaId": {"type": "Int", "value": media_id},
            "userId": {"type": "Int", "value": user_id},
            "mediaType": {"type": "MediaType", "value": media_type},
            "sort": {"type": "[ReviewSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ReviewFields("reviews", arguments=cleared_arguments)

    @classmethod
    def recommendations(
        cls,
        *,
        id: Optional[int] = None,
        media_id: Optional[int] = None,
        media_recommendation_id: Optional[int] = None,
        user_id: Optional[int] = None,
        rating: Optional[int] = None,
        on_list: Optional[bool] = None,
        rating_greater: Optional[int] = None,
        rating_lesser: Optional[int] = None,
        sort: Optional[List[RecommendationSort]] = None,
    ) -> "RecommendationFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "Int", "value": id},
            "mediaId": {"type": "Int", "value": media_id},
            "mediaRecommendationId": {"type": "Int", "value": media_recommendation_id},
            "userId": {"type": "Int", "value": user_id},
            "rating": {"type": "Int", "value": rating},
            "onList": {"type": "Boolean", "value": on_list},
            "rating_greater": {"type": "Int", "value": rating_greater},
            "rating_lesser": {"type": "Int", "value": rating_lesser},
            "sort": {"type": "[RecommendationSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RecommendationFields("recommendations", arguments=cleared_arguments)

    @classmethod
    def likes(
        cls, *, likeable_id: Optional[int] = None, type: Optional[LikeableType] = None
    ) -> "UserFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "likeableId": {"type": "Int", "value": likeable_id},
            "type": {"type": "LikeableType", "value": type},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserFields("likes", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            PageGraphQLField,
            "ActivityReplyFields",
            "ActivityUnionUnion",
            "AiringScheduleFields",
            "CharacterFields",
            "MediaFields",
            "MediaListFields",
            "MediaTrendFields",
            "NotificationUnionUnion",
            "PageInfoFields",
            "RecommendationFields",
            "ReviewFields",
            "StaffFields",
            "StudioFields",
            "ThreadCommentFields",
            "ThreadFields",
            "UserFields",
        ],
    ) -> "PageFields":
        """Subfields should come from the PageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PageFields":
        self._alias = alias
        return self


class PageInfoFields(GraphQLField):
    total: "PageInfoGraphQLField" = PageInfoGraphQLField("total")
    per_page: "PageInfoGraphQLField" = PageInfoGraphQLField("perPage")
    current_page: "PageInfoGraphQLField" = PageInfoGraphQLField("currentPage")
    last_page: "PageInfoGraphQLField" = PageInfoGraphQLField("lastPage")
    has_next_page: "PageInfoGraphQLField" = PageInfoGraphQLField("hasNextPage")

    def fields(self, *subfields: PageInfoGraphQLField) -> "PageInfoFields":
        """Subfields should come from the PageInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PageInfoFields":
        self._alias = alias
        return self


class ParsedMarkdownFields(GraphQLField):
    html: "ParsedMarkdownGraphQLField" = ParsedMarkdownGraphQLField("html")

    def fields(self, *subfields: ParsedMarkdownGraphQLField) -> "ParsedMarkdownFields":
        """Subfields should come from the ParsedMarkdownFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ParsedMarkdownFields":
        self._alias = alias
        return self


class RecommendationFields(GraphQLField):
    id: "RecommendationGraphQLField" = RecommendationGraphQLField("id")
    rating: "RecommendationGraphQLField" = RecommendationGraphQLField("rating")
    user_rating: "RecommendationGraphQLField" = RecommendationGraphQLField("userRating")

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    @classmethod
    def media_recommendation(cls) -> "MediaFields":
        return MediaFields("mediaRecommendation")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self, *subfields: Union[RecommendationGraphQLField, "MediaFields", "UserFields"]
    ) -> "RecommendationFields":
        """Subfields should come from the RecommendationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RecommendationFields":
        self._alias = alias
        return self


class RecommendationConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "RecommendationEdgeFields":
        return RecommendationEdgeFields("edges")

    @classmethod
    def nodes(cls) -> "RecommendationFields":
        return RecommendationFields("nodes")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    def fields(
        self,
        *subfields: Union[
            RecommendationConnectionGraphQLField,
            "PageInfoFields",
            "RecommendationEdgeFields",
            "RecommendationFields",
        ],
    ) -> "RecommendationConnectionFields":
        """Subfields should come from the RecommendationConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RecommendationConnectionFields":
        self._alias = alias
        return self


class RecommendationEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "RecommendationFields":
        return RecommendationFields("node")

    def fields(
        self, *subfields: Union[RecommendationEdgeGraphQLField, "RecommendationFields"]
    ) -> "RecommendationEdgeFields":
        """Subfields should come from the RecommendationEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RecommendationEdgeFields":
        self._alias = alias
        return self


class RelatedMediaAdditionNotificationFields(GraphQLField):
    id: "RelatedMediaAdditionNotificationGraphQLField" = (
        RelatedMediaAdditionNotificationGraphQLField("id")
    )
    type: "RelatedMediaAdditionNotificationGraphQLField" = (
        RelatedMediaAdditionNotificationGraphQLField("type")
    )
    media_id: "RelatedMediaAdditionNotificationGraphQLField" = (
        RelatedMediaAdditionNotificationGraphQLField("mediaId")
    )
    context: "RelatedMediaAdditionNotificationGraphQLField" = (
        RelatedMediaAdditionNotificationGraphQLField("context")
    )
    created_at: "RelatedMediaAdditionNotificationGraphQLField" = (
        RelatedMediaAdditionNotificationGraphQLField("createdAt")
    )

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    def fields(
        self,
        *subfields: Union[RelatedMediaAdditionNotificationGraphQLField, "MediaFields"],
    ) -> "RelatedMediaAdditionNotificationFields":
        """Subfields should come from the RelatedMediaAdditionNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RelatedMediaAdditionNotificationFields":
        self._alias = alias
        return self


class ReviewFields(GraphQLField):
    id: "ReviewGraphQLField" = ReviewGraphQLField("id")
    user_id: "ReviewGraphQLField" = ReviewGraphQLField("userId")
    media_id: "ReviewGraphQLField" = ReviewGraphQLField("mediaId")
    media_type: "ReviewGraphQLField" = ReviewGraphQLField("mediaType")
    summary: "ReviewGraphQLField" = ReviewGraphQLField("summary")

    @classmethod
    def body(cls, *, as_html: Optional[bool] = None) -> "ReviewGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ReviewGraphQLField("body", arguments=cleared_arguments)

    rating: "ReviewGraphQLField" = ReviewGraphQLField("rating")
    rating_amount: "ReviewGraphQLField" = ReviewGraphQLField("ratingAmount")
    user_rating: "ReviewGraphQLField" = ReviewGraphQLField("userRating")
    score: "ReviewGraphQLField" = ReviewGraphQLField("score")
    private: "ReviewGraphQLField" = ReviewGraphQLField("private")
    site_url: "ReviewGraphQLField" = ReviewGraphQLField("siteUrl")
    created_at: "ReviewGraphQLField" = ReviewGraphQLField("createdAt")
    updated_at: "ReviewGraphQLField" = ReviewGraphQLField("updatedAt")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    @classmethod
    def media(cls) -> "MediaFields":
        return MediaFields("media")

    def fields(
        self, *subfields: Union[ReviewGraphQLField, "MediaFields", "UserFields"]
    ) -> "ReviewFields":
        """Subfields should come from the ReviewFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ReviewFields":
        self._alias = alias
        return self


class ReviewConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "ReviewEdgeFields":
        return ReviewEdgeFields("edges")

    @classmethod
    def nodes(cls) -> "ReviewFields":
        return ReviewFields("nodes")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    def fields(
        self,
        *subfields: Union[
            ReviewConnectionGraphQLField,
            "PageInfoFields",
            "ReviewEdgeFields",
            "ReviewFields",
        ],
    ) -> "ReviewConnectionFields":
        """Subfields should come from the ReviewConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ReviewConnectionFields":
        self._alias = alias
        return self


class ReviewEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "ReviewFields":
        return ReviewFields("node")

    def fields(
        self, *subfields: Union[ReviewEdgeGraphQLField, "ReviewFields"]
    ) -> "ReviewEdgeFields":
        """Subfields should come from the ReviewEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ReviewEdgeFields":
        self._alias = alias
        return self


class ScoreDistributionFields(GraphQLField):
    score: "ScoreDistributionGraphQLField" = ScoreDistributionGraphQLField("score")
    amount: "ScoreDistributionGraphQLField" = ScoreDistributionGraphQLField("amount")

    def fields(
        self, *subfields: ScoreDistributionGraphQLField
    ) -> "ScoreDistributionFields":
        """Subfields should come from the ScoreDistributionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ScoreDistributionFields":
        self._alias = alias
        return self


class SiteStatisticsFields(GraphQLField):
    @classmethod
    def users(
        cls,
        *,
        sort: Optional[List[SiteTrendSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "SiteTrendConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[SiteTrendSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SiteTrendConnectionFields("users", arguments=cleared_arguments)

    @classmethod
    def anime(
        cls,
        *,
        sort: Optional[List[SiteTrendSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "SiteTrendConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[SiteTrendSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SiteTrendConnectionFields("anime", arguments=cleared_arguments)

    @classmethod
    def manga(
        cls,
        *,
        sort: Optional[List[SiteTrendSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "SiteTrendConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[SiteTrendSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SiteTrendConnectionFields("manga", arguments=cleared_arguments)

    @classmethod
    def characters(
        cls,
        *,
        sort: Optional[List[SiteTrendSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "SiteTrendConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[SiteTrendSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SiteTrendConnectionFields("characters", arguments=cleared_arguments)

    @classmethod
    def staff(
        cls,
        *,
        sort: Optional[List[SiteTrendSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "SiteTrendConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[SiteTrendSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SiteTrendConnectionFields("staff", arguments=cleared_arguments)

    @classmethod
    def studios(
        cls,
        *,
        sort: Optional[List[SiteTrendSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "SiteTrendConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[SiteTrendSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SiteTrendConnectionFields("studios", arguments=cleared_arguments)

    @classmethod
    def reviews(
        cls,
        *,
        sort: Optional[List[SiteTrendSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "SiteTrendConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[SiteTrendSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SiteTrendConnectionFields("reviews", arguments=cleared_arguments)

    def fields(
        self, *subfields: Union[SiteStatisticsGraphQLField, "SiteTrendConnectionFields"]
    ) -> "SiteStatisticsFields":
        """Subfields should come from the SiteStatisticsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SiteStatisticsFields":
        self._alias = alias
        return self


class SiteTrendFields(GraphQLField):
    date: "SiteTrendGraphQLField" = SiteTrendGraphQLField("date")
    count: "SiteTrendGraphQLField" = SiteTrendGraphQLField("count")
    change: "SiteTrendGraphQLField" = SiteTrendGraphQLField("change")

    def fields(self, *subfields: SiteTrendGraphQLField) -> "SiteTrendFields":
        """Subfields should come from the SiteTrendFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SiteTrendFields":
        self._alias = alias
        return self


class SiteTrendConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "SiteTrendEdgeFields":
        return SiteTrendEdgeFields("edges")

    @classmethod
    def nodes(cls) -> "SiteTrendFields":
        return SiteTrendFields("nodes")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    def fields(
        self,
        *subfields: Union[
            SiteTrendConnectionGraphQLField,
            "PageInfoFields",
            "SiteTrendEdgeFields",
            "SiteTrendFields",
        ],
    ) -> "SiteTrendConnectionFields":
        """Subfields should come from the SiteTrendConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SiteTrendConnectionFields":
        self._alias = alias
        return self


class SiteTrendEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "SiteTrendFields":
        return SiteTrendFields("node")

    def fields(
        self, *subfields: Union[SiteTrendEdgeGraphQLField, "SiteTrendFields"]
    ) -> "SiteTrendEdgeFields":
        """Subfields should come from the SiteTrendEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SiteTrendEdgeFields":
        self._alias = alias
        return self


class StaffFields(GraphQLField):
    id: "StaffGraphQLField" = StaffGraphQLField("id")

    @classmethod
    def name(cls) -> "StaffNameFields":
        return StaffNameFields("name")

    language: "StaffGraphQLField" = StaffGraphQLField("language")
    language_v_2: "StaffGraphQLField" = StaffGraphQLField("languageV2")

    @classmethod
    def image(cls) -> "StaffImageFields":
        return StaffImageFields("image")

    @classmethod
    def description(cls, *, as_html: Optional[bool] = None) -> "StaffGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return StaffGraphQLField("description", arguments=cleared_arguments)

    primary_occupations: "StaffGraphQLField" = StaffGraphQLField("primaryOccupations")
    gender: "StaffGraphQLField" = StaffGraphQLField("gender")

    @classmethod
    def date_of_birth(cls) -> "FuzzyDateFields":
        return FuzzyDateFields("dateOfBirth")

    @classmethod
    def date_of_death(cls) -> "FuzzyDateFields":
        return FuzzyDateFields("dateOfDeath")

    age: "StaffGraphQLField" = StaffGraphQLField("age")
    years_active: "StaffGraphQLField" = StaffGraphQLField("yearsActive")
    home_town: "StaffGraphQLField" = StaffGraphQLField("homeTown")
    blood_type: "StaffGraphQLField" = StaffGraphQLField("bloodType")
    is_favourite: "StaffGraphQLField" = StaffGraphQLField("isFavourite")
    is_favourite_blocked: "StaffGraphQLField" = StaffGraphQLField("isFavouriteBlocked")
    site_url: "StaffGraphQLField" = StaffGraphQLField("siteUrl")

    @classmethod
    def staff_media(
        cls,
        *,
        sort: Optional[List[MediaSort]] = None,
        type: Optional[MediaType] = None,
        on_list: Optional[bool] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "MediaConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[MediaSort]", "value": sort},
            "type": {"type": "MediaType", "value": type},
            "onList": {"type": "Boolean", "value": on_list},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaConnectionFields("staffMedia", arguments=cleared_arguments)

    @classmethod
    def characters(
        cls,
        *,
        sort: Optional[List[CharacterSort]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "CharacterConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[CharacterSort]", "value": sort},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CharacterConnectionFields("characters", arguments=cleared_arguments)

    @classmethod
    def character_media(
        cls,
        *,
        sort: Optional[List[MediaSort]] = None,
        on_list: Optional[bool] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "MediaConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[MediaSort]", "value": sort},
            "onList": {"type": "Boolean", "value": on_list},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaConnectionFields("characterMedia", arguments=cleared_arguments)

    updated_at: "StaffGraphQLField" = StaffGraphQLField("updatedAt")

    @classmethod
    def staff(cls) -> "StaffFields":
        return StaffFields("staff")

    @classmethod
    def submitter(cls) -> "UserFields":
        return UserFields("submitter")

    submission_status: "StaffGraphQLField" = StaffGraphQLField("submissionStatus")
    submission_notes: "StaffGraphQLField" = StaffGraphQLField("submissionNotes")
    favourites: "StaffGraphQLField" = StaffGraphQLField("favourites")
    mod_notes: "StaffGraphQLField" = StaffGraphQLField("modNotes")

    def fields(
        self,
        *subfields: Union[
            StaffGraphQLField,
            "CharacterConnectionFields",
            "FuzzyDateFields",
            "MediaConnectionFields",
            "StaffFields",
            "StaffImageFields",
            "StaffNameFields",
            "UserFields",
        ],
    ) -> "StaffFields":
        """Subfields should come from the StaffFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StaffFields":
        self._alias = alias
        return self


class StaffConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "StaffEdgeFields":
        return StaffEdgeFields("edges")

    @classmethod
    def nodes(cls) -> "StaffFields":
        return StaffFields("nodes")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    def fields(
        self,
        *subfields: Union[
            StaffConnectionGraphQLField,
            "PageInfoFields",
            "StaffEdgeFields",
            "StaffFields",
        ],
    ) -> "StaffConnectionFields":
        """Subfields should come from the StaffConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StaffConnectionFields":
        self._alias = alias
        return self


class StaffEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "StaffFields":
        return StaffFields("node")

    id: "StaffEdgeGraphQLField" = StaffEdgeGraphQLField("id")
    role: "StaffEdgeGraphQLField" = StaffEdgeGraphQLField("role")
    favourite_order: "StaffEdgeGraphQLField" = StaffEdgeGraphQLField("favouriteOrder")

    def fields(
        self, *subfields: Union[StaffEdgeGraphQLField, "StaffFields"]
    ) -> "StaffEdgeFields":
        """Subfields should come from the StaffEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StaffEdgeFields":
        self._alias = alias
        return self


class StaffImageFields(GraphQLField):
    large: "StaffImageGraphQLField" = StaffImageGraphQLField("large")
    medium: "StaffImageGraphQLField" = StaffImageGraphQLField("medium")

    def fields(self, *subfields: StaffImageGraphQLField) -> "StaffImageFields":
        """Subfields should come from the StaffImageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StaffImageFields":
        self._alias = alias
        return self


class StaffNameFields(GraphQLField):
    first: "StaffNameGraphQLField" = StaffNameGraphQLField("first")
    middle: "StaffNameGraphQLField" = StaffNameGraphQLField("middle")
    last: "StaffNameGraphQLField" = StaffNameGraphQLField("last")
    full: "StaffNameGraphQLField" = StaffNameGraphQLField("full")
    native: "StaffNameGraphQLField" = StaffNameGraphQLField("native")
    alternative: "StaffNameGraphQLField" = StaffNameGraphQLField("alternative")
    user_preferred: "StaffNameGraphQLField" = StaffNameGraphQLField("userPreferred")

    def fields(self, *subfields: StaffNameGraphQLField) -> "StaffNameFields":
        """Subfields should come from the StaffNameFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StaffNameFields":
        self._alias = alias
        return self


class StaffRoleTypeFields(GraphQLField):
    @classmethod
    def voice_actor(cls) -> "StaffFields":
        return StaffFields("voiceActor")

    role_notes: "StaffRoleTypeGraphQLField" = StaffRoleTypeGraphQLField("roleNotes")
    dub_group: "StaffRoleTypeGraphQLField" = StaffRoleTypeGraphQLField("dubGroup")

    def fields(
        self, *subfields: Union[StaffRoleTypeGraphQLField, "StaffFields"]
    ) -> "StaffRoleTypeFields":
        """Subfields should come from the StaffRoleTypeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StaffRoleTypeFields":
        self._alias = alias
        return self


class StaffStatsFields(GraphQLField):
    @classmethod
    def staff(cls) -> "StaffFields":
        return StaffFields("staff")

    amount: "StaffStatsGraphQLField" = StaffStatsGraphQLField("amount")
    mean_score: "StaffStatsGraphQLField" = StaffStatsGraphQLField("meanScore")
    time_watched: "StaffStatsGraphQLField" = StaffStatsGraphQLField("timeWatched")

    def fields(
        self, *subfields: Union[StaffStatsGraphQLField, "StaffFields"]
    ) -> "StaffStatsFields":
        """Subfields should come from the StaffStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StaffStatsFields":
        self._alias = alias
        return self


class StatusDistributionFields(GraphQLField):
    status: "StatusDistributionGraphQLField" = StatusDistributionGraphQLField("status")
    amount: "StatusDistributionGraphQLField" = StatusDistributionGraphQLField("amount")

    def fields(
        self, *subfields: StatusDistributionGraphQLField
    ) -> "StatusDistributionFields":
        """Subfields should come from the StatusDistributionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StatusDistributionFields":
        self._alias = alias
        return self


class StudioFields(GraphQLField):
    id: "StudioGraphQLField" = StudioGraphQLField("id")
    name: "StudioGraphQLField" = StudioGraphQLField("name")
    is_animation_studio: "StudioGraphQLField" = StudioGraphQLField("isAnimationStudio")

    @classmethod
    def media(
        cls,
        *,
        sort: Optional[List[MediaSort]] = None,
        is_main: Optional[bool] = None,
        on_list: Optional[bool] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
    ) -> "MediaConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "[MediaSort]", "value": sort},
            "isMain": {"type": "Boolean", "value": is_main},
            "onList": {"type": "Boolean", "value": on_list},
            "page": {"type": "Int", "value": page},
            "perPage": {"type": "Int", "value": per_page},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MediaConnectionFields("media", arguments=cleared_arguments)

    site_url: "StudioGraphQLField" = StudioGraphQLField("siteUrl")
    is_favourite: "StudioGraphQLField" = StudioGraphQLField("isFavourite")
    favourites: "StudioGraphQLField" = StudioGraphQLField("favourites")

    def fields(
        self, *subfields: Union[StudioGraphQLField, "MediaConnectionFields"]
    ) -> "StudioFields":
        """Subfields should come from the StudioFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StudioFields":
        self._alias = alias
        return self


class StudioConnectionFields(GraphQLField):
    @classmethod
    def edges(cls) -> "StudioEdgeFields":
        return StudioEdgeFields("edges")

    @classmethod
    def nodes(cls) -> "StudioFields":
        return StudioFields("nodes")

    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("pageInfo")

    def fields(
        self,
        *subfields: Union[
            StudioConnectionGraphQLField,
            "PageInfoFields",
            "StudioEdgeFields",
            "StudioFields",
        ],
    ) -> "StudioConnectionFields":
        """Subfields should come from the StudioConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StudioConnectionFields":
        self._alias = alias
        return self


class StudioEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "StudioFields":
        return StudioFields("node")

    id: "StudioEdgeGraphQLField" = StudioEdgeGraphQLField("id")
    is_main: "StudioEdgeGraphQLField" = StudioEdgeGraphQLField("isMain")
    favourite_order: "StudioEdgeGraphQLField" = StudioEdgeGraphQLField("favouriteOrder")

    def fields(
        self, *subfields: Union[StudioEdgeGraphQLField, "StudioFields"]
    ) -> "StudioEdgeFields":
        """Subfields should come from the StudioEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StudioEdgeFields":
        self._alias = alias
        return self


class StudioStatsFields(GraphQLField):
    @classmethod
    def studio(cls) -> "StudioFields":
        return StudioFields("studio")

    amount: "StudioStatsGraphQLField" = StudioStatsGraphQLField("amount")
    mean_score: "StudioStatsGraphQLField" = StudioStatsGraphQLField("meanScore")
    time_watched: "StudioStatsGraphQLField" = StudioStatsGraphQLField("timeWatched")

    def fields(
        self, *subfields: Union[StudioStatsGraphQLField, "StudioFields"]
    ) -> "StudioStatsFields":
        """Subfields should come from the StudioStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StudioStatsFields":
        self._alias = alias
        return self


class TagStatsFields(GraphQLField):
    @classmethod
    def tag(cls) -> "MediaTagFields":
        return MediaTagFields("tag")

    amount: "TagStatsGraphQLField" = TagStatsGraphQLField("amount")
    mean_score: "TagStatsGraphQLField" = TagStatsGraphQLField("meanScore")
    time_watched: "TagStatsGraphQLField" = TagStatsGraphQLField("timeWatched")

    def fields(
        self, *subfields: Union[TagStatsGraphQLField, "MediaTagFields"]
    ) -> "TagStatsFields":
        """Subfields should come from the TagStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TagStatsFields":
        self._alias = alias
        return self


class TextActivityFields(GraphQLField):
    id: "TextActivityGraphQLField" = TextActivityGraphQLField("id")
    user_id: "TextActivityGraphQLField" = TextActivityGraphQLField("userId")
    type: "TextActivityGraphQLField" = TextActivityGraphQLField("type")
    reply_count: "TextActivityGraphQLField" = TextActivityGraphQLField("replyCount")

    @classmethod
    def text(cls, *, as_html: Optional[bool] = None) -> "TextActivityGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TextActivityGraphQLField("text", arguments=cleared_arguments)

    site_url: "TextActivityGraphQLField" = TextActivityGraphQLField("siteUrl")
    is_locked: "TextActivityGraphQLField" = TextActivityGraphQLField("isLocked")
    is_subscribed: "TextActivityGraphQLField" = TextActivityGraphQLField("isSubscribed")
    like_count: "TextActivityGraphQLField" = TextActivityGraphQLField("likeCount")
    is_liked: "TextActivityGraphQLField" = TextActivityGraphQLField("isLiked")
    is_pinned: "TextActivityGraphQLField" = TextActivityGraphQLField("isPinned")
    created_at: "TextActivityGraphQLField" = TextActivityGraphQLField("createdAt")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    @classmethod
    def replies(cls) -> "ActivityReplyFields":
        return ActivityReplyFields("replies")

    @classmethod
    def likes(cls) -> "UserFields":
        return UserFields("likes")

    def fields(
        self,
        *subfields: Union[
            TextActivityGraphQLField, "ActivityReplyFields", "UserFields"
        ],
    ) -> "TextActivityFields":
        """Subfields should come from the TextActivityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TextActivityFields":
        self._alias = alias
        return self


class ThreadFields(GraphQLField):
    id: "ThreadGraphQLField" = ThreadGraphQLField("id")
    title: "ThreadGraphQLField" = ThreadGraphQLField("title")

    @classmethod
    def body(cls, *, as_html: Optional[bool] = None) -> "ThreadGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ThreadGraphQLField("body", arguments=cleared_arguments)

    user_id: "ThreadGraphQLField" = ThreadGraphQLField("userId")
    reply_user_id: "ThreadGraphQLField" = ThreadGraphQLField("replyUserId")
    reply_comment_id: "ThreadGraphQLField" = ThreadGraphQLField("replyCommentId")
    reply_count: "ThreadGraphQLField" = ThreadGraphQLField("replyCount")
    view_count: "ThreadGraphQLField" = ThreadGraphQLField("viewCount")
    is_locked: "ThreadGraphQLField" = ThreadGraphQLField("isLocked")
    is_sticky: "ThreadGraphQLField" = ThreadGraphQLField("isSticky")
    is_subscribed: "ThreadGraphQLField" = ThreadGraphQLField("isSubscribed")
    like_count: "ThreadGraphQLField" = ThreadGraphQLField("likeCount")
    is_liked: "ThreadGraphQLField" = ThreadGraphQLField("isLiked")
    replied_at: "ThreadGraphQLField" = ThreadGraphQLField("repliedAt")
    created_at: "ThreadGraphQLField" = ThreadGraphQLField("createdAt")
    updated_at: "ThreadGraphQLField" = ThreadGraphQLField("updatedAt")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    @classmethod
    def reply_user(cls) -> "UserFields":
        return UserFields("replyUser")

    @classmethod
    def likes(cls) -> "UserFields":
        return UserFields("likes")

    site_url: "ThreadGraphQLField" = ThreadGraphQLField("siteUrl")

    @classmethod
    def categories(cls) -> "ThreadCategoryFields":
        return ThreadCategoryFields("categories")

    @classmethod
    def media_categories(cls) -> "MediaFields":
        return MediaFields("mediaCategories")

    def fields(
        self,
        *subfields: Union[
            ThreadGraphQLField, "MediaFields", "ThreadCategoryFields", "UserFields"
        ],
    ) -> "ThreadFields":
        """Subfields should come from the ThreadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThreadFields":
        self._alias = alias
        return self


class ThreadCategoryFields(GraphQLField):
    id: "ThreadCategoryGraphQLField" = ThreadCategoryGraphQLField("id")
    name: "ThreadCategoryGraphQLField" = ThreadCategoryGraphQLField("name")

    def fields(self, *subfields: ThreadCategoryGraphQLField) -> "ThreadCategoryFields":
        """Subfields should come from the ThreadCategoryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThreadCategoryFields":
        self._alias = alias
        return self


class ThreadCommentFields(GraphQLField):
    id: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField("id")
    user_id: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField("userId")
    thread_id: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField("threadId")

    @classmethod
    def comment(cls, *, as_html: Optional[bool] = None) -> "ThreadCommentGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ThreadCommentGraphQLField("comment", arguments=cleared_arguments)

    like_count: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField("likeCount")
    is_liked: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField("isLiked")
    site_url: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField("siteUrl")
    created_at: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField("createdAt")
    updated_at: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField("updatedAt")

    @classmethod
    def thread(cls) -> "ThreadFields":
        return ThreadFields("thread")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    @classmethod
    def likes(cls) -> "UserFields":
        return UserFields("likes")

    child_comments: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField(
        "childComments"
    )
    is_locked: "ThreadCommentGraphQLField" = ThreadCommentGraphQLField("isLocked")

    def fields(
        self, *subfields: Union[ThreadCommentGraphQLField, "ThreadFields", "UserFields"]
    ) -> "ThreadCommentFields":
        """Subfields should come from the ThreadCommentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThreadCommentFields":
        self._alias = alias
        return self


class ThreadCommentLikeNotificationFields(GraphQLField):
    id: "ThreadCommentLikeNotificationGraphQLField" = (
        ThreadCommentLikeNotificationGraphQLField("id")
    )
    user_id: "ThreadCommentLikeNotificationGraphQLField" = (
        ThreadCommentLikeNotificationGraphQLField("userId")
    )
    type: "ThreadCommentLikeNotificationGraphQLField" = (
        ThreadCommentLikeNotificationGraphQLField("type")
    )
    comment_id: "ThreadCommentLikeNotificationGraphQLField" = (
        ThreadCommentLikeNotificationGraphQLField("commentId")
    )
    context: "ThreadCommentLikeNotificationGraphQLField" = (
        ThreadCommentLikeNotificationGraphQLField("context")
    )
    created_at: "ThreadCommentLikeNotificationGraphQLField" = (
        ThreadCommentLikeNotificationGraphQLField("createdAt")
    )

    @classmethod
    def thread(cls) -> "ThreadFields":
        return ThreadFields("thread")

    @classmethod
    def comment(cls) -> "ThreadCommentFields":
        return ThreadCommentFields("comment")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ThreadCommentLikeNotificationGraphQLField,
            "ThreadCommentFields",
            "ThreadFields",
            "UserFields",
        ],
    ) -> "ThreadCommentLikeNotificationFields":
        """Subfields should come from the ThreadCommentLikeNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThreadCommentLikeNotificationFields":
        self._alias = alias
        return self


class ThreadCommentMentionNotificationFields(GraphQLField):
    id: "ThreadCommentMentionNotificationGraphQLField" = (
        ThreadCommentMentionNotificationGraphQLField("id")
    )
    user_id: "ThreadCommentMentionNotificationGraphQLField" = (
        ThreadCommentMentionNotificationGraphQLField("userId")
    )
    type: "ThreadCommentMentionNotificationGraphQLField" = (
        ThreadCommentMentionNotificationGraphQLField("type")
    )
    comment_id: "ThreadCommentMentionNotificationGraphQLField" = (
        ThreadCommentMentionNotificationGraphQLField("commentId")
    )
    context: "ThreadCommentMentionNotificationGraphQLField" = (
        ThreadCommentMentionNotificationGraphQLField("context")
    )
    created_at: "ThreadCommentMentionNotificationGraphQLField" = (
        ThreadCommentMentionNotificationGraphQLField("createdAt")
    )

    @classmethod
    def thread(cls) -> "ThreadFields":
        return ThreadFields("thread")

    @classmethod
    def comment(cls) -> "ThreadCommentFields":
        return ThreadCommentFields("comment")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ThreadCommentMentionNotificationGraphQLField,
            "ThreadCommentFields",
            "ThreadFields",
            "UserFields",
        ],
    ) -> "ThreadCommentMentionNotificationFields":
        """Subfields should come from the ThreadCommentMentionNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThreadCommentMentionNotificationFields":
        self._alias = alias
        return self


class ThreadCommentReplyNotificationFields(GraphQLField):
    id: "ThreadCommentReplyNotificationGraphQLField" = (
        ThreadCommentReplyNotificationGraphQLField("id")
    )
    user_id: "ThreadCommentReplyNotificationGraphQLField" = (
        ThreadCommentReplyNotificationGraphQLField("userId")
    )
    type: "ThreadCommentReplyNotificationGraphQLField" = (
        ThreadCommentReplyNotificationGraphQLField("type")
    )
    comment_id: "ThreadCommentReplyNotificationGraphQLField" = (
        ThreadCommentReplyNotificationGraphQLField("commentId")
    )
    context: "ThreadCommentReplyNotificationGraphQLField" = (
        ThreadCommentReplyNotificationGraphQLField("context")
    )
    created_at: "ThreadCommentReplyNotificationGraphQLField" = (
        ThreadCommentReplyNotificationGraphQLField("createdAt")
    )

    @classmethod
    def thread(cls) -> "ThreadFields":
        return ThreadFields("thread")

    @classmethod
    def comment(cls) -> "ThreadCommentFields":
        return ThreadCommentFields("comment")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ThreadCommentReplyNotificationGraphQLField,
            "ThreadCommentFields",
            "ThreadFields",
            "UserFields",
        ],
    ) -> "ThreadCommentReplyNotificationFields":
        """Subfields should come from the ThreadCommentReplyNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThreadCommentReplyNotificationFields":
        self._alias = alias
        return self


class ThreadCommentSubscribedNotificationFields(GraphQLField):
    id: "ThreadCommentSubscribedNotificationGraphQLField" = (
        ThreadCommentSubscribedNotificationGraphQLField("id")
    )
    user_id: "ThreadCommentSubscribedNotificationGraphQLField" = (
        ThreadCommentSubscribedNotificationGraphQLField("userId")
    )
    type: "ThreadCommentSubscribedNotificationGraphQLField" = (
        ThreadCommentSubscribedNotificationGraphQLField("type")
    )
    comment_id: "ThreadCommentSubscribedNotificationGraphQLField" = (
        ThreadCommentSubscribedNotificationGraphQLField("commentId")
    )
    context: "ThreadCommentSubscribedNotificationGraphQLField" = (
        ThreadCommentSubscribedNotificationGraphQLField("context")
    )
    created_at: "ThreadCommentSubscribedNotificationGraphQLField" = (
        ThreadCommentSubscribedNotificationGraphQLField("createdAt")
    )

    @classmethod
    def thread(cls) -> "ThreadFields":
        return ThreadFields("thread")

    @classmethod
    def comment(cls) -> "ThreadCommentFields":
        return ThreadCommentFields("comment")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ThreadCommentSubscribedNotificationGraphQLField,
            "ThreadCommentFields",
            "ThreadFields",
            "UserFields",
        ],
    ) -> "ThreadCommentSubscribedNotificationFields":
        """Subfields should come from the ThreadCommentSubscribedNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThreadCommentSubscribedNotificationFields":
        self._alias = alias
        return self


class ThreadLikeNotificationFields(GraphQLField):
    id: "ThreadLikeNotificationGraphQLField" = ThreadLikeNotificationGraphQLField("id")
    user_id: "ThreadLikeNotificationGraphQLField" = ThreadLikeNotificationGraphQLField(
        "userId"
    )
    type: "ThreadLikeNotificationGraphQLField" = ThreadLikeNotificationGraphQLField(
        "type"
    )
    thread_id: "ThreadLikeNotificationGraphQLField" = (
        ThreadLikeNotificationGraphQLField("threadId")
    )
    context: "ThreadLikeNotificationGraphQLField" = ThreadLikeNotificationGraphQLField(
        "context"
    )
    created_at: "ThreadLikeNotificationGraphQLField" = (
        ThreadLikeNotificationGraphQLField("createdAt")
    )

    @classmethod
    def thread(cls) -> "ThreadFields":
        return ThreadFields("thread")

    @classmethod
    def comment(cls) -> "ThreadCommentFields":
        return ThreadCommentFields("comment")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self,
        *subfields: Union[
            ThreadLikeNotificationGraphQLField,
            "ThreadCommentFields",
            "ThreadFields",
            "UserFields",
        ],
    ) -> "ThreadLikeNotificationFields":
        """Subfields should come from the ThreadLikeNotificationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThreadLikeNotificationFields":
        self._alias = alias
        return self


class UserFields(GraphQLField):
    id: "UserGraphQLField" = UserGraphQLField("id")
    name: "UserGraphQLField" = UserGraphQLField("name")

    @classmethod
    def about(cls, *, as_html: Optional[bool] = None) -> "UserGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "asHtml": {"type": "Boolean", "value": as_html}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserGraphQLField("about", arguments=cleared_arguments)

    @classmethod
    def avatar(cls) -> "UserAvatarFields":
        return UserAvatarFields("avatar")

    banner_image: "UserGraphQLField" = UserGraphQLField("bannerImage")
    is_following: "UserGraphQLField" = UserGraphQLField("isFollowing")
    is_follower: "UserGraphQLField" = UserGraphQLField("isFollower")
    is_blocked: "UserGraphQLField" = UserGraphQLField("isBlocked")
    bans: "UserGraphQLField" = UserGraphQLField("bans")

    @classmethod
    def options(cls) -> "UserOptionsFields":
        return UserOptionsFields("options")

    @classmethod
    def media_list_options(cls) -> "MediaListOptionsFields":
        return MediaListOptionsFields("mediaListOptions")

    @classmethod
    def favourites(cls, *, page: Optional[int] = None) -> "FavouritesFields":
        arguments: Dict[str, Dict[str, Any]] = {"page": {"type": "Int", "value": page}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FavouritesFields("favourites", arguments=cleared_arguments)

    @classmethod
    def statistics(cls) -> "UserStatisticTypesFields":
        return UserStatisticTypesFields("statistics")

    unread_notification_count: "UserGraphQLField" = UserGraphQLField(
        "unreadNotificationCount"
    )
    site_url: "UserGraphQLField" = UserGraphQLField("siteUrl")
    donator_tier: "UserGraphQLField" = UserGraphQLField("donatorTier")
    donator_badge: "UserGraphQLField" = UserGraphQLField("donatorBadge")
    moderator_roles: "UserGraphQLField" = UserGraphQLField("moderatorRoles")
    created_at: "UserGraphQLField" = UserGraphQLField("createdAt")
    updated_at: "UserGraphQLField" = UserGraphQLField("updatedAt")

    @classmethod
    def stats(cls) -> "UserStatsFields":
        return UserStatsFields("stats")

    moderator_status: "UserGraphQLField" = UserGraphQLField("moderatorStatus")

    @classmethod
    def previous_names(cls) -> "UserPreviousNameFields":
        return UserPreviousNameFields("previousNames")

    def fields(
        self,
        *subfields: Union[
            UserGraphQLField,
            "FavouritesFields",
            "MediaListOptionsFields",
            "UserAvatarFields",
            "UserOptionsFields",
            "UserPreviousNameFields",
            "UserStatisticTypesFields",
            "UserStatsFields",
        ],
    ) -> "UserFields":
        """Subfields should come from the UserFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserFields":
        self._alias = alias
        return self


class UserActivityHistoryFields(GraphQLField):
    date: "UserActivityHistoryGraphQLField" = UserActivityHistoryGraphQLField("date")
    amount: "UserActivityHistoryGraphQLField" = UserActivityHistoryGraphQLField(
        "amount"
    )
    level: "UserActivityHistoryGraphQLField" = UserActivityHistoryGraphQLField("level")

    def fields(
        self, *subfields: UserActivityHistoryGraphQLField
    ) -> "UserActivityHistoryFields":
        """Subfields should come from the UserActivityHistoryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserActivityHistoryFields":
        self._alias = alias
        return self


class UserAvatarFields(GraphQLField):
    large: "UserAvatarGraphQLField" = UserAvatarGraphQLField("large")
    medium: "UserAvatarGraphQLField" = UserAvatarGraphQLField("medium")

    def fields(self, *subfields: UserAvatarGraphQLField) -> "UserAvatarFields":
        """Subfields should come from the UserAvatarFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserAvatarFields":
        self._alias = alias
        return self


class UserCountryStatisticFields(GraphQLField):
    count: "UserCountryStatisticGraphQLField" = UserCountryStatisticGraphQLField(
        "count"
    )
    mean_score: "UserCountryStatisticGraphQLField" = UserCountryStatisticGraphQLField(
        "meanScore"
    )
    minutes_watched: "UserCountryStatisticGraphQLField" = (
        UserCountryStatisticGraphQLField("minutesWatched")
    )
    chapters_read: "UserCountryStatisticGraphQLField" = (
        UserCountryStatisticGraphQLField("chaptersRead")
    )
    media_ids: "UserCountryStatisticGraphQLField" = UserCountryStatisticGraphQLField(
        "mediaIds"
    )
    country: "UserCountryStatisticGraphQLField" = UserCountryStatisticGraphQLField(
        "country"
    )

    def fields(
        self, *subfields: UserCountryStatisticGraphQLField
    ) -> "UserCountryStatisticFields":
        """Subfields should come from the UserCountryStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserCountryStatisticFields":
        self._alias = alias
        return self


class UserFormatStatisticFields(GraphQLField):
    count: "UserFormatStatisticGraphQLField" = UserFormatStatisticGraphQLField("count")
    mean_score: "UserFormatStatisticGraphQLField" = UserFormatStatisticGraphQLField(
        "meanScore"
    )
    minutes_watched: "UserFormatStatisticGraphQLField" = (
        UserFormatStatisticGraphQLField("minutesWatched")
    )
    chapters_read: "UserFormatStatisticGraphQLField" = UserFormatStatisticGraphQLField(
        "chaptersRead"
    )
    media_ids: "UserFormatStatisticGraphQLField" = UserFormatStatisticGraphQLField(
        "mediaIds"
    )
    format: "UserFormatStatisticGraphQLField" = UserFormatStatisticGraphQLField(
        "format"
    )

    def fields(
        self, *subfields: UserFormatStatisticGraphQLField
    ) -> "UserFormatStatisticFields":
        """Subfields should come from the UserFormatStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserFormatStatisticFields":
        self._alias = alias
        return self


class UserGenreStatisticFields(GraphQLField):
    count: "UserGenreStatisticGraphQLField" = UserGenreStatisticGraphQLField("count")
    mean_score: "UserGenreStatisticGraphQLField" = UserGenreStatisticGraphQLField(
        "meanScore"
    )
    minutes_watched: "UserGenreStatisticGraphQLField" = UserGenreStatisticGraphQLField(
        "minutesWatched"
    )
    chapters_read: "UserGenreStatisticGraphQLField" = UserGenreStatisticGraphQLField(
        "chaptersRead"
    )
    media_ids: "UserGenreStatisticGraphQLField" = UserGenreStatisticGraphQLField(
        "mediaIds"
    )
    genre: "UserGenreStatisticGraphQLField" = UserGenreStatisticGraphQLField("genre")

    def fields(
        self, *subfields: UserGenreStatisticGraphQLField
    ) -> "UserGenreStatisticFields":
        """Subfields should come from the UserGenreStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserGenreStatisticFields":
        self._alias = alias
        return self


class UserLengthStatisticFields(GraphQLField):
    count: "UserLengthStatisticGraphQLField" = UserLengthStatisticGraphQLField("count")
    mean_score: "UserLengthStatisticGraphQLField" = UserLengthStatisticGraphQLField(
        "meanScore"
    )
    minutes_watched: "UserLengthStatisticGraphQLField" = (
        UserLengthStatisticGraphQLField("minutesWatched")
    )
    chapters_read: "UserLengthStatisticGraphQLField" = UserLengthStatisticGraphQLField(
        "chaptersRead"
    )
    media_ids: "UserLengthStatisticGraphQLField" = UserLengthStatisticGraphQLField(
        "mediaIds"
    )
    length: "UserLengthStatisticGraphQLField" = UserLengthStatisticGraphQLField(
        "length"
    )

    def fields(
        self, *subfields: UserLengthStatisticGraphQLField
    ) -> "UserLengthStatisticFields":
        """Subfields should come from the UserLengthStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserLengthStatisticFields":
        self._alias = alias
        return self


class UserOptionsFields(GraphQLField):
    title_language: "UserOptionsGraphQLField" = UserOptionsGraphQLField("titleLanguage")
    display_adult_content: "UserOptionsGraphQLField" = UserOptionsGraphQLField(
        "displayAdultContent"
    )
    airing_notifications: "UserOptionsGraphQLField" = UserOptionsGraphQLField(
        "airingNotifications"
    )
    profile_color: "UserOptionsGraphQLField" = UserOptionsGraphQLField("profileColor")

    @classmethod
    def notification_options(cls) -> "NotificationOptionFields":
        return NotificationOptionFields("notificationOptions")

    timezone: "UserOptionsGraphQLField" = UserOptionsGraphQLField("timezone")
    activity_merge_time: "UserOptionsGraphQLField" = UserOptionsGraphQLField(
        "activityMergeTime"
    )
    staff_name_language: "UserOptionsGraphQLField" = UserOptionsGraphQLField(
        "staffNameLanguage"
    )
    restrict_messages_to_following: "UserOptionsGraphQLField" = UserOptionsGraphQLField(
        "restrictMessagesToFollowing"
    )

    @classmethod
    def disabled_list_activity(cls) -> "ListActivityOptionFields":
        return ListActivityOptionFields("disabledListActivity")

    def fields(
        self,
        *subfields: Union[
            UserOptionsGraphQLField,
            "ListActivityOptionFields",
            "NotificationOptionFields",
        ],
    ) -> "UserOptionsFields":
        """Subfields should come from the UserOptionsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserOptionsFields":
        self._alias = alias
        return self


class UserPreviousNameFields(GraphQLField):
    name: "UserPreviousNameGraphQLField" = UserPreviousNameGraphQLField("name")
    created_at: "UserPreviousNameGraphQLField" = UserPreviousNameGraphQLField(
        "createdAt"
    )
    updated_at: "UserPreviousNameGraphQLField" = UserPreviousNameGraphQLField(
        "updatedAt"
    )

    def fields(
        self, *subfields: UserPreviousNameGraphQLField
    ) -> "UserPreviousNameFields":
        """Subfields should come from the UserPreviousNameFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserPreviousNameFields":
        self._alias = alias
        return self


class UserReleaseYearStatisticFields(GraphQLField):
    count: "UserReleaseYearStatisticGraphQLField" = (
        UserReleaseYearStatisticGraphQLField("count")
    )
    mean_score: "UserReleaseYearStatisticGraphQLField" = (
        UserReleaseYearStatisticGraphQLField("meanScore")
    )
    minutes_watched: "UserReleaseYearStatisticGraphQLField" = (
        UserReleaseYearStatisticGraphQLField("minutesWatched")
    )
    chapters_read: "UserReleaseYearStatisticGraphQLField" = (
        UserReleaseYearStatisticGraphQLField("chaptersRead")
    )
    media_ids: "UserReleaseYearStatisticGraphQLField" = (
        UserReleaseYearStatisticGraphQLField("mediaIds")
    )
    release_year: "UserReleaseYearStatisticGraphQLField" = (
        UserReleaseYearStatisticGraphQLField("releaseYear")
    )

    def fields(
        self, *subfields: UserReleaseYearStatisticGraphQLField
    ) -> "UserReleaseYearStatisticFields":
        """Subfields should come from the UserReleaseYearStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserReleaseYearStatisticFields":
        self._alias = alias
        return self


class UserScoreStatisticFields(GraphQLField):
    count: "UserScoreStatisticGraphQLField" = UserScoreStatisticGraphQLField("count")
    mean_score: "UserScoreStatisticGraphQLField" = UserScoreStatisticGraphQLField(
        "meanScore"
    )
    minutes_watched: "UserScoreStatisticGraphQLField" = UserScoreStatisticGraphQLField(
        "minutesWatched"
    )
    chapters_read: "UserScoreStatisticGraphQLField" = UserScoreStatisticGraphQLField(
        "chaptersRead"
    )
    media_ids: "UserScoreStatisticGraphQLField" = UserScoreStatisticGraphQLField(
        "mediaIds"
    )
    score: "UserScoreStatisticGraphQLField" = UserScoreStatisticGraphQLField("score")

    def fields(
        self, *subfields: UserScoreStatisticGraphQLField
    ) -> "UserScoreStatisticFields":
        """Subfields should come from the UserScoreStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserScoreStatisticFields":
        self._alias = alias
        return self


class UserStaffStatisticFields(GraphQLField):
    count: "UserStaffStatisticGraphQLField" = UserStaffStatisticGraphQLField("count")
    mean_score: "UserStaffStatisticGraphQLField" = UserStaffStatisticGraphQLField(
        "meanScore"
    )
    minutes_watched: "UserStaffStatisticGraphQLField" = UserStaffStatisticGraphQLField(
        "minutesWatched"
    )
    chapters_read: "UserStaffStatisticGraphQLField" = UserStaffStatisticGraphQLField(
        "chaptersRead"
    )
    media_ids: "UserStaffStatisticGraphQLField" = UserStaffStatisticGraphQLField(
        "mediaIds"
    )

    @classmethod
    def staff(cls) -> "StaffFields":
        return StaffFields("staff")

    def fields(
        self, *subfields: Union[UserStaffStatisticGraphQLField, "StaffFields"]
    ) -> "UserStaffStatisticFields":
        """Subfields should come from the UserStaffStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserStaffStatisticFields":
        self._alias = alias
        return self


class UserStartYearStatisticFields(GraphQLField):
    count: "UserStartYearStatisticGraphQLField" = UserStartYearStatisticGraphQLField(
        "count"
    )
    mean_score: "UserStartYearStatisticGraphQLField" = (
        UserStartYearStatisticGraphQLField("meanScore")
    )
    minutes_watched: "UserStartYearStatisticGraphQLField" = (
        UserStartYearStatisticGraphQLField("minutesWatched")
    )
    chapters_read: "UserStartYearStatisticGraphQLField" = (
        UserStartYearStatisticGraphQLField("chaptersRead")
    )
    media_ids: "UserStartYearStatisticGraphQLField" = (
        UserStartYearStatisticGraphQLField("mediaIds")
    )
    start_year: "UserStartYearStatisticGraphQLField" = (
        UserStartYearStatisticGraphQLField("startYear")
    )

    def fields(
        self, *subfields: UserStartYearStatisticGraphQLField
    ) -> "UserStartYearStatisticFields":
        """Subfields should come from the UserStartYearStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserStartYearStatisticFields":
        self._alias = alias
        return self


class UserStatisticTypesFields(GraphQLField):
    @classmethod
    def anime(cls) -> "UserStatisticsFields":
        return UserStatisticsFields("anime")

    @classmethod
    def manga(cls) -> "UserStatisticsFields":
        return UserStatisticsFields("manga")

    def fields(
        self, *subfields: Union[UserStatisticTypesGraphQLField, "UserStatisticsFields"]
    ) -> "UserStatisticTypesFields":
        """Subfields should come from the UserStatisticTypesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserStatisticTypesFields":
        self._alias = alias
        return self


class UserStatisticsFields(GraphQLField):
    count: "UserStatisticsGraphQLField" = UserStatisticsGraphQLField("count")
    mean_score: "UserStatisticsGraphQLField" = UserStatisticsGraphQLField("meanScore")
    standard_deviation: "UserStatisticsGraphQLField" = UserStatisticsGraphQLField(
        "standardDeviation"
    )
    minutes_watched: "UserStatisticsGraphQLField" = UserStatisticsGraphQLField(
        "minutesWatched"
    )
    episodes_watched: "UserStatisticsGraphQLField" = UserStatisticsGraphQLField(
        "episodesWatched"
    )
    chapters_read: "UserStatisticsGraphQLField" = UserStatisticsGraphQLField(
        "chaptersRead"
    )
    volumes_read: "UserStatisticsGraphQLField" = UserStatisticsGraphQLField(
        "volumesRead"
    )

    @classmethod
    def formats(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserFormatStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserFormatStatisticFields("formats", arguments=cleared_arguments)

    @classmethod
    def statuses(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserStatusStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserStatusStatisticFields("statuses", arguments=cleared_arguments)

    @classmethod
    def scores(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserScoreStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserScoreStatisticFields("scores", arguments=cleared_arguments)

    @classmethod
    def lengths(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserLengthStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserLengthStatisticFields("lengths", arguments=cleared_arguments)

    @classmethod
    def release_years(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserReleaseYearStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserReleaseYearStatisticFields(
            "releaseYears", arguments=cleared_arguments
        )

    @classmethod
    def start_years(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserStartYearStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserStartYearStatisticFields("startYears", arguments=cleared_arguments)

    @classmethod
    def genres(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserGenreStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserGenreStatisticFields("genres", arguments=cleared_arguments)

    @classmethod
    def tags(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserTagStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserTagStatisticFields("tags", arguments=cleared_arguments)

    @classmethod
    def countries(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserCountryStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserCountryStatisticFields("countries", arguments=cleared_arguments)

    @classmethod
    def voice_actors(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserVoiceActorStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserVoiceActorStatisticFields("voiceActors", arguments=cleared_arguments)

    @classmethod
    def staff(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserStaffStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserStaffStatisticFields("staff", arguments=cleared_arguments)

    @classmethod
    def studios(
        cls,
        *,
        limit: Optional[int] = None,
        sort: Optional[List[UserStatisticsSort]] = None,
    ) -> "UserStudioStatisticFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "limit": {"type": "Int", "value": limit},
            "sort": {"type": "[UserStatisticsSort]", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserStudioStatisticFields("studios", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            UserStatisticsGraphQLField,
            "UserCountryStatisticFields",
            "UserFormatStatisticFields",
            "UserGenreStatisticFields",
            "UserLengthStatisticFields",
            "UserReleaseYearStatisticFields",
            "UserScoreStatisticFields",
            "UserStaffStatisticFields",
            "UserStartYearStatisticFields",
            "UserStatusStatisticFields",
            "UserStudioStatisticFields",
            "UserTagStatisticFields",
            "UserVoiceActorStatisticFields",
        ],
    ) -> "UserStatisticsFields":
        """Subfields should come from the UserStatisticsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserStatisticsFields":
        self._alias = alias
        return self


class UserStatsFields(GraphQLField):
    watched_time: "UserStatsGraphQLField" = UserStatsGraphQLField("watchedTime")
    chapters_read: "UserStatsGraphQLField" = UserStatsGraphQLField("chaptersRead")

    @classmethod
    def activity_history(cls) -> "UserActivityHistoryFields":
        return UserActivityHistoryFields("activityHistory")

    @classmethod
    def anime_status_distribution(cls) -> "StatusDistributionFields":
        return StatusDistributionFields("animeStatusDistribution")

    @classmethod
    def manga_status_distribution(cls) -> "StatusDistributionFields":
        return StatusDistributionFields("mangaStatusDistribution")

    @classmethod
    def anime_score_distribution(cls) -> "ScoreDistributionFields":
        return ScoreDistributionFields("animeScoreDistribution")

    @classmethod
    def manga_score_distribution(cls) -> "ScoreDistributionFields":
        return ScoreDistributionFields("mangaScoreDistribution")

    @classmethod
    def anime_list_scores(cls) -> "ListScoreStatsFields":
        return ListScoreStatsFields("animeListScores")

    @classmethod
    def manga_list_scores(cls) -> "ListScoreStatsFields":
        return ListScoreStatsFields("mangaListScores")

    @classmethod
    def favoured_genres_overview(cls) -> "GenreStatsFields":
        return GenreStatsFields("favouredGenresOverview")

    @classmethod
    def favoured_genres(cls) -> "GenreStatsFields":
        return GenreStatsFields("favouredGenres")

    @classmethod
    def favoured_tags(cls) -> "TagStatsFields":
        return TagStatsFields("favouredTags")

    @classmethod
    def favoured_actors(cls) -> "StaffStatsFields":
        return StaffStatsFields("favouredActors")

    @classmethod
    def favoured_staff(cls) -> "StaffStatsFields":
        return StaffStatsFields("favouredStaff")

    @classmethod
    def favoured_studios(cls) -> "StudioStatsFields":
        return StudioStatsFields("favouredStudios")

    @classmethod
    def favoured_years(cls) -> "YearStatsFields":
        return YearStatsFields("favouredYears")

    @classmethod
    def favoured_formats(cls) -> "FormatStatsFields":
        return FormatStatsFields("favouredFormats")

    def fields(
        self,
        *subfields: Union[
            UserStatsGraphQLField,
            "FormatStatsFields",
            "GenreStatsFields",
            "ListScoreStatsFields",
            "ScoreDistributionFields",
            "StaffStatsFields",
            "StatusDistributionFields",
            "StudioStatsFields",
            "TagStatsFields",
            "UserActivityHistoryFields",
            "YearStatsFields",
        ],
    ) -> "UserStatsFields":
        """Subfields should come from the UserStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserStatsFields":
        self._alias = alias
        return self


class UserStatusStatisticFields(GraphQLField):
    count: "UserStatusStatisticGraphQLField" = UserStatusStatisticGraphQLField("count")
    mean_score: "UserStatusStatisticGraphQLField" = UserStatusStatisticGraphQLField(
        "meanScore"
    )
    minutes_watched: "UserStatusStatisticGraphQLField" = (
        UserStatusStatisticGraphQLField("minutesWatched")
    )
    chapters_read: "UserStatusStatisticGraphQLField" = UserStatusStatisticGraphQLField(
        "chaptersRead"
    )
    media_ids: "UserStatusStatisticGraphQLField" = UserStatusStatisticGraphQLField(
        "mediaIds"
    )
    status: "UserStatusStatisticGraphQLField" = UserStatusStatisticGraphQLField(
        "status"
    )

    def fields(
        self, *subfields: UserStatusStatisticGraphQLField
    ) -> "UserStatusStatisticFields":
        """Subfields should come from the UserStatusStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserStatusStatisticFields":
        self._alias = alias
        return self


class UserStudioStatisticFields(GraphQLField):
    count: "UserStudioStatisticGraphQLField" = UserStudioStatisticGraphQLField("count")
    mean_score: "UserStudioStatisticGraphQLField" = UserStudioStatisticGraphQLField(
        "meanScore"
    )
    minutes_watched: "UserStudioStatisticGraphQLField" = (
        UserStudioStatisticGraphQLField("minutesWatched")
    )
    chapters_read: "UserStudioStatisticGraphQLField" = UserStudioStatisticGraphQLField(
        "chaptersRead"
    )
    media_ids: "UserStudioStatisticGraphQLField" = UserStudioStatisticGraphQLField(
        "mediaIds"
    )

    @classmethod
    def studio(cls) -> "StudioFields":
        return StudioFields("studio")

    def fields(
        self, *subfields: Union[UserStudioStatisticGraphQLField, "StudioFields"]
    ) -> "UserStudioStatisticFields":
        """Subfields should come from the UserStudioStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserStudioStatisticFields":
        self._alias = alias
        return self


class UserTagStatisticFields(GraphQLField):
    count: "UserTagStatisticGraphQLField" = UserTagStatisticGraphQLField("count")
    mean_score: "UserTagStatisticGraphQLField" = UserTagStatisticGraphQLField(
        "meanScore"
    )
    minutes_watched: "UserTagStatisticGraphQLField" = UserTagStatisticGraphQLField(
        "minutesWatched"
    )
    chapters_read: "UserTagStatisticGraphQLField" = UserTagStatisticGraphQLField(
        "chaptersRead"
    )
    media_ids: "UserTagStatisticGraphQLField" = UserTagStatisticGraphQLField("mediaIds")

    @classmethod
    def tag(cls) -> "MediaTagFields":
        return MediaTagFields("tag")

    def fields(
        self, *subfields: Union[UserTagStatisticGraphQLField, "MediaTagFields"]
    ) -> "UserTagStatisticFields":
        """Subfields should come from the UserTagStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserTagStatisticFields":
        self._alias = alias
        return self


class UserVoiceActorStatisticFields(GraphQLField):
    count: "UserVoiceActorStatisticGraphQLField" = UserVoiceActorStatisticGraphQLField(
        "count"
    )
    mean_score: "UserVoiceActorStatisticGraphQLField" = (
        UserVoiceActorStatisticGraphQLField("meanScore")
    )
    minutes_watched: "UserVoiceActorStatisticGraphQLField" = (
        UserVoiceActorStatisticGraphQLField("minutesWatched")
    )
    chapters_read: "UserVoiceActorStatisticGraphQLField" = (
        UserVoiceActorStatisticGraphQLField("chaptersRead")
    )
    media_ids: "UserVoiceActorStatisticGraphQLField" = (
        UserVoiceActorStatisticGraphQLField("mediaIds")
    )

    @classmethod
    def voice_actor(cls) -> "StaffFields":
        return StaffFields("voiceActor")

    character_ids: "UserVoiceActorStatisticGraphQLField" = (
        UserVoiceActorStatisticGraphQLField("characterIds")
    )

    def fields(
        self, *subfields: Union[UserVoiceActorStatisticGraphQLField, "StaffFields"]
    ) -> "UserVoiceActorStatisticFields":
        """Subfields should come from the UserVoiceActorStatisticFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserVoiceActorStatisticFields":
        self._alias = alias
        return self


class YearStatsFields(GraphQLField):
    year: "YearStatsGraphQLField" = YearStatsGraphQLField("year")
    amount: "YearStatsGraphQLField" = YearStatsGraphQLField("amount")
    mean_score: "YearStatsGraphQLField" = YearStatsGraphQLField("meanScore")

    def fields(self, *subfields: YearStatsGraphQLField) -> "YearStatsFields":
        """Subfields should come from the YearStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "YearStatsFields":
        self._alias = alias
        return self
