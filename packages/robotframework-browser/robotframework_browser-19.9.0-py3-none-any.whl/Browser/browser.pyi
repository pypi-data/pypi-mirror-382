# Copyright 2020-     Robot Framework Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import typing
import os
from concurrent.futures import Future
from os import PathLike
import pathlib
from pathlib import Path
from typing import Any

import assertionengine

from robotlibcore import DynamicCore  # type: ignore

from .utils.data_types import *
from .base import LibraryComponent


class Browser(DynamicCore):
    timeout: Any = ...
    scope_stack: typing.Dict = ...
    _old_init_args: typing.Dict = ...
    _playwright_state: Any = ...
    _browser_control: Any = ...


    def __init__(self, *_, auto_closing_level: AutoClosingLevel = AutoClosingLevel.TEST, auto_delete_passed_tracing: bool = False, enable_playwright_debug: typing.Union[PlaywrightLogTypes, bool] = PlaywrightLogTypes.library, enable_presenter_mode: typing.Union[HighLightElement, bool] = False, external_browser_executable: typing.Optional[dict[SupportedBrowsers, str]] = None, highlight_on_failure: bool = False, jsextension: typing.Union[list[str], str, None] = None, language: typing.Optional[str] = None, playwright_process_host: typing.Optional[str] = None, playwright_process_port: typing.Optional[int] = None, plugins: typing.Union[list[str], str, None] = None, retry_assertions_for: timedelta = timedelta(seconds=1.0), run_on_failure: str = 'Take Screenshot  fail-screenshot-{index}', selector_prefix: typing.Optional[str] = None, show_keyword_call_banner: typing.Optional[bool] = None, strict: bool = True, timeout: timedelta = timedelta(seconds=10.0), tracing_group_mode: TracingGroupMode = TracingGroupMode.Full): ...
    def add_cookie(self, name: str, value: str, url: typing.Optional[str] = None, domain: typing.Optional[str] = None, path: typing.Optional[str] = None, expires: typing.Union[str, datetime.datetime, None] = None, httpOnly: typing.Optional[bool] = None, secure: typing.Optional[bool] = None, sameSite: typing.Optional[CookieSameSite] = None): ...
    def add_locator_handler_click(self, selector: str, click_selector: str, *, noWaitAfter: bool = True, times: typing.Optional[int] = None, click_clickCount: int = 1, click_delay: int = 0, click_force: bool = False): ...
    def add_locator_handler_custom(self, selector: str, handler_spec: list, noWaitAfter: bool = True, times: typing.Optional[int] = None): ...
    def add_style_tag(self, content: str): ...
    def advance_clock(self, time: timedelta, advance_type: CLockAdvanceType = CLockAdvanceType.fast_forward): ...
    def cancel_download(self, download: typing.Union[DownloadInfo, str]): ...
    def check_checkbox(self, selector: str, force: bool = False): ...
    def clear_permissions(self): ...
    def clear_text(self, selector: str): ...
    def click(self, selector: str, button: MouseButton = MouseButton.left): ...
    def click_with_options(self, selector: str, button: MouseButton = MouseButton.left, *modifiers: KeyboardModifier, clickCount: int = 1, delay: typing.Optional[datetime.timedelta] = None, force: bool = False, noWaitAfter: bool = False, position_x: typing.Optional[float] = None, position_y: typing.Optional[float] = None, trial: bool = False): ...
    def close_browser(self, browser: typing.Union[SelectionType, str] = SelectionType.CURRENT): ...
    def close_browser_server(self, wsEndpoint: str): ...
    def close_context(self, context: typing.Union[SelectionType, str] = SelectionType.CURRENT, browser: typing.Union[SelectionType, str] = SelectionType.CURRENT, *, save_trace: bool = True): ...
    def close_page(self, page: typing.Union[SelectionType, NewPageDetails, str] = SelectionType.CURRENT, context: typing.Union[SelectionType, str] = SelectionType.CURRENT, browser: typing.Union[SelectionType, str] = SelectionType.CURRENT, runBeforeUnload: bool = False): ...
    def connect_to_browser(self, wsEndpoint: str, browser: SupportedBrowsers = SupportedBrowsers.chromium, use_cdp: bool = False, *, timeout: timedelta = timedelta(seconds=30.0)): ...
    def crawl_site(self, url: typing.Optional[str] = None, page_crawl_keyword = 'take_screenshot', max_number_of_page_to_crawl: int = 1000, max_depth_to_crawl: int = 50): ...
    def delete_all_cookies(self): ...
    def deselect_options(self, selector: str): ...
    def download(self, url: str, saveAs: str = '', wait_for_finished: bool = True, download_timeout: typing.Optional[datetime.timedelta] = None): ...
    def drag_and_drop(self, selector_from: str, selector_to: str, steps: int = 1): ...
    def drag_and_drop_by_coordinates(self, from_x: float, from_y: float, to_x: float, to_y: float, steps: int = 1): ...
    def drag_and_drop_relative_to(self, selector_from: str, x: float = 0.0, y: float = 0.0, steps: int = 1): ...
    def eat_all_cookies(self): ...
    def emulate_media(self, colorScheme: typing.Optional[ColorScheme] = None, forcedColors: typing.Union[ForcedColors, NotSet] = NotSet.not_set, media: typing.Optional[Media] = None, reducedMotion: typing.Optional[ReducedMotion] = None): ...
    def evaluate_javascript(self, selector: typing.Optional[str] = None, *function: str, arg: typing.Any = None, all_elements: bool = False): ...
    def fill_secret(self, selector: str, secret: str, force: bool = False): ...
    def fill_text(self, selector: str, txt: str, force: bool = False): ...
    def focus(self, selector: str): ...
    def get_attribute(self, selector: str, attribute: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_attribute_names(self, selector: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, *assertion_expected, message: typing.Optional[str] = None): ...
    def get_boundingbox(self, selector: str, key: BoundingBoxFields = BoundingBoxFields.ALL, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None, *, allow_hidden: bool = False): ...
    def get_browser_catalog(self, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_browser_ids(self, browser: SelectionType = SelectionType.ALL, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, *assertion_expected: typing.Optional[typing.Any], message: typing.Optional[str] = None): ...
    def get_checkbox_state(self, selector: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Union[bool, str] = 'Unchecked', message: typing.Optional[str] = None): ...
    def get_classes(self, selector: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, *assertion_expected, message: typing.Optional[str] = None): ...
    def get_client_size(self, selector: typing.Optional[str] = None, key: SizeFields = SizeFields.ALL, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_console_log(self, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None, *, full: bool = False, last: typing.Union[int, datetime.timedelta, None] = None): ...
    def get_context_ids(self, context: SelectionType = SelectionType.ALL, browser: typing.Union[SelectionType, str] = SelectionType.ALL, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, *assertion_expected: typing.Optional[typing.Any], message: typing.Optional[str] = None): ...
    def get_cookie(self, cookie: str, return_type: CookieType = CookieType.dictionary): ...
    def get_cookies(self, return_type: CookieType = CookieType.dictionary): ...
    def get_device(self, name: str): ...
    def get_devices(self): ...
    def get_download_state(self, download: typing.Union[DownloadInfo, str], assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_element(self, selector: str): ...
    def get_element_by(self, selection_strategy: SelectionStrategy, text: typing.Union[str, RegExp], exact: bool = False, all_elements: bool = False): ...
    def get_element_by_role(self, role: ElementRole, *, all_elements: bool = False, checked: typing.Optional[bool] = None, disabled: typing.Optional[bool] = None, exact: typing.Optional[bool] = None, expanded: typing.Optional[bool] = None, include_hidden: typing.Optional[bool] = None, level: typing.Optional[int] = None, name: typing.Union[str, RegExp, None] = None, pressed: typing.Optional[bool] = None, selected: typing.Optional[bool] = None): ...
    def get_element_count(self, selector: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Union[int, str] = 0, message: typing.Optional[str] = None): ...
    def get_element_states(self, selector: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, *assertion_expected: typing.Union[ElementState, str], message: typing.Optional[str] = None, return_names = True): ...
    def get_elements(self, selector: str): ...
    def get_page_errors(self, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None, *, full: bool = False, last: typing.Union[int, datetime.timedelta, None] = None): ...
    def get_page_ids(self, page: SelectionType = SelectionType.ALL, context: typing.Union[SelectionType, str] = SelectionType.ALL, browser: typing.Union[SelectionType, str] = SelectionType.ALL, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, *assertion_expected: typing.Optional[typing.Any], message: typing.Optional[str] = None): ...
    def get_page_source(self, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_property(self, selector: str, property: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_scroll_position(self, selector: typing.Optional[str] = None, key: AreaFields = AreaFields.ALL, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_scroll_size(self, selector: typing.Optional[str] = None, key: SizeFields = SizeFields.ALL, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_select_options(self, selector: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_selected_options(self, selector: str, option_attribute: SelectAttribute = SelectAttribute.label, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, *assertion_expected, message: typing.Optional[str] = None): ...
    def get_style(self, selector: str, key: typing.Optional[str] = 'ALL', assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None, pseudo_element: typing.Optional[str] = None): ...
    def get_table_cell_element(self, table: str, column: str, row: str): ...
    def get_table_cell_index(self, selector: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Union[int, str] = 0, message: typing.Optional[str] = None): ...
    def get_table_row_index(self, selector: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Union[int, str] = 0, message: typing.Optional[str] = None): ...
    def get_text(self, selector: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_title(self, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_url(self, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def get_viewport_size(self, key: SizeFields = SizeFields.ALL, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None): ...
    def go_back(self): ...
    def go_forward(self): ...
    def go_to(self, url: str, timeout: typing.Optional[datetime.timedelta] = None, wait_until: PageLoadStates = PageLoadStates.load): ...
    def grant_permissions(self, *permissions: Permission, origin: typing.Optional[str] = None): ...
    def handle_future_dialogs(self, action: DialogAction, prompt_input: str = ''): ...
    def highlight_elements(self, selector: str, duration: timedelta = timedelta(seconds=5.0), width: str = '2px', style: str = 'dotted', color: str = 'blue', *, mode: HighlightMode = HighlightMode.border): ...
    def hover(self, selector: str, position_x: typing.Optional[float] = None, position_y: typing.Optional[float] = None, force: bool = False, *modifiers: KeyboardModifier): ...
    def http(self, url: str, method: RequestMethod = RequestMethod.GET, body: typing.Optional[str] = None, headers: typing.Optional[dict] = None): ...
    def keyboard_input(self, action: KeyboardInputAction, input: str, delay: typing.Union[int, datetime.timedelta] = timedelta(seconds=0.0)): ...
    def keyboard_key(self, action: KeyAction, key: str): ...
    def launch_browser_server(self, browser: SupportedBrowsers = SupportedBrowsers.chromium, headless: bool = True, *, args: typing.Optional[list[str]] = None, channel: typing.Optional[str] = None, chromiumSandbox: bool = False, devtools: bool = False, downloadsPath: typing.Optional[str] = None, env: typing.Optional[dict] = None, executablePath: typing.Optional[str] = None, firefoxUserPrefs: typing.Optional[dict[str, typing.Union[str, int, float, bool]]] = None, handleSIGHUP: bool = True, handleSIGINT: bool = True, handleSIGTERM: bool = True, ignoreDefaultArgs: typing.Union[list[str], bool, None] = None, port: typing.Optional[int] = None, proxy: typing.Optional[Proxy] = None, reuse_existing: bool = True, slowMo: timedelta = timedelta(seconds=0.0), timeout: timedelta = timedelta(seconds=30.0), wsPath: typing.Optional[str] = None): ...
    def local_storage_clear(self, frame_selector: typing.Optional[str] = None): ...
    def local_storage_get_item(self, key: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None, frame_selector: typing.Optional[str] = None): ...
    def local_storage_remove_item(self, key: str, frame_selector: typing.Optional[str] = None): ...
    def local_storage_set_item(self, key: str, value: str, frame_selector: typing.Optional[str] = None): ...
    def merge_coverage_reports(self, input_folder: Path, output_folder: Path, config_file: typing.Optional[pathlib._local.Path] = None, name: typing.Optional[str] = None, reports: typing.Optional[list[str]] = None): ...
    def mouse_button(self, action: MouseButtonAction, x: typing.Optional[float] = None, y: typing.Optional[float] = None, button: MouseButton = MouseButton.left, clickCount: int = 1, delay: typing.Union[int, datetime.timedelta] = timedelta(seconds=0.0)): ...
    def mouse_move(self, x: float, y: float, steps: int = 1): ...
    def mouse_move_relative_to(self, selector: str, x: float = 0.0, y: float = 0.0, steps: int = 1): ...
    def mouse_wheel(self, deltaX: int, deltaY: int): ...
    def new_browser(self, browser: SupportedBrowsers = SupportedBrowsers.chromium, headless: bool = True, *, args: typing.Optional[list[str]] = None, channel: typing.Optional[str] = None, chromiumSandbox: bool = False, devtools: bool = False, downloadsPath: typing.Optional[str] = None, env: typing.Optional[dict] = None, executablePath: typing.Optional[str] = None, firefoxUserPrefs: typing.Optional[dict[str, typing.Union[str, int, float, bool]]] = None, handleSIGHUP: bool = True, handleSIGINT: bool = True, handleSIGTERM: bool = True, ignoreDefaultArgs: typing.Union[list[str], bool, None] = None, proxy: typing.Optional[Proxy] = None, reuse_existing: bool = True, slowMo: timedelta = timedelta(seconds=0.0), timeout: timedelta = timedelta(seconds=30.0)): ...
    def new_context(self, *, acceptDownloads: bool = True, baseURL: typing.Optional[str] = None, bypassCSP: bool = False, clientCertificates: typing.Optional[list[ClientCertificate]] = None, colorScheme: typing.Optional[ColorScheme] = None, defaultBrowserType: typing.Optional[SupportedBrowsers] = None, deviceScaleFactor: typing.Optional[float] = None, extraHTTPHeaders: typing.Optional[dict[str, str]] = None, forcedColors: ForcedColors = ForcedColors.none, geolocation: typing.Optional[GeoLocation] = None, hasTouch: typing.Optional[bool] = None, httpCredentials: typing.Optional[HttpCredentials] = None, ignoreHTTPSErrors: bool = False, isMobile: typing.Optional[bool] = None, javaScriptEnabled: bool = True, locale: typing.Optional[str] = None, offline: bool = False, permissions: typing.Optional[list[Permission]] = None, proxy: typing.Optional[Proxy] = None, recordHar: typing.Optional[RecordHar] = None, recordVideo: typing.Optional[RecordVideo] = None, reducedMotion: ReduceMotion = ReduceMotion.no_preference, screen: typing.Optional[dict[str, int]] = None, serviceWorkers: typing.Optional[ServiceWorkersPermissions] = ServiceWorkersPermissions.allow, storageState: typing.Optional[str] = None, timezoneId: typing.Optional[str] = None, tracing: typing.Union[bool, pathlib._local.Path, None] = None, userAgent: typing.Optional[str] = None, viewport: typing.Optional[ViewportDimensions] = {'width': 1280, 'height': 720}): ...
    def new_page(self, url: typing.Optional[str] = None, wait_until: PageLoadStates = PageLoadStates.load): ...
    def new_persistent_context(self, userDataDir: str = '', browser: SupportedBrowsers = SupportedBrowsers.chromium, headless: bool = True, *, acceptDownloads: bool = True, args: typing.Optional[list[str]] = None, baseURL: typing.Optional[str] = None, bypassCSP: bool = False, channel: typing.Optional[str] = None, chromiumSandbox: bool = False, colorScheme: typing.Optional[ColorScheme] = None, defaultBrowserType: typing.Optional[SupportedBrowsers] = None, deviceScaleFactor: typing.Optional[float] = None, devtools: bool = False, downloadsPath: typing.Optional[str] = None, env: typing.Optional[dict] = None, executablePath: typing.Optional[str] = None, extraHTTPHeaders: typing.Optional[dict[str, str]] = None, forcedColors: ForcedColors = ForcedColors.none, geolocation: typing.Optional[GeoLocation] = None, handleSIGHUP: bool = True, handleSIGINT: bool = True, handleSIGTERM: bool = True, hasTouch: typing.Optional[bool] = None, httpCredentials: typing.Optional[HttpCredentials] = None, ignoreDefaultArgs: typing.Union[list[str], bool, None] = None, ignoreHTTPSErrors: bool = False, isMobile: typing.Optional[bool] = None, javaScriptEnabled: bool = True, locale: typing.Optional[str] = None, offline: bool = False, permissions: typing.Optional[list[Permission]] = None, proxy: typing.Optional[Proxy] = None, recordHar: typing.Optional[RecordHar] = None, recordVideo: typing.Optional[RecordVideo] = None, reducedMotion: ReduceMotion = ReduceMotion.no_preference, screen: typing.Optional[dict[str, int]] = None, serviceWorkers: typing.Optional[ServiceWorkersPermissions] = ServiceWorkersPermissions.allow, slowMo: timedelta = timedelta(seconds=0.0), timeout: timedelta = timedelta(seconds=30.0), timezoneId: typing.Optional[str] = None, tracing: typing.Union[bool, pathlib._local.Path, None] = None, url: typing.Optional[str] = None, userAgent: typing.Optional[str] = None, viewport: typing.Optional[ViewportDimensions] = {'width': 1280, 'height': 720}): ...
    def open_browser(self, url: typing.Optional[str] = None, browser: SupportedBrowsers = SupportedBrowsers.chromium, headless: bool = False, pause_on_failure: bool = True, bypassCSP = True): ...
    def pause_at(self, time: datetime.datetime): ...
    def press_keys(self, selector: str, *keys: str, press_duration: timedelta = timedelta(seconds=0.0), key_delay: timedelta = timedelta(seconds=0.0)): ...
    def promise_to(self, kw: str, *args): ...
    def promise_to_upload_file(self, path: PathLike): ...
    def promise_to_wait_for_download(self, saveAs: str = '', wait_for_finished: bool = True, download_timeout: typing.Optional[datetime.timedelta] = None): ...
    def record_selector(self, label: typing.Optional[str] = None): ...
    def register_keyword_to_run_on_failure(self, keyword: typing.Optional[str], *args: str, scope: Scope = Scope.Global): ...
    def reload(self, timeout: typing.Optional[datetime.timedelta] = None, waitUntil: PageLoadStates = PageLoadStates.load): ...
    def remove_locator_handler(self, locator: str): ...
    def resume_clock(self): ...
    def save_page_as_pdf(self, path: PathLike, *, displayHeaderFooter: bool = False, footerTemplate: str = '', format: PdfFormat = PdfFormat.Letter, headerTemplate: str = '', height: str = '0px', landscape: bool = False, margin: PdfMarging = {'top': '0px', 'right': '0px', 'bottom': '0px', 'left': '0px'}, outline: bool = False, pageRanges: str = '', preferCSSPageSize: bool = False, printBackground: bool = False, scale: float = 1, tagged: bool = False, width: str = '0px'): ...
    def save_storage_state(self): ...
    def scroll_by(self, selector: typing.Optional[str] = None, vertical: str = 'height', horizontal: str = '0', behavior: ScrollBehavior = ScrollBehavior.auto): ...
    def scroll_to(self, selector: typing.Optional[str] = None, vertical: str = 'top', horizontal: str = 'left', behavior: ScrollBehavior = ScrollBehavior.auto): ...
    def scroll_to_element(self, selector: str): ...
    def select_options_by(self, selector: str, attribute: SelectAttribute, *values): ...
    def session_storage_clear(self, frame_selector: typing.Optional[str] = None): ...
    def session_storage_get_item(self, key: str, assertion_operator: typing.Optional[assertionengine.assertion_engine.AssertionOperator] = None, assertion_expected: typing.Optional[typing.Any] = None, message: typing.Optional[str] = None, frame_selector: typing.Optional[str] = None): ...
    def session_storage_remove_item(self, key: str, frame_selector: typing.Optional[str] = None): ...
    def session_storage_set_item(self, key: str, value: str, frame_selector: typing.Optional[str] = None): ...
    def set_assertion_formatters(self, formatters: typing.Dict[FormatterKeywords, list[typing.Union[FormatingRules, LambdaFunction]]], scope: Scope = Scope.Suite): ...
    def set_browser_timeout(self, timeout: timedelta, scope: Scope = Scope.Suite): ...
    def set_default_run_before_unload(self, runBeforeUnload: bool): ...
    def set_geolocation(self, latitude: float, longitude: float, accuracy: typing.Optional[float] = None): ...
    def set_highlight_on_failure(self, highlight: bool = True, scope: Scope = Scope.Suite): ...
    def set_offline(self, offline: bool = True): ...
    def set_retry_assertions_for(self, timeout: timedelta, scope: Scope = Scope.Suite): ...
    def set_selector_prefix(self, prefix: typing.Optional[str], scope: Scope = Scope.Suite): ...
    def set_strict_mode(self, mode: bool, scope: Scope = Scope.Suite): ...
    def set_time(self, time: datetime.datetime, clock_type: ClockType = ClockType.install): ...
    def set_viewport_size(self, width: int, height: int): ...
    def show_keyword_banner(self, show: bool = True, style: str = '', scope: Scope = Scope.Suite): ...
    def start_coverage(self, *, config_file: typing.Optional[os.PathLike] = None, coverage_type: CoverageType = CoverageType.all, path: Path = pathlib.Path('.'), raw: bool = False, reportAnonymousScripts: bool = False, resetOnNavigation: bool = True): ...
    def stop_coverage(self): ...
    def switch_browser(self, id: str): ...
    def switch_context(self, id: str, browser: typing.Union[SelectionType, str] = SelectionType.CURRENT): ...
    def switch_page(self, id: typing.Union[NewPageDetails, SelectionType, str], context: typing.Union[SelectionType, str] = SelectionType.CURRENT, browser: typing.Union[SelectionType, str] = SelectionType.CURRENT): ...
    def take_screenshot(self, filename: typing.Optional[str] = 'robotframework-browser-screenshot-{index}', selector: typing.Optional[str] = None, *, crop: typing.Optional[BoundingBox] = None, disableAnimations: bool = False, fileType: ScreenshotFileTypes = ScreenshotFileTypes.png, fullPage: bool = False, highlight_selector: typing.Optional[str] = None, log_screenshot: bool = True, mask: typing.Union[list[str], str] = '', maskColor: typing.Optional[str] = None, omitBackground: bool = False, quality: typing.Optional[int] = None, scale: typing.Optional[Scale] = None, return_as: ScreenshotReturnType = ScreenshotReturnType.path_string, timeout: typing.Optional[datetime.timedelta] = None): ...
    def tap(self, selector: str, *modifiers: KeyboardModifier, force: bool = False, noWaitAfter: bool = False, position_x: typing.Optional[int] = None, position_y: typing.Optional[int] = None, trial: bool = False): ...
    def type_secret(self, selector: str, secret: str, delay: timedelta = timedelta(seconds=0.0), clear: bool = True): ...
    def type_text(self, selector: str, txt: str, delay: timedelta = timedelta(seconds=0.0), clear: bool = True): ...
    def uncheck_checkbox(self, selector: str, force: bool = False): ...
    def upload_file_by_selector(self, selector: str, path: typing.Union[os.PathLike, FileUploadBuffer], *extra_paths: PathLike): ...
    def wait_for(self, *promises: Future): ...
    def wait_for_alert(self, action: DialogAction, prompt_input: str = '', text: typing.Optional[str] = None, timeout: typing.Optional[datetime.timedelta] = None): ...
    def wait_for_alerts(self, actions: list, prompt_inputs: list, texts: list, timeout: typing.Optional[datetime.timedelta] = None): ...
    def wait_for_all_promises(self): ...
    def wait_for_condition(self, condition: ConditionInputs, *args: typing.Any, timeout: typing.Optional[datetime.timedelta] = None, message: typing.Optional[str] = None): ...
    def wait_for_elements_state(self, selector: str, state: ElementState = ElementState.visible, timeout: typing.Optional[datetime.timedelta] = None, message: typing.Optional[str] = None): ...
    def wait_for_function(self, function: str, selector: str = '', polling: typing.Union[str, datetime.timedelta] = 'raf', timeout: typing.Optional[datetime.timedelta] = None, message: typing.Optional[str] = None): ...
    def wait_for_load_state(self, state: PageLoadStates = PageLoadStates.load, timeout: typing.Optional[datetime.timedelta] = None): ...
    def wait_for_navigation(self, url: typing.Union[str, RegExp], timeout: typing.Optional[datetime.timedelta] = None, wait_until: PageLoadStates = PageLoadStates.load): ...
    def wait_for_request(self, matcher: typing.Union[str, RegExp] = '', timeout: typing.Optional[datetime.timedelta] = None): ...
    def wait_for_response(self, matcher: typing.Union[str, RegExp] = '', timeout: typing.Optional[datetime.timedelta] = None): ...
    def wait_until_network_is_idle(self, timeout: typing.Optional[datetime.timedelta] = None): ...
    def get_timeout(self, timeout: Union[timedelta, None]) -> float: ...
    def convert_timeout(self, timeout: Union[timedelta, float], to_ms: bool = True) -> float: ...
    def millisecs_to_timestr(self, timeout: float)  -> str: ...
    def get_strict_mode(self, strict: Union[bool, None]) -> bool: ...
    def _parse_run_on_failure_keyword(self, keyword_name: Union[str, None]) -> DelayedKeyword: ...
    def _create_lib_component_from_jsextension(self, jsextension: str) -> LibraryComponent: ...

