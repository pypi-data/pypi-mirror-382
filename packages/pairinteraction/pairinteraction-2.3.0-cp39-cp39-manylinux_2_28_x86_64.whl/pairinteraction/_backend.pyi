# mypy: ignore-errors

from collections.abc import Sequence, Set
import enum
import os
import pathlib
from typing import Annotated, Optional, Union, overload

import numpy
from numpy.typing import NDArray
import scipy


class LogEntry:
    @property
    def level(self) -> int: ...

    @property
    def message(self) -> bytes: ...

def get_pending_logs() -> list[LogEntry]: ...

class OperatorType(enum.Enum):
    ZERO = 0

    ENERGY = 1

    ELECTRIC_DIPOLE = 2

    ELECTRIC_QUADRUPOLE = 3

    ELECTRIC_QUADRUPOLE_ZERO = 4

    ELECTRIC_OCTUPOLE = 5

    MAGNETIC_DIPOLE = 6

    ARBITRARY = 8

class Parity(enum.Enum):
    ODD = -1

    EVEN = 1

    UNKNOWN = 2

class TransformationType(enum.IntEnum):
    IDENTITY = 0

    SORT_BY_KET = 1

    SORT_BY_QUANTUM_NUMBER_F = 2

    SORT_BY_QUANTUM_NUMBER_M = 4

    SORT_BY_PARITY = 8

    SORT_BY_ENERGY = 16

    ROTATE = 32

    ARBITRARY = 64

class FloatType(enum.Enum):
    FLOAT32 = 0

    FLOAT64 = 1

class DiagonalizerInterfaceReal:
    @overload
    def eigh(self, arg0: scipy.sparse.csr_matrix[float], arg1: float, /) -> EigenSystemHReal: ...

    @overload
    def eigh(self, arg0: scipy.sparse.csr_matrix[float], arg1: float, arg2: float, arg3: float, /) -> EigenSystemHReal: ...

class DiagonalizerInterfaceComplex:
    @overload
    def eigh(self, arg0: scipy.sparse.csr_matrix[complex], arg1: float, /) -> EigenSystemHComplex: ...

    @overload
    def eigh(self, arg0: scipy.sparse.csr_matrix[complex], arg1: float, arg2: float, arg3: float, /) -> EigenSystemHComplex: ...

class EigenSystemHReal:
    @property
    def eigenvectors(self) -> scipy.sparse.csr_matrix[float]: ...

    @eigenvectors.setter
    def eigenvectors(self, arg: scipy.sparse.csr_matrix[float], /) -> None: ...

    @property
    def eigenvalues(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @eigenvalues.setter
    def eigenvalues(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')], /) -> None: ...

class EigenSystemHComplex:
    @property
    def eigenvectors(self) -> scipy.sparse.csr_matrix[complex]: ...

    @eigenvectors.setter
    def eigenvectors(self, arg: scipy.sparse.csr_matrix[complex], /) -> None: ...

    @property
    def eigenvalues(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @eigenvalues.setter
    def eigenvalues(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')], /) -> None: ...

class TransformationReal:
    def __init__(self) -> None: ...

    @property
    def matrix(self) -> scipy.sparse.csr_matrix[float]: ...

    @matrix.setter
    def matrix(self, arg: scipy.sparse.csr_matrix[float], /) -> None: ...

    @property
    def transformation_type(self) -> list[TransformationType]: ...

    @transformation_type.setter
    def transformation_type(self, arg: Sequence[TransformationType], /) -> None: ...

class TransformationComplex:
    def __init__(self) -> None: ...

    @property
    def matrix(self) -> scipy.sparse.csr_matrix[complex]: ...

    @matrix.setter
    def matrix(self, arg: scipy.sparse.csr_matrix[complex], /) -> None: ...

    @property
    def transformation_type(self) -> list[TransformationType]: ...

    @transformation_type.setter
    def transformation_type(self, arg: Sequence[TransformationType], /) -> None: ...

class Sorting:
    def __init__(self) -> None: ...

    @property
    def transformation_type(self) -> list[TransformationType]: ...

    @transformation_type.setter
    def transformation_type(self, arg: Sequence[TransformationType], /) -> None: ...

class IndicesOfBlock:
    def __init__(self, start: int, end: int) -> None: ...

    @property
    def start(self) -> int: ...

    @start.setter
    def start(self, arg: int, /) -> None: ...

    @property
    def end(self) -> int: ...

    @end.setter
    def end(self, arg: int, /) -> None: ...

class IndicesOfBlocksCreator:
    pass

class TransformationBuilderInterfaceReal:
    def get_rotator(self, arg0: Sequence[float], arg1: Sequence[float], /) -> TransformationReal: ...

class TransformationBuilderInterfaceComplex:
    def get_rotator(self, arg0: Sequence[float], arg1: Sequence[float], /) -> TransformationComplex: ...

class OperatorOperatorAtomReal(TransformationBuilderInterfaceReal):
    def __init__(self, arg: BasisAtomReal, /) -> None: ...

    def get_basis(self) -> BasisAtomReal: ...

    def get_matrix(self) -> scipy.sparse.csr_matrix[float]: ...

    def get_transformation(self) -> TransformationReal: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationReal: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    @overload
    def transformed(self, arg: TransformationReal, /) -> OperatorAtomReal: ...

    @overload
    def transformed(self, arg: Sorting, /) -> OperatorAtomReal: ...

    def __rmul__(self, arg: float, /) -> OperatorAtomReal: ...

    def __mul__(self, arg: float, /) -> OperatorAtomReal: ...

    def __truediv__(self, arg: float, /) -> OperatorAtomReal: ...

    def __add__(self, arg: OperatorOperatorAtomReal, /) -> OperatorAtomReal: ...

    def __sub__(self, arg: OperatorOperatorAtomReal, /) -> OperatorAtomReal: ...

class OperatorOperatorAtomComplex(TransformationBuilderInterfaceComplex):
    def __init__(self, arg: BasisAtomComplex, /) -> None: ...

    def get_basis(self) -> BasisAtomComplex: ...

    def get_matrix(self) -> scipy.sparse.csr_matrix[complex]: ...

    def get_transformation(self) -> TransformationComplex: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationComplex: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    @overload
    def transformed(self, arg: TransformationComplex, /) -> OperatorAtomComplex: ...

    @overload
    def transformed(self, arg: Sorting, /) -> OperatorAtomComplex: ...

    def __rmul__(self, arg: complex, /) -> OperatorAtomComplex: ...

    def __mul__(self, arg: complex, /) -> OperatorAtomComplex: ...

    def __truediv__(self, arg: complex, /) -> OperatorAtomComplex: ...

    def __add__(self, arg: OperatorOperatorAtomComplex, /) -> OperatorAtomComplex: ...

    def __sub__(self, arg: OperatorOperatorAtomComplex, /) -> OperatorAtomComplex: ...

class OperatorAtomReal(OperatorOperatorAtomReal):
    @overload
    def __init__(self, arg: BasisAtomReal, /) -> None: ...

    @overload
    def __init__(self, arg0: BasisAtomReal, arg1: OperatorType, arg2: int, /) -> None: ...

class OperatorAtomComplex(OperatorOperatorAtomComplex):
    @overload
    def __init__(self, arg: BasisAtomComplex, /) -> None: ...

    @overload
    def __init__(self, arg0: BasisAtomComplex, arg1: OperatorType, arg2: int, /) -> None: ...

class OperatorOperatorPairReal(TransformationBuilderInterfaceReal):
    def __init__(self, arg: BasisPairReal, /) -> None: ...

    def get_basis(self) -> BasisPairReal: ...

    def get_matrix(self) -> scipy.sparse.csr_matrix[float]: ...

    def get_transformation(self) -> TransformationReal: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationReal: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    @overload
    def transformed(self, arg: TransformationReal, /) -> OperatorPairReal: ...

    @overload
    def transformed(self, arg: Sorting, /) -> OperatorPairReal: ...

    def __rmul__(self, arg: float, /) -> OperatorPairReal: ...

    def __mul__(self, arg: float, /) -> OperatorPairReal: ...

    def __truediv__(self, arg: float, /) -> OperatorPairReal: ...

    def __add__(self, arg: OperatorOperatorPairReal, /) -> OperatorPairReal: ...

    def __sub__(self, arg: OperatorOperatorPairReal, /) -> OperatorPairReal: ...

class OperatorOperatorPairComplex(TransformationBuilderInterfaceComplex):
    def __init__(self, arg: BasisPairComplex, /) -> None: ...

    def get_basis(self) -> BasisPairComplex: ...

    def get_matrix(self) -> scipy.sparse.csr_matrix[complex]: ...

    def get_transformation(self) -> TransformationComplex: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationComplex: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    @overload
    def transformed(self, arg: TransformationComplex, /) -> OperatorPairComplex: ...

    @overload
    def transformed(self, arg: Sorting, /) -> OperatorPairComplex: ...

    def __rmul__(self, arg: complex, /) -> OperatorPairComplex: ...

    def __mul__(self, arg: complex, /) -> OperatorPairComplex: ...

    def __truediv__(self, arg: complex, /) -> OperatorPairComplex: ...

    def __add__(self, arg: OperatorOperatorPairComplex, /) -> OperatorPairComplex: ...

    def __sub__(self, arg: OperatorOperatorPairComplex, /) -> OperatorPairComplex: ...

class OperatorPairReal(OperatorOperatorPairReal):
    @overload
    def __init__(self, arg: BasisPairReal, /) -> None: ...

    @overload
    def __init__(self, arg0: BasisPairReal, arg1: OperatorType, /) -> None: ...

class OperatorPairComplex(OperatorOperatorPairComplex):
    @overload
    def __init__(self, arg: BasisPairComplex, /) -> None: ...

    @overload
    def __init__(self, arg0: BasisPairComplex, arg1: OperatorType, /) -> None: ...

class Database:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, download_missing: bool) -> None: ...

    @overload
    def __init__(self, database_dir: str | os.PathLike) -> None: ...

    @overload
    def __init__(self, download_missing: bool, use_cache: bool, database_dir: str | os.PathLike) -> None: ...

    def get_download_missing(self) -> bool: ...

    def get_use_cache(self) -> bool: ...

    def get_database_dir(self) -> pathlib.Path: ...

class DiagonalizerEigenReal(DiagonalizerInterfaceReal):
    def __init__(self, float_type: FloatType = FloatType.FLOAT64) -> None: ...

    def eigh(self, arg0: scipy.sparse.csr_matrix[float], arg1: float, /) -> EigenSystemHReal: ...

class DiagonalizerEigenComplex(DiagonalizerInterfaceComplex):
    def __init__(self, float_type: FloatType = FloatType.FLOAT64) -> None: ...

    def eigh(self, arg0: scipy.sparse.csr_matrix[complex], arg1: float, /) -> EigenSystemHComplex: ...

class DiagonalizerFeastReal(DiagonalizerInterfaceReal):
    def __init__(self, m0: int, float_type: FloatType = FloatType.FLOAT64) -> None: ...

    @overload
    def eigh(self, arg0: scipy.sparse.csr_matrix[float], arg1: float, /) -> EigenSystemHReal: ...

    @overload
    def eigh(self, arg0: scipy.sparse.csr_matrix[float], arg1: float, arg2: float, arg3: float, /) -> EigenSystemHReal: ...

class DiagonalizerFeastComplex(DiagonalizerInterfaceComplex):
    def __init__(self, m0: int, float_type: FloatType = FloatType.FLOAT64) -> None: ...

    @overload
    def eigh(self, arg0: scipy.sparse.csr_matrix[complex], arg1: float, /) -> EigenSystemHComplex: ...

    @overload
    def eigh(self, arg0: scipy.sparse.csr_matrix[complex], arg1: float, arg2: float, arg3: float, /) -> EigenSystemHComplex: ...

class DiagonalizerLapackeEvdReal(DiagonalizerInterfaceReal):
    def __init__(self, float_type: FloatType = FloatType.FLOAT64) -> None: ...

    def eigh(self, arg0: scipy.sparse.csr_matrix[float], arg1: float, /) -> EigenSystemHReal: ...

class DiagonalizerLapackeEvdComplex(DiagonalizerInterfaceComplex):
    def __init__(self, float_type: FloatType = FloatType.FLOAT64) -> None: ...

    def eigh(self, arg0: scipy.sparse.csr_matrix[complex], arg1: float, /) -> EigenSystemHComplex: ...

class DiagonalizerLapackeEvrReal(DiagonalizerInterfaceReal):
    def __init__(self, float_type: FloatType = FloatType.FLOAT64) -> None: ...

    def eigh(self, arg0: scipy.sparse.csr_matrix[float], arg1: float, /) -> EigenSystemHReal: ...

class DiagonalizerLapackeEvrComplex(DiagonalizerInterfaceComplex):
    def __init__(self, float_type: FloatType = FloatType.FLOAT64) -> None: ...

    def eigh(self, arg0: scipy.sparse.csr_matrix[complex], arg1: float, /) -> EigenSystemHComplex: ...

def diagonalizeSystemAtomReal(systems: list, diagonalizer: DiagonalizerInterfaceReal, min_eigenvalue: Optional[float] = None, max_eigenvalue: Optional[float] = None, rtol: float = 1e-06) -> None: ...

def diagonalizeSystemAtomComplex(systems: list, diagonalizer: DiagonalizerInterfaceComplex, min_eigenvalue: Optional[float] = None, max_eigenvalue: Optional[float] = None, rtol: float = 1e-06) -> None: ...

def diagonalizeSystemPairReal(systems: list, diagonalizer: DiagonalizerInterfaceReal, min_eigenvalue: Optional[float] = None, max_eigenvalue: Optional[float] = None, rtol: float = 1e-06) -> None: ...

def diagonalizeSystemPairComplex(systems: list, diagonalizer: DiagonalizerInterfaceComplex, min_eigenvalue: Optional[float] = None, max_eigenvalue: Optional[float] = None, rtol: float = 1e-06) -> None: ...

class Ket:
    def get_energy(self) -> float: ...

    def get_quantum_number_f(self) -> float: ...

    def get_quantum_number_m(self) -> float: ...

    def get_parity(self) -> Parity: ...

    def get_label(self) -> str: ...

    def __str__(self) -> str: ...

class KetAtom(Ket):
    def get_database(self) -> Database: ...

    def get_species(self) -> str: ...

    def get_quantum_number_n(self) -> int: ...

    def get_quantum_number_nu(self) -> float: ...

    def get_quantum_number_nui(self) -> float: ...

    def get_quantum_number_l(self) -> float: ...

    def get_quantum_number_s(self) -> float: ...

    def get_quantum_number_j(self) -> float: ...

    def get_quantum_number_l_ryd(self) -> float: ...

    def get_quantum_number_j_ryd(self) -> float: ...

    def get_quantum_number_nui_std(self) -> float: ...

    def get_quantum_number_l_std(self) -> float: ...

    def get_quantum_number_s_std(self) -> float: ...

    def get_quantum_number_j_std(self) -> float: ...

    def get_quantum_number_l_ryd_std(self) -> float: ...

    def get_quantum_number_j_ryd_std(self) -> float: ...

    def is_j_total_momentum(self) -> bool: ...

    def is_calculated_with_mqdt(self) -> bool: ...

    def get_underspecified_channel_contribution(self) -> float: ...

    def __eq__(self, arg: KetAtom, /) -> bool: ...

    def __hash__(self) -> int: ...

class KetAtomCreator:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg0: str, arg1: int, arg2: float, arg3: float, arg4: float, /) -> None: ...

    def set_species(self, arg: str, /) -> KetAtomCreator: ...

    def set_energy(self, arg: float, /) -> KetAtomCreator: ...

    def set_quantum_number_f(self, arg: float, /) -> KetAtomCreator: ...

    def set_quantum_number_m(self, arg: float, /) -> KetAtomCreator: ...

    def set_parity(self, arg: Parity, /) -> KetAtomCreator: ...

    def set_quantum_number_n(self, arg: int, /) -> KetAtomCreator: ...

    def set_quantum_number_nu(self, arg: float, /) -> KetAtomCreator: ...

    def set_quantum_number_nui(self, arg: float, /) -> KetAtomCreator: ...

    def set_quantum_number_l(self, arg: float, /) -> KetAtomCreator: ...

    def set_quantum_number_s(self, arg: float, /) -> KetAtomCreator: ...

    def set_quantum_number_j(self, arg: float, /) -> KetAtomCreator: ...

    def set_quantum_number_l_ryd(self, arg: float, /) -> KetAtomCreator: ...

    def set_quantum_number_j_ryd(self, arg: float, /) -> KetAtomCreator: ...

    def create(self, arg: Database, /) -> KetAtom: ...

class KetPairReal(Ket):
    def get_atomic_states(self) -> list[BasisAtomReal]: ...

    def __eq__(self, arg: KetPairReal, /) -> bool: ...

    def __hash__(self) -> int: ...

class KetPairComplex(Ket):
    def get_atomic_states(self) -> list[BasisAtomComplex]: ...

    def __eq__(self, arg: KetPairComplex, /) -> bool: ...

    def __hash__(self) -> int: ...

class BasisBasisAtomReal(TransformationBuilderInterfaceReal):
    def get_kets(self) -> list[KetAtom]: ...

    def get_ket(self, arg: int, /) -> KetAtom: ...

    def get_state(self, arg: int, /) -> BasisAtomReal: ...

    def get_number_of_states(self) -> int: ...

    def get_number_of_kets(self) -> int: ...

    def get_quantum_number_f(self, arg: int, /) -> float: ...

    def get_quantum_number_m(self, arg: int, /) -> float: ...

    def get_parity(self, arg: int, /) -> Parity: ...

    def get_coefficients(self) -> scipy.sparse.csr_matrix[float]: ...

    def set_coefficients(self, arg: scipy.sparse.csr_matrix[float], /) -> None: ...

    def get_transformation(self) -> TransformationReal: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationReal: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    def get_sorter_without_checks(self, arg0: Sequence[TransformationType], arg1: Sorting, /) -> None: ...

    def get_indices_of_blocks_without_checks(self, arg0: Set[TransformationType], arg1: IndicesOfBlocksCreator, /) -> None: ...

    @overload
    def transformed(self, arg: TransformationReal, /) -> BasisAtomReal: ...

    @overload
    def transformed(self, arg: Sorting, /) -> BasisAtomReal: ...

    @overload
    def get_amplitudes(self, arg: KetAtom, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_amplitudes(self, arg: BasisAtomReal, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_overlaps(self, arg: KetAtom, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_overlaps(self, arg: BasisAtomReal, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_matrix_elements(self, arg0: KetAtom, arg1: OperatorType, arg2: int, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_matrix_elements(self, arg0: BasisAtomReal, arg1: OperatorType, arg2: int, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_corresponding_state(self, arg: int, /) -> BasisAtomReal: ...

    @overload
    def get_corresponding_state(self, arg: KetAtom, /) -> BasisAtomReal: ...

    @overload
    def get_corresponding_state_index(self, arg: int, /) -> int: ...

    @overload
    def get_corresponding_state_index(self, arg: KetAtom, /) -> int: ...

    @overload
    def get_corresponding_ket(self, arg: int, /) -> KetAtom: ...

    @overload
    def get_corresponding_ket(self, arg: BasisAtomReal, /) -> KetAtom: ...

    @overload
    def get_corresponding_ket_index(self, arg: int, /) -> int: ...

    @overload
    def get_corresponding_ket_index(self, arg: BasisAtomReal, /) -> int: ...

    def copy(self) -> BasisAtomReal: ...

class BasisBasisAtomComplex(TransformationBuilderInterfaceComplex):
    def get_kets(self) -> list[KetAtom]: ...

    def get_ket(self, arg: int, /) -> KetAtom: ...

    def get_state(self, arg: int, /) -> BasisAtomComplex: ...

    def get_number_of_states(self) -> int: ...

    def get_number_of_kets(self) -> int: ...

    def get_quantum_number_f(self, arg: int, /) -> float: ...

    def get_quantum_number_m(self, arg: int, /) -> float: ...

    def get_parity(self, arg: int, /) -> Parity: ...

    def get_coefficients(self) -> scipy.sparse.csr_matrix[complex]: ...

    def set_coefficients(self, arg: scipy.sparse.csr_matrix[complex], /) -> None: ...

    def get_transformation(self) -> TransformationComplex: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationComplex: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    def get_sorter_without_checks(self, arg0: Sequence[TransformationType], arg1: Sorting, /) -> None: ...

    def get_indices_of_blocks_without_checks(self, arg0: Set[TransformationType], arg1: IndicesOfBlocksCreator, /) -> None: ...

    @overload
    def transformed(self, arg: TransformationComplex, /) -> BasisAtomComplex: ...

    @overload
    def transformed(self, arg: Sorting, /) -> BasisAtomComplex: ...

    @overload
    def get_amplitudes(self, arg: KetAtom, /) -> Annotated[NDArray[numpy.complex128], dict(shape=(None,), order='C')]: ...

    @overload
    def get_amplitudes(self, arg: BasisAtomComplex, /) -> scipy.sparse.csr_matrix[complex]: ...

    @overload
    def get_overlaps(self, arg: KetAtom, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_overlaps(self, arg: BasisAtomComplex, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_matrix_elements(self, arg0: KetAtom, arg1: OperatorType, arg2: int, /) -> Annotated[NDArray[numpy.complex128], dict(shape=(None,), order='C')]: ...

    @overload
    def get_matrix_elements(self, arg0: BasisAtomComplex, arg1: OperatorType, arg2: int, /) -> scipy.sparse.csr_matrix[complex]: ...

    @overload
    def get_corresponding_state(self, arg: int, /) -> BasisAtomComplex: ...

    @overload
    def get_corresponding_state(self, arg: KetAtom, /) -> BasisAtomComplex: ...

    @overload
    def get_corresponding_state_index(self, arg: int, /) -> int: ...

    @overload
    def get_corresponding_state_index(self, arg: KetAtom, /) -> int: ...

    @overload
    def get_corresponding_ket(self, arg: int, /) -> KetAtom: ...

    @overload
    def get_corresponding_ket(self, arg: BasisAtomComplex, /) -> KetAtom: ...

    @overload
    def get_corresponding_ket_index(self, arg: int, /) -> int: ...

    @overload
    def get_corresponding_ket_index(self, arg: BasisAtomComplex, /) -> int: ...

    def copy(self) -> BasisAtomComplex: ...

class BasisAtomReal(BasisBasisAtomReal):
    pass

class BasisAtomComplex(BasisBasisAtomComplex):
    pass

class BasisAtomCreatorReal:
    def __init__(self) -> None: ...

    def set_species(self, arg: str, /) -> BasisAtomCreatorReal: ...

    def restrict_energy(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_f(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_m(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def restrict_parity(self, arg: Parity, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_n(self, arg0: int, arg1: int, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_nu(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_nui(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_l(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_s(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_j(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_l_ryd(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def restrict_quantum_number_j_ryd(self, arg0: float, arg1: float, /) -> BasisAtomCreatorReal: ...

    def append_ket(self, arg: KetAtom, /) -> BasisAtomCreatorReal: ...

    def create(self, arg: Database, /) -> BasisAtomReal: ...

class BasisAtomCreatorComplex:
    def __init__(self) -> None: ...

    def set_species(self, arg: str, /) -> BasisAtomCreatorComplex: ...

    def restrict_energy(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_f(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_m(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def restrict_parity(self, arg: Parity, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_n(self, arg0: int, arg1: int, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_nu(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_nui(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_l(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_s(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_j(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_l_ryd(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def restrict_quantum_number_j_ryd(self, arg0: float, arg1: float, /) -> BasisAtomCreatorComplex: ...

    def append_ket(self, arg: KetAtom, /) -> BasisAtomCreatorComplex: ...

    def create(self, arg: Database, /) -> BasisAtomComplex: ...

class BasisBasisPairReal(TransformationBuilderInterfaceReal):
    def get_kets(self) -> list[KetPairReal]: ...

    def get_ket(self, arg: int, /) -> KetPairReal: ...

    def get_state(self, arg: int, /) -> BasisPairReal: ...

    def get_number_of_states(self) -> int: ...

    def get_number_of_kets(self) -> int: ...

    def get_quantum_number_f(self, arg: int, /) -> float: ...

    def get_quantum_number_m(self, arg: int, /) -> float: ...

    def get_parity(self, arg: int, /) -> Parity: ...

    def get_coefficients(self) -> scipy.sparse.csr_matrix[float]: ...

    def set_coefficients(self, arg: scipy.sparse.csr_matrix[float], /) -> None: ...

    def get_transformation(self) -> TransformationReal: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationReal: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    def get_sorter_without_checks(self, arg0: Sequence[TransformationType], arg1: Sorting, /) -> None: ...

    def get_indices_of_blocks_without_checks(self, arg0: Set[TransformationType], arg1: IndicesOfBlocksCreator, /) -> None: ...

    @overload
    def transformed(self, arg: TransformationReal, /) -> BasisPairReal: ...

    @overload
    def transformed(self, arg: Sorting, /) -> BasisPairReal: ...

    @overload
    def get_amplitudes(self, arg: KetPairReal, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_amplitudes(self, arg: BasisPairReal, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_overlaps(self, arg: KetPairReal, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_overlaps(self, arg: BasisPairReal, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_matrix_elements(self, arg0: KetPairReal, arg1: OperatorType, arg2: int, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_matrix_elements(self, arg0: BasisPairReal, arg1: OperatorType, arg2: int, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_corresponding_state(self, arg: int, /) -> BasisPairReal: ...

    @overload
    def get_corresponding_state(self, arg: KetPairReal, /) -> BasisPairReal: ...

    @overload
    def get_corresponding_state_index(self, arg: int, /) -> int: ...

    @overload
    def get_corresponding_state_index(self, arg: KetPairReal, /) -> int: ...

    @overload
    def get_corresponding_ket(self, arg: int, /) -> KetPairReal: ...

    @overload
    def get_corresponding_ket(self, arg: BasisPairReal, /) -> KetPairReal: ...

    @overload
    def get_corresponding_ket_index(self, arg: int, /) -> int: ...

    @overload
    def get_corresponding_ket_index(self, arg: BasisPairReal, /) -> int: ...

    def copy(self) -> BasisPairReal: ...

class BasisBasisPairComplex(TransformationBuilderInterfaceComplex):
    def get_kets(self) -> list[KetPairComplex]: ...

    def get_ket(self, arg: int, /) -> KetPairComplex: ...

    def get_state(self, arg: int, /) -> BasisPairComplex: ...

    def get_number_of_states(self) -> int: ...

    def get_number_of_kets(self) -> int: ...

    def get_quantum_number_f(self, arg: int, /) -> float: ...

    def get_quantum_number_m(self, arg: int, /) -> float: ...

    def get_parity(self, arg: int, /) -> Parity: ...

    def get_coefficients(self) -> scipy.sparse.csr_matrix[complex]: ...

    def set_coefficients(self, arg: scipy.sparse.csr_matrix[complex], /) -> None: ...

    def get_transformation(self) -> TransformationComplex: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationComplex: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    def get_sorter_without_checks(self, arg0: Sequence[TransformationType], arg1: Sorting, /) -> None: ...

    def get_indices_of_blocks_without_checks(self, arg0: Set[TransformationType], arg1: IndicesOfBlocksCreator, /) -> None: ...

    @overload
    def transformed(self, arg: TransformationComplex, /) -> BasisPairComplex: ...

    @overload
    def transformed(self, arg: Sorting, /) -> BasisPairComplex: ...

    @overload
    def get_amplitudes(self, arg: KetPairComplex, /) -> Annotated[NDArray[numpy.complex128], dict(shape=(None,), order='C')]: ...

    @overload
    def get_amplitudes(self, arg: BasisPairComplex, /) -> scipy.sparse.csr_matrix[complex]: ...

    @overload
    def get_overlaps(self, arg: KetPairComplex, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_overlaps(self, arg: BasisPairComplex, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_matrix_elements(self, arg0: KetPairComplex, arg1: OperatorType, arg2: int, /) -> Annotated[NDArray[numpy.complex128], dict(shape=(None,), order='C')]: ...

    @overload
    def get_matrix_elements(self, arg0: BasisPairComplex, arg1: OperatorType, arg2: int, /) -> scipy.sparse.csr_matrix[complex]: ...

    @overload
    def get_corresponding_state(self, arg: int, /) -> BasisPairComplex: ...

    @overload
    def get_corresponding_state(self, arg: KetPairComplex, /) -> BasisPairComplex: ...

    @overload
    def get_corresponding_state_index(self, arg: int, /) -> int: ...

    @overload
    def get_corresponding_state_index(self, arg: KetPairComplex, /) -> int: ...

    @overload
    def get_corresponding_ket(self, arg: int, /) -> KetPairComplex: ...

    @overload
    def get_corresponding_ket(self, arg: BasisPairComplex, /) -> KetPairComplex: ...

    @overload
    def get_corresponding_ket_index(self, arg: int, /) -> int: ...

    @overload
    def get_corresponding_ket_index(self, arg: BasisPairComplex, /) -> int: ...

    def copy(self) -> BasisPairComplex: ...

class BasisPairReal(BasisBasisPairReal):
    @overload
    def get_amplitudes(self, arg0: KetAtom, arg1: KetAtom, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_amplitudes(self, arg0: BasisAtomReal, arg1: BasisAtomReal, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_overlaps(self, arg0: KetAtom, arg1: KetAtom, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_overlaps(self, arg0: BasisAtomReal, arg1: BasisAtomReal, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_matrix_elements(self, arg0: BasisPairReal, arg1: OperatorType, arg2: OperatorType, arg3: int, arg4: int, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_matrix_elements(self, arg0: BasisAtomReal, arg1: BasisAtomReal, arg2: OperatorType, arg3: OperatorType, arg4: int, arg5: int, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_matrix_elements(self, arg0: KetPairReal, arg1: OperatorType, arg2: OperatorType, arg3: int, arg4: int, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_matrix_elements(self, arg0: KetAtom, arg1: KetAtom, arg2: OperatorType, arg3: OperatorType, arg4: int, arg5: int, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

class BasisPairComplex(BasisBasisPairComplex):
    @overload
    def get_amplitudes(self, arg0: KetAtom, arg1: KetAtom, /) -> Annotated[NDArray[numpy.complex128], dict(shape=(None,), order='C')]: ...

    @overload
    def get_amplitudes(self, arg0: BasisAtomComplex, arg1: BasisAtomComplex, /) -> scipy.sparse.csr_matrix[complex]: ...

    @overload
    def get_overlaps(self, arg0: KetAtom, arg1: KetAtom, /) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @overload
    def get_overlaps(self, arg0: BasisAtomComplex, arg1: BasisAtomComplex, /) -> scipy.sparse.csr_matrix[float]: ...

    @overload
    def get_matrix_elements(self, arg0: BasisPairComplex, arg1: OperatorType, arg2: OperatorType, arg3: int, arg4: int, /) -> scipy.sparse.csr_matrix[complex]: ...

    @overload
    def get_matrix_elements(self, arg0: BasisAtomComplex, arg1: BasisAtomComplex, arg2: OperatorType, arg3: OperatorType, arg4: int, arg5: int, /) -> scipy.sparse.csr_matrix[complex]: ...

    @overload
    def get_matrix_elements(self, arg0: KetPairComplex, arg1: OperatorType, arg2: OperatorType, arg3: int, arg4: int, /) -> Annotated[NDArray[numpy.complex128], dict(shape=(None,), order='C')]: ...

    @overload
    def get_matrix_elements(self, arg0: KetAtom, arg1: KetAtom, arg2: OperatorType, arg3: OperatorType, arg4: int, arg5: int, /) -> Annotated[NDArray[numpy.complex128], dict(shape=(None,), order='C')]: ...

class BasisPairCreatorReal:
    def __init__(self) -> None: ...

    def add(self, arg: SystemAtomReal, /) -> BasisPairCreatorReal: ...

    def restrict_energy(self, arg0: float, arg1: float, /) -> BasisPairCreatorReal: ...

    def restrict_quantum_number_m(self, arg0: float, arg1: float, /) -> BasisPairCreatorReal: ...

    def restrict_product_of_parities(self, arg: Parity, /) -> BasisPairCreatorReal: ...

    def create(self) -> BasisPairReal: ...

class BasisPairCreatorComplex:
    def __init__(self) -> None: ...

    def add(self, arg: SystemAtomComplex, /) -> BasisPairCreatorComplex: ...

    def restrict_energy(self, arg0: float, arg1: float, /) -> BasisPairCreatorComplex: ...

    def restrict_quantum_number_m(self, arg0: float, arg1: float, /) -> BasisPairCreatorComplex: ...

    def restrict_product_of_parities(self, arg: Parity, /) -> BasisPairCreatorComplex: ...

    def create(self) -> BasisPairComplex: ...

class SystemSystemAtomReal(TransformationBuilderInterfaceReal):
    def get_basis(self) -> BasisAtomReal: ...

    def get_eigenbasis(self) -> BasisAtomReal: ...

    def get_eigenenergies(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    def get_matrix(self) -> scipy.sparse.csr_matrix[float]: ...

    def get_transformation(self) -> TransformationReal: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationReal: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    @overload
    def transform(self, arg: TransformationReal, /) -> SystemSystemAtomReal: ...

    @overload
    def transform(self, arg: Sorting, /) -> SystemSystemAtomReal: ...

    def diagonalize(self, diagonalizer: DiagonalizerInterfaceReal, min_eigenenergy: Optional[float] = None, max_eigenenergy: Optional[float] = None, rtol: float = 1e-06) -> SystemSystemAtomReal: ...

    def is_diagonal(self) -> bool: ...

class SystemSystemAtomComplex(TransformationBuilderInterfaceComplex):
    def get_basis(self) -> BasisAtomComplex: ...

    def get_eigenbasis(self) -> BasisAtomComplex: ...

    def get_eigenenergies(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    def get_matrix(self) -> scipy.sparse.csr_matrix[complex]: ...

    def get_transformation(self) -> TransformationComplex: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationComplex: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    @overload
    def transform(self, arg: TransformationComplex, /) -> SystemSystemAtomComplex: ...

    @overload
    def transform(self, arg: Sorting, /) -> SystemSystemAtomComplex: ...

    def diagonalize(self, diagonalizer: DiagonalizerInterfaceComplex, min_eigenenergy: Optional[float] = None, max_eigenenergy: Optional[float] = None, rtol: float = 1e-06) -> SystemSystemAtomComplex: ...

    def is_diagonal(self) -> bool: ...

class SystemAtomReal(SystemSystemAtomReal):
    def __init__(self, arg: BasisAtomReal, /) -> None: ...

    def set_electric_field(self, arg: Sequence[float], /) -> SystemAtomReal: ...

    def set_magnetic_field(self, arg: Sequence[float], /) -> SystemAtomReal: ...

    def set_diamagnetism_enabled(self, arg: bool, /) -> SystemAtomReal: ...

    def set_ion_distance_vector(self, arg: Sequence[float], /) -> SystemAtomReal: ...

    def set_ion_charge(self, arg: float, /) -> SystemAtomReal: ...

    def set_ion_interaction_order(self, arg: int, /) -> SystemAtomReal: ...

class SystemAtomComplex(SystemSystemAtomComplex):
    def __init__(self, arg: BasisAtomComplex, /) -> None: ...

    def set_electric_field(self, arg: Sequence[float], /) -> SystemAtomComplex: ...

    def set_magnetic_field(self, arg: Sequence[float], /) -> SystemAtomComplex: ...

    def set_diamagnetism_enabled(self, arg: bool, /) -> SystemAtomComplex: ...

    def set_ion_distance_vector(self, arg: Sequence[float], /) -> SystemAtomComplex: ...

    def set_ion_charge(self, arg: float, /) -> SystemAtomComplex: ...

    def set_ion_interaction_order(self, arg: int, /) -> SystemAtomComplex: ...

class SystemSystemPairReal(TransformationBuilderInterfaceReal):
    def get_basis(self) -> BasisPairReal: ...

    def get_eigenbasis(self) -> BasisPairReal: ...

    def get_eigenenergies(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    def get_matrix(self) -> scipy.sparse.csr_matrix[float]: ...

    def get_transformation(self) -> TransformationReal: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationReal: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    @overload
    def transform(self, arg: TransformationReal, /) -> SystemSystemPairReal: ...

    @overload
    def transform(self, arg: Sorting, /) -> SystemSystemPairReal: ...

    def diagonalize(self, diagonalizer: DiagonalizerInterfaceReal, min_eigenenergy: Optional[float] = None, max_eigenenergy: Optional[float] = None, rtol: float = 1e-06) -> SystemSystemPairReal: ...

    def is_diagonal(self) -> bool: ...

class SystemSystemPairComplex(TransformationBuilderInterfaceComplex):
    def get_basis(self) -> BasisPairComplex: ...

    def get_eigenbasis(self) -> BasisPairComplex: ...

    def get_eigenenergies(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    def get_matrix(self) -> scipy.sparse.csr_matrix[complex]: ...

    def get_transformation(self) -> TransformationComplex: ...

    def get_rotator(self, arg0: float, arg1: float, arg2: float, /) -> TransformationComplex: ...

    def get_sorter(self, arg: Sequence[TransformationType], /) -> Sorting: ...

    def get_indices_of_blocks(self, arg: Sequence[TransformationType], /) -> list[IndicesOfBlock]: ...

    @overload
    def transform(self, arg: TransformationComplex, /) -> SystemSystemPairComplex: ...

    @overload
    def transform(self, arg: Sorting, /) -> SystemSystemPairComplex: ...

    def diagonalize(self, diagonalizer: DiagonalizerInterfaceComplex, min_eigenenergy: Optional[float] = None, max_eigenenergy: Optional[float] = None, rtol: float = 1e-06) -> SystemSystemPairComplex: ...

    def is_diagonal(self) -> bool: ...

class SystemPairReal(SystemSystemPairReal):
    def __init__(self, arg: BasisPairReal, /) -> None: ...

    def set_interaction_order(self, arg: int, /) -> SystemPairReal: ...

    def set_distance_vector(self, arg: Sequence[float], /) -> SystemPairReal: ...

    def set_green_tensor(self, arg: GreenTensorReal, /) -> SystemPairReal: ...

class SystemPairComplex(SystemSystemPairComplex):
    def __init__(self, arg: BasisPairComplex, /) -> None: ...

    def set_interaction_order(self, arg: int, /) -> SystemPairComplex: ...

    def set_distance_vector(self, arg: Sequence[float], /) -> SystemPairComplex: ...

    def set_green_tensor(self, arg: GreenTensorComplex, /) -> SystemPairComplex: ...

class ConstantEntryReal:
    def row(self) -> int: ...

    def col(self) -> int: ...

    def val(self) -> float: ...

class OmegaDependentEntryReal:
    def row(self) -> int: ...

    def col(self) -> int: ...

    def val(self, arg: float, /) -> float: ...

class GreenTensorReal:
    def __init__(self) -> None: ...

    @overload
    def create_entries_from_cartesian(self, arg0: int, arg1: int, arg2: Annotated[NDArray[numpy.float64], dict(shape=(None, None), order='F')], /) -> None: ...

    @overload
    def create_entries_from_cartesian(self, arg0: int, arg1: int, arg2: Sequence[Annotated[NDArray[numpy.float64], dict(shape=(None, None), order='F')]], arg3: Sequence[float], /) -> None: ...

    def get_spherical_entries(self, arg0: int, arg1: int, /) -> list[Union[ConstantEntryReal, OmegaDependentEntryReal]]: ...

class ConstantEntryComplex:
    def row(self) -> int: ...

    def col(self) -> int: ...

    def val(self) -> complex: ...

class OmegaDependentEntryComplex:
    def row(self) -> int: ...

    def col(self) -> int: ...

    def val(self, arg: float, /) -> complex: ...

class GreenTensorComplex:
    def __init__(self) -> None: ...

    @overload
    def create_entries_from_cartesian(self, arg0: int, arg1: int, arg2: Annotated[NDArray[numpy.complex128], dict(shape=(None, None), order='F')], /) -> None: ...

    @overload
    def create_entries_from_cartesian(self, arg0: int, arg1: int, arg2: Sequence[Annotated[NDArray[numpy.complex128], dict(shape=(None, None), order='F')]], arg3: Sequence[float], /) -> None: ...

    def get_spherical_entries(self, arg0: int, arg1: int, /) -> list[Union[ConstantEntryComplex, OmegaDependentEntryComplex]]: ...

def run_unit_tests(download_missing: bool = False, use_cache: bool = True, database_dir: str | os.PathLike = '') -> int: ...

def get_cache_directory() -> pathlib.Path: ...

def get_config_directory() -> pathlib.Path: ...

VERSION_MAJOR: int = 2

VERSION_MINOR: int = 3

VERSION_PATCH: int = 0
