# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: tendermint/abci/types.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AbciAsyncStub",
    "AbciStub",
    "CheckTxType",
    "CommitInfo",
    "Event",
    "EventAttribute",
    "ExecTxResult",
    "ExtendedCommitInfo",
    "ExtendedVoteInfo",
    "Misbehavior",
    "MisbehaviorType",
    "Request",
    "RequestApplySnapshotChunk",
    "RequestCheckTx",
    "RequestCommit",
    "RequestEcho",
    "RequestExtendVote",
    "RequestFinalizeBlock",
    "RequestFlush",
    "RequestInfo",
    "RequestInitChain",
    "RequestListSnapshots",
    "RequestLoadSnapshotChunk",
    "RequestOfferSnapshot",
    "RequestPrepareProposal",
    "RequestProcessProposal",
    "RequestQuery",
    "RequestVerifyVoteExtension",
    "Response",
    "ResponseApplySnapshotChunk",
    "ResponseApplySnapshotChunkResult",
    "ResponseCheckTx",
    "ResponseCommit",
    "ResponseEcho",
    "ResponseException",
    "ResponseExtendVote",
    "ResponseFinalizeBlock",
    "ResponseFlush",
    "ResponseInfo",
    "ResponseInitChain",
    "ResponseListSnapshots",
    "ResponseLoadSnapshotChunk",
    "ResponseOfferSnapshot",
    "ResponseOfferSnapshotResult",
    "ResponsePrepareProposal",
    "ResponseProcessProposal",
    "ResponseProcessProposalProposalStatus",
    "ResponseQuery",
    "ResponseVerifyVoteExtension",
    "ResponseVerifyVoteExtensionVerifyStatus",
    "Snapshot",
    "TxResult",
    "Validator",
    "ValidatorUpdate",
    "VoteInfo",
)

import datetime
from dataclasses import dataclass
from typing import TYPE_CHECKING

import betterproto2
import grpc

from ...message_pool import default_message_pool

if TYPE_CHECKING:
    from betterproto2.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.7.1"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class CheckTxType(betterproto2.Enum):
    NEW = 0

    RECHECK = 1


class MisbehaviorType(betterproto2.Enum):
    UNKNOWN = 0

    DUPLICATE_VOTE = 1

    LIGHT_CLIENT_ATTACK = 2


class ResponseApplySnapshotChunkResult(betterproto2.Enum):
    UNKNOWN = 0
    """
    Unknown result, abort all snapshot restoration
    """

    ACCEPT = 1
    """
    Chunk successfully accepted
    """

    ABORT = 2
    """
    Abort all snapshot restoration
    """

    RETRY = 3
    """
    Retry chunk (combine with refetch and reject)
    """

    RETRY_SNAPSHOT = 4
    """
    Retry snapshot (combine with refetch and reject)
    """

    REJECT_SNAPSHOT = 5
    """
    Reject this snapshot, try others
    """


class ResponseOfferSnapshotResult(betterproto2.Enum):
    UNKNOWN = 0
    """
    Unknown result, abort all snapshot restoration
    """

    ACCEPT = 1
    """
    Snapshot accepted, apply chunks
    """

    ABORT = 2
    """
    Abort all snapshot restoration
    """

    REJECT = 3
    """
    Reject this specific snapshot, try others
    """

    REJECT_FORMAT = 4
    """
    Reject all snapshots of this format, try others
    """

    REJECT_SENDER = 5
    """
    Reject all snapshots from the sender(s), try others
    """


class ResponseProcessProposalProposalStatus(betterproto2.Enum):
    UNKNOWN = 0

    ACCEPT = 1

    REJECT = 2


class ResponseVerifyVoteExtensionVerifyStatus(betterproto2.Enum):
    UNKNOWN = 0

    ACCEPT = 1

    REJECT = 2
    """
    Rejecting the vote extension will reject the entire precommit by the sender.
    Incorrectly implementing this thus has liveness implications as it may affect
    CometBFT's ability to receive 2/3+ valid votes to finalize the block.
    Honest nodes should never be rejected.
    """


@dataclass(eq=False, repr=False)
class CommitInfo(betterproto2.Message):
    """
    ----------------------------------------
    Misc.
    """

    round: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    votes: "list[VoteInfo]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("tendermint.abci", "CommitInfo", CommitInfo)


@dataclass(eq=False, repr=False)
class Event(betterproto2.Message):
    """
    Event allows application developers to attach additional information to
    ResponseFinalizeBlock and ResponseCheckTx.
    Later, transactions may be queried using these events.
    """

    type: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    attributes: "list[EventAttribute]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("tendermint.abci", "Event", Event)


@dataclass(eq=False, repr=False)
class EventAttribute(betterproto2.Message):
    """
    EventAttribute is a single key-value pair, associated with an event.
    """

    key: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    value: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    index: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    nondeterministic
    """


default_message_pool.register_message(
    "tendermint.abci", "EventAttribute", EventAttribute
)


@dataclass(eq=False, repr=False)
class ExecTxResult(betterproto2.Message):
    """
    ExecTxResult contains results of executing one individual transaction.

    * Its structure is equivalent to #ResponseDeliverTx which will be deprecated/deleted
    """

    code: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    data: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    log: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    nondeterministic
    """

    info: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)
    """
    nondeterministic
    """

    gas_wanted: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)

    gas_used: "int" = betterproto2.field(6, betterproto2.TYPE_INT64)

    events: "list[Event]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    nondeterministic
    """

    codespace: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)


default_message_pool.register_message("tendermint.abci", "ExecTxResult", ExecTxResult)


@dataclass(eq=False, repr=False)
class ExtendedCommitInfo(betterproto2.Message):
    """
    ExtendedCommitInfo is similar to CommitInfo except that it is only used in
    the PrepareProposal request such that CometBFT can provide vote extensions
    to the application.
    """

    round: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    The round at which the block proposer decided in the previous height.
    """

    votes: "list[ExtendedVoteInfo]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of validators' addresses in the last validator set with their voting
    information, including vote extensions.
    """


default_message_pool.register_message(
    "tendermint.abci", "ExtendedCommitInfo", ExtendedCommitInfo
)


@dataclass(eq=False, repr=False)
class ExtendedVoteInfo(betterproto2.Message):
    validator: "Validator | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The validator that sent the vote.
    """

    vote_extension: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)
    """
    Non-deterministic extension provided by the sending validator's application.
    """

    extension_signature: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)
    """
    Vote extension signature created by CometBFT
    """

    block_id_flag: "_types__.BlockIdFlag" = betterproto2.field(
        5, betterproto2.TYPE_ENUM, default_factory=lambda: _types__.BlockIdFlag(0)
    )
    """
    block_id_flag indicates whether the validator voted for a block, nil, or did not vote at all
    """


default_message_pool.register_message(
    "tendermint.abci", "ExtendedVoteInfo", ExtendedVoteInfo
)


@dataclass(eq=False, repr=False)
class Misbehavior(betterproto2.Message):
    type: "MisbehaviorType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: MisbehaviorType(0)
    )

    validator: "Validator | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The offending validator
    """

    height: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)
    """
    The height when the offense occurred
    """

    time: "datetime.datetime | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.Timestamp,
        optional=True,
    )
    """
    The corresponding time where the offense occurred
    """

    total_voting_power: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)
    """
    Total voting power of the validator set in case the ABCI application does
    not store historical validators.
    https://github.com/tendermint/tendermint/issues/4581
    """


default_message_pool.register_message("tendermint.abci", "Misbehavior", Misbehavior)


@dataclass(eq=False, repr=False)
class Request(betterproto2.Message):
    """
    ----------------------------------------
    Request types

    Oneofs:
        - value:
    """

    echo: "RequestEcho | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    flush: "RequestFlush | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    info: "RequestInfo | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    init_chain: "RequestInitChain | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    query: "RequestQuery | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    check_tx: "RequestCheckTx | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    commit: "RequestCommit | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    list_snapshots: "RequestListSnapshots | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    offer_snapshot: "RequestOfferSnapshot | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    load_snapshot_chunk: "RequestLoadSnapshotChunk | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    apply_snapshot_chunk: "RequestApplySnapshotChunk | None" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    prepare_proposal: "RequestPrepareProposal | None" = betterproto2.field(
        16, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    process_proposal: "RequestProcessProposal | None" = betterproto2.field(
        17, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    extend_vote: "RequestExtendVote | None" = betterproto2.field(
        18, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    verify_vote_extension: "RequestVerifyVoteExtension | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    finalize_block: "RequestFinalizeBlock | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )


default_message_pool.register_message("tendermint.abci", "Request", Request)


@dataclass(eq=False, repr=False)
class RequestApplySnapshotChunk(betterproto2.Message):
    """
    Applies a snapshot chunk
    """

    index: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    chunk: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    sender: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "tendermint.abci", "RequestApplySnapshotChunk", RequestApplySnapshotChunk
)


@dataclass(eq=False, repr=False)
class RequestCheckTx(betterproto2.Message):
    tx: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    type: "CheckTxType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: CheckTxType(0)
    )


default_message_pool.register_message(
    "tendermint.abci", "RequestCheckTx", RequestCheckTx
)


@dataclass(eq=False, repr=False)
class RequestCommit(betterproto2.Message):
    pass


default_message_pool.register_message("tendermint.abci", "RequestCommit", RequestCommit)


@dataclass(eq=False, repr=False)
class RequestEcho(betterproto2.Message):
    message: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message("tendermint.abci", "RequestEcho", RequestEcho)


@dataclass(eq=False, repr=False)
class RequestExtendVote(betterproto2.Message):
    """
    Extends a vote with application-injected data
    """

    hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    the hash of the block that this vote may be referring to
    """

    height: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)
    """
    the height of the extended vote
    """

    time: "datetime.datetime | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.Timestamp,
        optional=True,
    )
    """
    info of the block that this vote may be referring to
    """

    txs: "list[bytes]" = betterproto2.field(4, betterproto2.TYPE_BYTES, repeated=True)

    proposed_last_commit: "CommitInfo | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )

    misbehavior: "list[Misbehavior]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )

    next_validators_hash: "bytes" = betterproto2.field(7, betterproto2.TYPE_BYTES)

    proposer_address: "bytes" = betterproto2.field(8, betterproto2.TYPE_BYTES)
    """
    address of the public key of the original proposer of the block.
    """


default_message_pool.register_message(
    "tendermint.abci", "RequestExtendVote", RequestExtendVote
)


@dataclass(eq=False, repr=False)
class RequestFinalizeBlock(betterproto2.Message):
    txs: "list[bytes]" = betterproto2.field(1, betterproto2.TYPE_BYTES, repeated=True)

    decided_last_commit: "CommitInfo | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    misbehavior: "list[Misbehavior]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )

    hash: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)
    """
    hash is the merkle root hash of the fields of the decided block.
    """

    height: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)

    time: "datetime.datetime | None" = betterproto2.field(
        6,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.Timestamp,
        optional=True,
    )

    next_validators_hash: "bytes" = betterproto2.field(7, betterproto2.TYPE_BYTES)

    proposer_address: "bytes" = betterproto2.field(8, betterproto2.TYPE_BYTES)
    """
    proposer_address is the address of the public key of the original proposer of the block.
    """


default_message_pool.register_message(
    "tendermint.abci", "RequestFinalizeBlock", RequestFinalizeBlock
)


@dataclass(eq=False, repr=False)
class RequestFlush(betterproto2.Message):
    pass


default_message_pool.register_message("tendermint.abci", "RequestFlush", RequestFlush)


@dataclass(eq=False, repr=False)
class RequestInfo(betterproto2.Message):
    version: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    block_version: "int" = betterproto2.field(2, betterproto2.TYPE_UINT64)

    p2p_version: "int" = betterproto2.field(3, betterproto2.TYPE_UINT64)

    abci_version: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)


default_message_pool.register_message("tendermint.abci", "RequestInfo", RequestInfo)


@dataclass(eq=False, repr=False)
class RequestInitChain(betterproto2.Message):
    time: "datetime.datetime | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.Timestamp,
        optional=True,
    )

    chain_id: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    consensus_params: "_types__.ConsensusParams | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    validators: "list[ValidatorUpdate]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )

    app_state_bytes: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)

    initial_height: "int" = betterproto2.field(6, betterproto2.TYPE_INT64)


default_message_pool.register_message(
    "tendermint.abci", "RequestInitChain", RequestInitChain
)


@dataclass(eq=False, repr=False)
class RequestListSnapshots(betterproto2.Message):
    """
    lists available snapshots
    """

    pass


default_message_pool.register_message(
    "tendermint.abci", "RequestListSnapshots", RequestListSnapshots
)


@dataclass(eq=False, repr=False)
class RequestLoadSnapshotChunk(betterproto2.Message):
    """
    loads a snapshot chunk
    """

    height: "int" = betterproto2.field(1, betterproto2.TYPE_UINT64)

    format: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    chunk: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)


default_message_pool.register_message(
    "tendermint.abci", "RequestLoadSnapshotChunk", RequestLoadSnapshotChunk
)


@dataclass(eq=False, repr=False)
class RequestOfferSnapshot(betterproto2.Message):
    """
    offers a snapshot to the application
    """

    snapshot: "Snapshot | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    snapshot offered by peers
    """

    app_hash: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    light client-verified app hash for snapshot height
    """


default_message_pool.register_message(
    "tendermint.abci", "RequestOfferSnapshot", RequestOfferSnapshot
)


@dataclass(eq=False, repr=False)
class RequestPrepareProposal(betterproto2.Message):
    max_tx_bytes: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    the modified transactions cannot exceed this size.
    """

    txs: "list[bytes]" = betterproto2.field(2, betterproto2.TYPE_BYTES, repeated=True)
    """
    txs is an array of transactions that will be included in a block,
    sent to the app for possible modifications.
    """

    local_last_commit: "ExtendedCommitInfo | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    misbehavior: "list[Misbehavior]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )

    height: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)

    time: "datetime.datetime | None" = betterproto2.field(
        6,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.Timestamp,
        optional=True,
    )

    next_validators_hash: "bytes" = betterproto2.field(7, betterproto2.TYPE_BYTES)

    proposer_address: "bytes" = betterproto2.field(8, betterproto2.TYPE_BYTES)
    """
    address of the public key of the validator proposing the block.
    """


default_message_pool.register_message(
    "tendermint.abci", "RequestPrepareProposal", RequestPrepareProposal
)


@dataclass(eq=False, repr=False)
class RequestProcessProposal(betterproto2.Message):
    txs: "list[bytes]" = betterproto2.field(1, betterproto2.TYPE_BYTES, repeated=True)

    proposed_last_commit: "CommitInfo | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    misbehavior: "list[Misbehavior]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )

    hash: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)
    """
    hash is the merkle root hash of the fields of the proposed block.
    """

    height: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)

    time: "datetime.datetime | None" = betterproto2.field(
        6,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: __google__protobuf__.Timestamp,
        optional=True,
    )

    next_validators_hash: "bytes" = betterproto2.field(7, betterproto2.TYPE_BYTES)

    proposer_address: "bytes" = betterproto2.field(8, betterproto2.TYPE_BYTES)
    """
    address of the public key of the original proposer of the block.
    """


default_message_pool.register_message(
    "tendermint.abci", "RequestProcessProposal", RequestProcessProposal
)


@dataclass(eq=False, repr=False)
class RequestQuery(betterproto2.Message):
    data: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    path: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    height: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)

    prove: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)


default_message_pool.register_message("tendermint.abci", "RequestQuery", RequestQuery)


@dataclass(eq=False, repr=False)
class RequestVerifyVoteExtension(betterproto2.Message):
    """
    Verify the vote extension
    """

    hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    the hash of the block that this received vote corresponds to
    """

    validator_address: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    the validator that signed the vote extension
    """

    height: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)

    vote_extension: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "tendermint.abci", "RequestVerifyVoteExtension", RequestVerifyVoteExtension
)


@dataclass(eq=False, repr=False)
class Response(betterproto2.Message):
    """
    ----------------------------------------
    Response types

    Oneofs:
        - value:
    """

    exception: "ResponseException | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    echo: "ResponseEcho | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    flush: "ResponseFlush | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    info: "ResponseInfo | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    init_chain: "ResponseInitChain | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    query: "ResponseQuery | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    check_tx: "ResponseCheckTx | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    commit: "ResponseCommit | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    list_snapshots: "ResponseListSnapshots | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    offer_snapshot: "ResponseOfferSnapshot | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    load_snapshot_chunk: "ResponseLoadSnapshotChunk | None" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    apply_snapshot_chunk: "ResponseApplySnapshotChunk | None" = betterproto2.field(
        16, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    prepare_proposal: "ResponsePrepareProposal | None" = betterproto2.field(
        17, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    process_proposal: "ResponseProcessProposal | None" = betterproto2.field(
        18, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    extend_vote: "ResponseExtendVote | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    verify_vote_extension: "ResponseVerifyVoteExtension | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )

    finalize_block: "ResponseFinalizeBlock | None" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, optional=True, group="value"
    )


default_message_pool.register_message("tendermint.abci", "Response", Response)


@dataclass(eq=False, repr=False)
class ResponseApplySnapshotChunk(betterproto2.Message):
    result: "ResponseApplySnapshotChunkResult" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ResponseApplySnapshotChunkResult(0),
    )

    refetch_chunks: "list[int]" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, repeated=True
    )
    """
    Chunks to refetch and reapply
    """

    reject_senders: "list[str]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Chunk senders to reject and ban
    """


default_message_pool.register_message(
    "tendermint.abci", "ResponseApplySnapshotChunk", ResponseApplySnapshotChunk
)


@dataclass(eq=False, repr=False)
class ResponseCheckTx(betterproto2.Message):
    code: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    data: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    log: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    nondeterministic
    """

    info: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)
    """
    nondeterministic
    """

    gas_wanted: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)

    gas_used: "int" = betterproto2.field(6, betterproto2.TYPE_INT64)

    events: "list[Event]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )

    codespace: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "tendermint.abci", "ResponseCheckTx", ResponseCheckTx
)


@dataclass(eq=False, repr=False)
class ResponseCommit(betterproto2.Message):
    retain_height: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)


default_message_pool.register_message(
    "tendermint.abci", "ResponseCommit", ResponseCommit
)


@dataclass(eq=False, repr=False)
class ResponseEcho(betterproto2.Message):
    message: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message("tendermint.abci", "ResponseEcho", ResponseEcho)


@dataclass(eq=False, repr=False)
class ResponseException(betterproto2.Message):
    """
    nondeterministic
    """

    error: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "tendermint.abci", "ResponseException", ResponseException
)


@dataclass(eq=False, repr=False)
class ResponseExtendVote(betterproto2.Message):
    vote_extension: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "tendermint.abci", "ResponseExtendVote", ResponseExtendVote
)


@dataclass(eq=False, repr=False)
class ResponseFinalizeBlock(betterproto2.Message):
    events: "list[Event]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    set of block events emmitted as part of executing the block
    """

    tx_results: "list[ExecTxResult]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    the result of executing each transaction including the events
    the particular transction emitted. This should match the order
    of the transactions delivered in the block itself
    """

    validator_updates: "list[ValidatorUpdate]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    a list of updates to the validator set. These will reflect the validator set at current height + 2.
    """

    consensus_param_updates: "_types__.ConsensusParams | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    updates to the consensus params, if any.
    """

    app_hash: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)
    """
    app_hash is the hash of the applications' state which is used to confirm that execution of the transactions was
    deterministic. It is up to the application to decide which algorithm to use.
    """


default_message_pool.register_message(
    "tendermint.abci", "ResponseFinalizeBlock", ResponseFinalizeBlock
)


@dataclass(eq=False, repr=False)
class ResponseFlush(betterproto2.Message):
    pass


default_message_pool.register_message("tendermint.abci", "ResponseFlush", ResponseFlush)


@dataclass(eq=False, repr=False)
class ResponseInfo(betterproto2.Message):
    data: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    version: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    app_version: "int" = betterproto2.field(3, betterproto2.TYPE_UINT64)

    last_block_height: "int" = betterproto2.field(4, betterproto2.TYPE_INT64)

    last_block_app_hash: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)


default_message_pool.register_message("tendermint.abci", "ResponseInfo", ResponseInfo)


@dataclass(eq=False, repr=False)
class ResponseInitChain(betterproto2.Message):
    consensus_params: "_types__.ConsensusParams | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    validators: "list[ValidatorUpdate]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )

    app_hash: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "tendermint.abci", "ResponseInitChain", ResponseInitChain
)


@dataclass(eq=False, repr=False)
class ResponseListSnapshots(betterproto2.Message):
    snapshots: "list[Snapshot]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "tendermint.abci", "ResponseListSnapshots", ResponseListSnapshots
)


@dataclass(eq=False, repr=False)
class ResponseLoadSnapshotChunk(betterproto2.Message):
    chunk: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "tendermint.abci", "ResponseLoadSnapshotChunk", ResponseLoadSnapshotChunk
)


@dataclass(eq=False, repr=False)
class ResponseOfferSnapshot(betterproto2.Message):
    result: "ResponseOfferSnapshotResult" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ResponseOfferSnapshotResult(0),
    )


default_message_pool.register_message(
    "tendermint.abci", "ResponseOfferSnapshot", ResponseOfferSnapshot
)


@dataclass(eq=False, repr=False)
class ResponsePrepareProposal(betterproto2.Message):
    txs: "list[bytes]" = betterproto2.field(1, betterproto2.TYPE_BYTES, repeated=True)


default_message_pool.register_message(
    "tendermint.abci", "ResponsePrepareProposal", ResponsePrepareProposal
)


@dataclass(eq=False, repr=False)
class ResponseProcessProposal(betterproto2.Message):
    status: "ResponseProcessProposalProposalStatus" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ResponseProcessProposalProposalStatus(0),
    )


default_message_pool.register_message(
    "tendermint.abci", "ResponseProcessProposal", ResponseProcessProposal
)


@dataclass(eq=False, repr=False)
class ResponseQuery(betterproto2.Message):
    code: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)

    log: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    bytes data = 2; // use "value" instead.

    nondeterministic
    """

    info: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)
    """
    nondeterministic
    """

    index: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)

    key: "bytes" = betterproto2.field(6, betterproto2.TYPE_BYTES)

    value: "bytes" = betterproto2.field(7, betterproto2.TYPE_BYTES)

    proof_ops: "_crypto__.ProofOps | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )

    height: "int" = betterproto2.field(9, betterproto2.TYPE_INT64)

    codespace: "str" = betterproto2.field(10, betterproto2.TYPE_STRING)


default_message_pool.register_message("tendermint.abci", "ResponseQuery", ResponseQuery)


@dataclass(eq=False, repr=False)
class ResponseVerifyVoteExtension(betterproto2.Message):
    status: "ResponseVerifyVoteExtensionVerifyStatus" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ResponseVerifyVoteExtensionVerifyStatus(0),
    )


default_message_pool.register_message(
    "tendermint.abci", "ResponseVerifyVoteExtension", ResponseVerifyVoteExtension
)


@dataclass(eq=False, repr=False)
class Snapshot(betterproto2.Message):
    """
    ----------------------------------------
    State Sync Types
    """

    height: "int" = betterproto2.field(1, betterproto2.TYPE_UINT64)
    """
    The height at which the snapshot was taken
    """

    format: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)
    """
    The application-specific snapshot format
    """

    chunks: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)
    """
    Number of chunks in the snapshot
    """

    hash: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)
    """
    Arbitrary snapshot hash, equal only if identical
    """

    metadata: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)
    """
    Arbitrary application metadata
    """


default_message_pool.register_message("tendermint.abci", "Snapshot", Snapshot)


@dataclass(eq=False, repr=False)
class TxResult(betterproto2.Message):
    """
    TxResult contains results of executing the transaction.

    One usage is indexing transaction results.
    """

    height: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)

    index: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)

    tx: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)

    result: "ExecTxResult | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("tendermint.abci", "TxResult", TxResult)


@dataclass(eq=False, repr=False)
class Validator(betterproto2.Message):
    """
    ----------------------------------------
    Blockchain Types
    """

    address: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    The first 20 bytes of SHA256(public key)
    """

    power: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)
    """
    PubKey pub_key = 2 [(gogoproto.nullable)=false];

    The voting power
    """


default_message_pool.register_message("tendermint.abci", "Validator", Validator)


@dataclass(eq=False, repr=False)
class ValidatorUpdate(betterproto2.Message):
    pub_key: "_crypto__.PublicKey | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    power: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)


default_message_pool.register_message(
    "tendermint.abci", "ValidatorUpdate", ValidatorUpdate
)


@dataclass(eq=False, repr=False)
class VoteInfo(betterproto2.Message):
    validator: "Validator | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    block_id_flag: "_types__.BlockIdFlag" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: _types__.BlockIdFlag(0)
    )


default_message_pool.register_message("tendermint.abci", "VoteInfo", VoteInfo)


class AbciStub:
    """
    NOTE: When using custom types, mind the warnings.
    https://github.com/cosmos/gogoproto/blob/master/custom_types.md#warnings-and-issues
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def echo(self, message: "RequestEcho") -> "ResponseEcho":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/Echo",
            RequestEcho.SerializeToString,
            ResponseEcho.FromString,
        )(message)

    def flush(self, message: "RequestFlush | None" = None) -> "ResponseFlush":
        if message is None:
            message = RequestFlush()

        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/Flush",
            RequestFlush.SerializeToString,
            ResponseFlush.FromString,
        )(message)

    def info(self, message: "RequestInfo") -> "ResponseInfo":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/Info",
            RequestInfo.SerializeToString,
            ResponseInfo.FromString,
        )(message)

    def check_tx(self, message: "RequestCheckTx") -> "ResponseCheckTx":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/CheckTx",
            RequestCheckTx.SerializeToString,
            ResponseCheckTx.FromString,
        )(message)

    def query(self, message: "RequestQuery") -> "ResponseQuery":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/Query",
            RequestQuery.SerializeToString,
            ResponseQuery.FromString,
        )(message)

    def commit(self, message: "RequestCommit | None" = None) -> "ResponseCommit":
        if message is None:
            message = RequestCommit()

        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/Commit",
            RequestCommit.SerializeToString,
            ResponseCommit.FromString,
        )(message)

    def init_chain(self, message: "RequestInitChain") -> "ResponseInitChain":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/InitChain",
            RequestInitChain.SerializeToString,
            ResponseInitChain.FromString,
        )(message)

    def list_snapshots(
        self, message: "RequestListSnapshots | None" = None
    ) -> "ResponseListSnapshots":
        if message is None:
            message = RequestListSnapshots()

        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/ListSnapshots",
            RequestListSnapshots.SerializeToString,
            ResponseListSnapshots.FromString,
        )(message)

    def offer_snapshot(
        self, message: "RequestOfferSnapshot"
    ) -> "ResponseOfferSnapshot":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/OfferSnapshot",
            RequestOfferSnapshot.SerializeToString,
            ResponseOfferSnapshot.FromString,
        )(message)

    def load_snapshot_chunk(
        self, message: "RequestLoadSnapshotChunk"
    ) -> "ResponseLoadSnapshotChunk":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/LoadSnapshotChunk",
            RequestLoadSnapshotChunk.SerializeToString,
            ResponseLoadSnapshotChunk.FromString,
        )(message)

    def apply_snapshot_chunk(
        self, message: "RequestApplySnapshotChunk"
    ) -> "ResponseApplySnapshotChunk":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/ApplySnapshotChunk",
            RequestApplySnapshotChunk.SerializeToString,
            ResponseApplySnapshotChunk.FromString,
        )(message)

    def prepare_proposal(
        self, message: "RequestPrepareProposal"
    ) -> "ResponsePrepareProposal":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/PrepareProposal",
            RequestPrepareProposal.SerializeToString,
            ResponsePrepareProposal.FromString,
        )(message)

    def process_proposal(
        self, message: "RequestProcessProposal"
    ) -> "ResponseProcessProposal":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/ProcessProposal",
            RequestProcessProposal.SerializeToString,
            ResponseProcessProposal.FromString,
        )(message)

    def extend_vote(self, message: "RequestExtendVote") -> "ResponseExtendVote":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/ExtendVote",
            RequestExtendVote.SerializeToString,
            ResponseExtendVote.FromString,
        )(message)

    def verify_vote_extension(
        self, message: "RequestVerifyVoteExtension"
    ) -> "ResponseVerifyVoteExtension":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/VerifyVoteExtension",
            RequestVerifyVoteExtension.SerializeToString,
            ResponseVerifyVoteExtension.FromString,
        )(message)

    def finalize_block(
        self, message: "RequestFinalizeBlock"
    ) -> "ResponseFinalizeBlock":
        return self._channel.unary_unary(
            "/tendermint.abci.ABCI/FinalizeBlock",
            RequestFinalizeBlock.SerializeToString,
            ResponseFinalizeBlock.FromString,
        )(message)


class AbciAsyncStub(betterproto2.ServiceStub):
    """
    NOTE: When using custom types, mind the warnings.
    https://github.com/cosmos/gogoproto/blob/master/custom_types.md#warnings-and-issues
    """

    async def echo(
        self,
        message: "RequestEcho",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseEcho":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/Echo",
            message,
            ResponseEcho,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def flush(
        self,
        message: "RequestFlush | None" = None,
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseFlush":
        if message is None:
            message = RequestFlush()

        return await self._unary_unary(
            "/tendermint.abci.ABCI/Flush",
            message,
            ResponseFlush,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def info(
        self,
        message: "RequestInfo",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseInfo":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/Info",
            message,
            ResponseInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def check_tx(
        self,
        message: "RequestCheckTx",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseCheckTx":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/CheckTx",
            message,
            ResponseCheckTx,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query(
        self,
        message: "RequestQuery",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseQuery":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/Query",
            message,
            ResponseQuery,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def commit(
        self,
        message: "RequestCommit | None" = None,
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseCommit":
        if message is None:
            message = RequestCommit()

        return await self._unary_unary(
            "/tendermint.abci.ABCI/Commit",
            message,
            ResponseCommit,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def init_chain(
        self,
        message: "RequestInitChain",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseInitChain":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/InitChain",
            message,
            ResponseInitChain,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_snapshots(
        self,
        message: "RequestListSnapshots | None" = None,
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseListSnapshots":
        if message is None:
            message = RequestListSnapshots()

        return await self._unary_unary(
            "/tendermint.abci.ABCI/ListSnapshots",
            message,
            ResponseListSnapshots,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def offer_snapshot(
        self,
        message: "RequestOfferSnapshot",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseOfferSnapshot":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/OfferSnapshot",
            message,
            ResponseOfferSnapshot,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def load_snapshot_chunk(
        self,
        message: "RequestLoadSnapshotChunk",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseLoadSnapshotChunk":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/LoadSnapshotChunk",
            message,
            ResponseLoadSnapshotChunk,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def apply_snapshot_chunk(
        self,
        message: "RequestApplySnapshotChunk",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseApplySnapshotChunk":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/ApplySnapshotChunk",
            message,
            ResponseApplySnapshotChunk,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def prepare_proposal(
        self,
        message: "RequestPrepareProposal",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponsePrepareProposal":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/PrepareProposal",
            message,
            ResponsePrepareProposal,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def process_proposal(
        self,
        message: "RequestProcessProposal",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseProcessProposal":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/ProcessProposal",
            message,
            ResponseProcessProposal,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def extend_vote(
        self,
        message: "RequestExtendVote",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseExtendVote":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/ExtendVote",
            message,
            ResponseExtendVote,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def verify_vote_extension(
        self,
        message: "RequestVerifyVoteExtension",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseVerifyVoteExtension":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/VerifyVoteExtension",
            message,
            ResponseVerifyVoteExtension,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def finalize_block(
        self,
        message: "RequestFinalizeBlock",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ResponseFinalizeBlock":
        return await self._unary_unary(
            "/tendermint.abci.ABCI/FinalizeBlock",
            message,
            ResponseFinalizeBlock,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from ...google import protobuf as __google__protobuf__
from .. import crypto as _crypto__
from .. import types as _types__
