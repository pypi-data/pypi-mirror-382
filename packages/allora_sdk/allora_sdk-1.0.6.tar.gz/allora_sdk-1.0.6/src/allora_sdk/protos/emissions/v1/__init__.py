# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: emissions/v1/node.proto, emissions/v1/nonce.proto, emissions/v1/reputer.proto, emissions/v1/topic.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Nonce",
    "Nonces",
    "OffchainNode",
    "ReputerRequestNonce",
    "ReputerRequestNonces",
    "ReputerValueBundle",
    "ReputerValueBundles",
    "TimestampedActorNonce",
    "Topic",
    "TopicList",
    "ValueBundle",
    "WithheldWorkerAttributedValue",
    "WorkerAttributedValue",
)

from dataclasses import dataclass

import betterproto2

from ...message_pool import default_message_pool

_COMPILER_VERSION = "0.7.1"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False)
class Nonce(betterproto2.Message):
    block_height: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    block height of the request
    """


default_message_pool.register_message("emissions.v1", "Nonce", Nonce)


@dataclass(eq=False, repr=False)
class Nonces(betterproto2.Message):
    nonces: "list[Nonce]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("emissions.v1", "Nonces", Nonces)


@dataclass(eq=False, repr=False)
class OffchainNode(betterproto2.Message):
    lib_p2p_key: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    multi_address: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    owner: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)

    node_address: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)

    node_id: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)


default_message_pool.register_message("emissions.v1", "OffchainNode", OffchainNode)


@dataclass(eq=False, repr=False)
class ReputerRequestNonce(betterproto2.Message):
    reputer_nonce: "Nonce | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    the reputers should respond to the reputer request with losses for work
    found at this worker nonce
    """


default_message_pool.register_message(
    "emissions.v1", "ReputerRequestNonce", ReputerRequestNonce
)


@dataclass(eq=False, repr=False)
class ReputerRequestNonces(betterproto2.Message):
    nonces: "list[ReputerRequestNonce]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "emissions.v1", "ReputerRequestNonces", ReputerRequestNonces
)


@dataclass(eq=False, repr=False)
class ReputerValueBundle(betterproto2.Message):
    """
    For when the bundle is computed on a per-reputer basis (ie.. if there is an
    index `m` in the above)
    """

    value_bundle: "ValueBundle | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    signature: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    pubkey: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "emissions.v1", "ReputerValueBundle", ReputerValueBundle
)


@dataclass(eq=False, repr=False)
class ReputerValueBundles(betterproto2.Message):
    reputer_value_bundles: "list[ReputerValueBundle]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "emissions.v1", "ReputerValueBundles", ReputerValueBundles
)


@dataclass(eq=False, repr=False)
class TimestampedActorNonce(betterproto2.Message):
    block_height: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    height at which value calculated or received
    """

    actor: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    nonce: "Nonce | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "emissions.v1", "TimestampedActorNonce", TimestampedActorNonce
)


@dataclass(eq=False, repr=False)
class Topic(betterproto2.Message):
    id: "int" = betterproto2.field(1, betterproto2.TYPE_UINT64)

    creator: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    metadata: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)

    loss_logic: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)

    loss_method: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)

    inference_logic: "str" = betterproto2.field(6, betterproto2.TYPE_STRING)

    inference_method: "str" = betterproto2.field(7, betterproto2.TYPE_STRING)

    epoch_last_ended: "int" = betterproto2.field(8, betterproto2.TYPE_INT64)

    epoch_length: "int" = betterproto2.field(9, betterproto2.TYPE_INT64)

    ground_truth_lag: "int" = betterproto2.field(10, betterproto2.TYPE_INT64)

    default_arg: "str" = betterproto2.field(11, betterproto2.TYPE_STRING)

    p_norm: "str" = betterproto2.field(12, betterproto2.TYPE_STRING)

    alpha_regret: "str" = betterproto2.field(13, betterproto2.TYPE_STRING)

    allow_negative: "bool" = betterproto2.field(14, betterproto2.TYPE_BOOL)


default_message_pool.register_message("emissions.v1", "Topic", Topic)


@dataclass(eq=False, repr=False)
class TopicList(betterproto2.Message):
    topics: "list[Topic]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("emissions.v1", "TopicList", TopicList)


@dataclass(eq=False, repr=False)
class ValueBundle(betterproto2.Message):
    """
    These losses and inferences are calculated per reputer or by the network
    The `m`s in the comments below exist for when they're made by reputers,
    but they may be absent implying that they were made by the network
    """

    topic_id: "int" = betterproto2.field(1, betterproto2.TYPE_UINT64)

    reputer_request_nonce: "ReputerRequestNonce | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    reputer: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)

    extra_data: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)

    combined_value: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    R_im || log10 L_im || I_i
    """

    inferer_values: "list[WorkerAttributedValue]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    R_ijm || log10 L_ijm || I_ij
    """

    forecaster_values: "list[WorkerAttributedValue]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    R_ikm || log10 L_ikm || I_ik
    """

    naive_value: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)
    """
    R^-_im  || log10 L^-_im || I^-_i
    """

    one_out_inferer_values: "list[WithheldWorkerAttributedValue]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    R^-_ilm || log10 L^-_ilm || I^-_il where l = any j
    Note: forecast-implied inferences are recomputed for each left-out
    inference
    """

    one_out_forecaster_values: "list[WithheldWorkerAttributedValue]" = (
        betterproto2.field(10, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    R^-_ilm || log10 L^-_ilm || I^-_il where l = any k
    """

    one_in_forecaster_values: "list[WorkerAttributedValue]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    R^+_ikm || log10 L^+_ikm || I^+_ik
    aka one_in_forecaster_values because equivalent to using only one
    forecast-implied inference
    """


default_message_pool.register_message("emissions.v1", "ValueBundle", ValueBundle)


@dataclass(eq=False, repr=False)
class WithheldWorkerAttributedValue(betterproto2.Message):
    worker: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    value: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "emissions.v1", "WithheldWorkerAttributedValue", WithheldWorkerAttributedValue
)


@dataclass(eq=False, repr=False)
class WorkerAttributedValue(betterproto2.Message):
    worker: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    worker who created the value
    """

    value: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "emissions.v1", "WorkerAttributedValue", WorkerAttributedValue
)
