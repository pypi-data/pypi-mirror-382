---
title: Best Practices
subtitle: Patterns, pitfalls, and advanced usage
slug: guides/agents/archival-best-practices
---

## Backfilling archives

You can pre-load archival memory with existing knowledge:

<CodeGroup>
```typescript TypeScript
// Load company policies
const policies = [
    "All replicants must undergo Voight-Kampff testing upon arrival",
    "Blade Runner units are authorized to retire rogue replicants",
    "Tyrell Corporation employees must report suspected replicants immediately"
];

for (const policy of policies) {
    await client.agents.passages.insert(agent.id, {
        content: policy,
        tags: ["policy", "company", "protocol"]
    });
}

// Load technical documentation
const docs = [
    {
        content: "Nexus-6 replicants: Superior strength, agility, and intelligence. Four-year lifespan prevents emotional development.",
        tags: ["technical", "nexus-6", "specifications"]
    },
    {
        content: "Voight-Kampff test: Measures capillary dilation, blush response, and pupil dilation to detect replicants.",
        tags: ["technical", "testing", "voight-kampff"]
    }
];

for (const doc of docs) {
    await client.agents.passages.insert(agent.id, {
        content: doc.content,
        tags: doc.tags
    });
}
```
```python Python
# Load company policies
policies = [
    "All replicants must undergo Voight-Kampff testing upon arrival",
    "Blade Runner units are authorized to retire rogue replicants",
    "Tyrell Corporation employees must report suspected replicants immediately"
]

for policy in policies:
    client.agents.passages.insert(
        agent_id=agent.id,
        content=policy,
        tags=["policy", "company", "protocol"]
    )

# Load technical documentation
docs = [
    {
        "content": "Nexus-6 replicants: Superior strength, agility, and intelligence. Four-year lifespan prevents emotional development.",
        "tags": ["technical", "nexus-6", "specifications"]
    },
    {
        "content": "Voight-Kampff test: Measures capillary dilation, blush response, and pupil dilation to detect replicants.",
        "tags": ["technical", "testing", "voight-kampff"]
    }
]

for doc in docs:
    client.agents.passages.insert(
        agent_id=agent.id,
        content=doc["content"],
        tags=doc["tags"]
    )
```
</CodeGroup>

**Use cases for backfilling:**
- Migrating knowledge bases to Letta
- Seeding specialized agents with domain knowledge
- Loading historical conversation logs
- Importing research libraries

## Enforcing archival usage with tool rules

If your agent forgets to use archival memory, you should first try prompting the agent to use it more consistently. If prompting alone doesn't work, you can enforce archival usage with [tool rules](/guides/agents/tool-rules).

**Force archival search at turn start:**

<CodeGroup>
```typescript TypeScript
await client.agents.update(agent.id, {
    toolRules: [
        { type: "init", toolName: "archival_memory_search" }
    ]
});
```
```python Python
from letta_client.types import InitToolRule

client.agents.update(
    agent_id=agent.id,
    tool_rules=[
        InitToolRule(tool_name="archival_memory_search")
    ]
)
```
</CodeGroup>

**Require archival insertion before exit:**

<CodeGroup>
```typescript TypeScript
await client.agents.update(agent.id, {
    toolRules: [
        {
            type: "child",
            toolName: "send_message",
            children: ["archival_memory_insert"]
        }
    ]
});
```
```python Python
from letta_client.types import ChildToolRule

client.agents.update(
    agent_id=agent.id,
    tool_rules=[
        ChildToolRule(
            tool_name="send_message",
            children=["archival_memory_insert"]
        )
    ]
)
```
</CodeGroup>

<Info>
**Using the ADE:** Tool rules can also be configured in the Agent Development Environment's Tool Manager interface.
</Info>

<Warning>
**Note:** Anthropic models don't support strict structured output, so tool rules may not be enforced. Use OpenAI or Gemini models for guaranteed tool rule compliance.
</Warning>

**When to use tool rules:**
- Knowledge management agents that should always search context
- Agents that need to learn from every interaction
- Librarian/archivist agents focused on information storage

**Latency considerations:** Forcing archival search adds a tool call at the start of every turn. For latency-sensitive applications (like customer support), consider making archival search optional.

[Learn more about tool rules →](/guides/agents/tool-rules)

## Best practices

**1. Avoid over-insertion**

The most common pitfall is inserting too many memories, creating clutter. Trust the agent to decide what's worth storing long-term.

**2. Create an archival policies block**

Help your agent learn how to use archival memory effectively by creating a dedicated memory block for archival usage policies:

<CodeGroup>
```typescript TypeScript
await client.blocks.create({
    label: "archival_policies",
    value: `
    When to insert into archival:
    - User preferences and important facts about the user
    - Technical specifications and reference information
    - Significant decisions or outcomes from conversations

    When NOT to insert:
    - Temporary conversational context
    - Information already stored
    - Trivial details or pleasantries

    Search strategies:
    - Use natural language questions for best results
    - Include tags when filtering by category
    - Try semantic variations if first search doesn't find what you need
    `
});
```
```python Python
client.blocks.create(
    label="archival_policies",
    value="""
    When to insert into archival:
    - User preferences and important facts about the user
    - Technical specifications and reference information
    - Significant decisions or outcomes from conversations

    When NOT to insert:
    - Temporary conversational context
    - Information already stored
    - Trivial details or pleasantries

    Search strategies:
    - Use natural language questions for best results
    - Include tags when filtering by category
    - Try semantic variations if first search doesn't find what you need
    """
)
```
</CodeGroup>

You can improve this block through conversation with your agent:

> **You:** "I noticed you didn't store the fact that I prefer TypeScript for backend development. Update your archival policies block to ensure you capture language preferences in the future."

> **Agent:** Updates the archival_policies block to include "Programming language preferences" under "When to insert into archival"

This collaborative approach helps agents learn from mistakes and improve their archival memory usage over time.

**3. Track query effectiveness**

Build self-improving agents by having them track archival search effectiveness in a memory block. This allows agents to learn which query patterns work best and refine their search strategies over time.

<CodeGroup>
```typescript TypeScript
// Create a memory block for tracking
await client.blocks.create({
    label: "archival_tracking",
    value: `
    Query patterns: Natural language questions work best
    Recent searches: "test procedures" (3 results), "replicant specs" (5 results)
    Success rate: ~85% of searches return relevant results
    Frequently searched topics: [technical specifications, protocols, case histories]
    Common patterns: Queries about technical specs work better than vague questions
    Improvements needed: Add more tags for better filtering
    `
});
```
```python Python
# Create a memory block for tracking
client.blocks.create(
    label="archival_tracking",
    value="""
    Query patterns: Natural language questions work best
    Recent searches: "test procedures" (3 results), "replicant specs" (5 results)
    Success rate: ~85% of searches return relevant results
    Frequently searched topics: [technical specifications, protocols, case histories]
    Common patterns: Queries about technical specs work better than vague questions
    Improvements needed: Add more tags for better filtering
    """
)
```
</CodeGroup>

The agent can update this block based on search results and continuously refine its archival strategy.

**4. Let agents experiment**

Agents can test different query styles to understand what works:

<CodeGroup>
```typescript TypeScript
// Agent tries variations
await archivalMemorySearch({query: "How does the Voight-Kampff test work?"})
await archivalMemorySearch({query: "Voight-Kampff procedure"})
await archivalMemorySearch({query: "replicant detection method"})
```
```python Python
# Agent tries variations
archival_memory_search(query="How does the Voight-Kampff test work?")
archival_memory_search(query="Voight-Kampff procedure")
archival_memory_search(query="replicant detection method")
```
</CodeGroup>

**Important:** Have the agent persist learnings from experimentation in a memory block (like `archival_tracking` or `archival_policies`), not in archival itself (avoid meta-clutter).

**5. Use tags consistently**

Establish a tag taxonomy and stick to it. Good language models typically handle tagging well.

**6. Add context to insertions**

❌ Don't: "Likes replicants"
✅ Do: "Deckard shows unusual empathy toward replicants, particularly Rachael, suggesting possible replicant identity"

**7. Pre-load domain knowledge**

For specialized agents, seed archival with relevant information upfront via backfilling.

**8. Consider latency**

Forced archival search adds overhead. For real-time applications, make it optional or use it selectively.

## Modifying archival memories (SDK only)

While agents cannot modify archival memories, developers can update or delete them via the SDK:

<CodeGroup>
```typescript TypeScript
// Update a memory
await client.agents.passages.update(agent.id, passage.id, {
    content: "Updated content",
    tags: ["new", "tags"]
});

// Delete a memory
await client.agents.passages.delete(agent.id, passage.id);
```
```python Python
# Update a memory
client.agents.passages.update(
    agent_id=agent.id,
    passage_id=passage.id,
    content="Updated content",
    tags=["new", "tags"]
)

# Delete a memory
client.agents.passages.delete(
    agent_id=agent.id,
    passage_id=passage.id
)
```
</CodeGroup>

This allows you to:
- Fix incorrect information
- Update outdated facts
- Remove sensitive or irrelevant data
- Reorganize tag structures

## Next steps

<CardGroup cols={2}>
  <Card
    title="Searching & Querying"
    href="/guides/agents/archival-search"
  >
    Learn how to search archival memory effectively
  </Card>
  <Card
    title="Archival Memory Overview"
    href="/guides/agents/archival-memory"
  >
    Back to archival memory overview
  </Card>
  <Card
    title="Memory Blocks"
    href="/guides/agents/memory-blocks"
  >
    Learn about always-visible memory
  </Card>
  <Card
    title="Tool Rules"
    href="/guides/agents/tool-rules"
  >
    Advanced tool execution constraints
  </Card>
</CardGroup>
