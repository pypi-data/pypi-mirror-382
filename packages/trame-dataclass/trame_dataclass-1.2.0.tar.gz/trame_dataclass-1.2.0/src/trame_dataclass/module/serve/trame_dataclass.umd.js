(function(h,c){typeof exports=="object"&&typeof module<"u"?c(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],c):(h=typeof globalThis<"u"?globalThis:h||self,c(h.trame_dataclass={},h.Vue))})(this,function(h,c){"use strict";function f(r,t,s){if(s.data._id!==r){s.data._id=r;const e=Object.keys(s.data);for(let a of e)delete s.data[a]}Object.assign(s.data,t.refs)}class d{constructor(){this.client=null,this.subscription=null,this.dataStates={},this.dataTypes={},this.typeDefinitions={},this.vueComponents={},this.internalReactiveObjects={},this.dataToVue={},this.pendingClientServerQueue=[],this.pendingFlushRequest=0}connect(t){this.client||!t||(this.client=t,this.subscription=t.getConnection().getSession().subscribe("trame.dataclass.publish",async([s])=>{const{id:e,state:a}=s;if(!this.dataStates[e]){await this.fetchState(e);return}Object.assign(this.dataStates[e].server,a);for(const[n,i]of Object.entries(a))this.isDataClass(e,n)?await this.handleNestedDataClass(e,n,i):this.dataStates[e].refs[n].value=i}))}updateServer(t,s,e){this.pendingClientServerQueue.push([t,s,e]),this.flushToServer()}async flushToServer(){if(this.pendingFlushRequest)return;this.pendingFlushRequest++;const t={};let s=0;for(;this.pendingClientServerQueue.length;){const[e,a,n]=this.pendingClientServerQueue.shift();let i=n;if(n!==null&&this.isDataClass(e,a))if(Array.isArray(n))i=n.map(l=>l._id);else if(n._id)i=n._id;else{i={};for(const[l,b]in Object.entries(n))i[l]=b._id}JSON.stringify(this.dataStates[e].server[a])!==JSON.stringify(i)&&(t[e]||(t[e]={}),t[e][a]=i,s++)}if(s)try{await this.client.getConnection().getSession().call("trame.dataclass.state.update",[t])}catch(e){console.error("Network error when pushing client state",e)}this.pendingFlushRequest--,this.pendingClientServerQueue.length&&this.flushToServer()}isDataClass(t,s){return this.typeDefinitions[this.dataTypes[t]].dataclass_containers.includes(s)}async handleNestedDataClass(t,s,e){if(e===null)this.dataStates[t].refs[s]?this.dataStates[t].refs[s].value=e:this.dataStates[t].refs[s]=c.ref(e);else if(Array.isArray(e)){const a=[];for(let n=0;n<e.length;n++){const i=e[n];let l=!1;this.internalReactiveObjects[i]||(this.internalReactiveObjects[i]=c.reactive({}),l=!0),a.push(this.internalReactiveObjects[i]),this.dataStates[i]||(l=!1,await this.fetchState(i)),l&&Object.assign(this.internalReactiveObjects[i],this.dataStates[i].refs)}this.dataStates[t].refs[s]?this.dataStates[t].refs[s].value=a:this.dataStates[t].refs[s]=c.ref(a)}else if(typeof e=="string"){const a=e;this.internalReactiveObjects[a]||(this.internalReactiveObjects[a]=c.reactive({})),this.dataStates[a]?Object.assign(this.internalReactiveObjects[a],this.dataStates[a].refs):await this.fetchState(a)}else{const a=c.reactive({});for(const[n,i]of Object.entries(e))this.internalReactiveObjects[i]||(this.internalReactiveObjects[i]=c.reactive({})),a[n]=this.internalReactiveObjects[i],this.dataStates[i]?Object.assign(this.internalReactiveObjects[i],this.dataStates[i].refs):await this.fetchState(i);this.dataStates[t].refs[s].value=a}}async fetchState(t){const s={_id:t},e=await this.client.getConnection().getSession().call("trame.dataclass.state.get",[t]);this.dataTypes[t]=e.definition,this.dataStates[t]={refs:s,server:e.state},this.typeDefinitions[e.definition]||await this.fetchDefinition(e.definition);for(const[a,n]of Object.entries(e.state))this.isDataClass(t,a)?(s[a]=c.ref(null),await this.handleNestedDataClass(t,a,n)):s[a]=c.ref(n),c.watch(()=>s[a].value,i=>this.updateServer(t,a,i));return this.dataToVue[t]&&this.dataToVue[t].forEach(a=>{f(t,this.dataStates[t],this.vueComponents[a])}),this.internalReactiveObjects[t]&&Object.assign(this.internalReactiveObjects[t],this.dataStates[t].refs),this.dataStates[t]}async fetchDefinition(t){const s=await this.client.getConnection().getSession().call("trame.dataclass.definition.get",[t]);this.typeDefinitions[t]=s}unlink(t,s){this.dataToVue[t]&&(this.dataToVue[t]=this.dataToVue[t].filter(e=>e!==s))}link(t,s){this.dataToVue[t]?this.dataToVue[t].push(s):this.dataToVue[t]=[s],this.dataStates[t]?f(t,this.dataStates[t],this.vueComponents[s]):this.fetchState(t)}connectVueComponent(t,s){var n;const e=(n=this.vueComponents[t])==null?void 0:n.id,a=s.id;this.unlink(e,t),this.vueComponents[t]=s,this.link(a,t)}disconnectVueComponent(t){var e;const s=(e=this.vueComponents[t])==null?void 0:e.id;delete this.vueComponents[t],this.unlink(s,t)}}const o=new d;let p=1;const u={TrameDataclass:{props:["instance"],setup(r){const t=c.inject("trame"),s=c.ref(!1),e=c.reactive({}),a={serverPush:!1},n=`vueDataClass${p++}`;return o.connect(t.client),c.watchEffect(()=>{if(r.instance)s.value=!0,o.connectVueComponent(n,{id:r.instance,data:e,guards:a});else{s.value=!1,o.disconnectVueComponent(n);const i=Object.keys(e);for(;i.length;)delete e[i.pop()]}}),c.onBeforeUnmount(()=>{o.disconnectVueComponent(n)}),{data:e,available:s}},template:'<slot :dataclass="data" :dataclassAvailable="available" ></slot>'}};function S(r){Object.keys(u).forEach(t=>{r.component(t,u[t])})}h.install=S,Object.defineProperty(h,Symbol.toStringTag,{value:"Module"})});
