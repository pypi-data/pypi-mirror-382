type SliderAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  min: Float
  max: Float
  step: Float
}

interface AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
}

"""The kind of assign widget."""
enum AssignWidgetKind {
  SEARCH
  CHOICE
  SLIDER
  CUSTOM
  STRING
  STATE_CHOICE
}

type ChoiceAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  choices: [Choice!]
}

type Choice {
  label: String!
  value: String!
  image: String
  description: String
}

type SearchAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  query: String!
  ward: String!
  filters: [Port!]
  dependencies: [String!]
}

type Port {
  key: String!
  label: String
  kind: PortKind!
  description: String
  identifier: Identifier
  nullable: Boolean!
  effects: [Effect!]
  default: AnyDefault
  children: [Port!]
  choices: [Choice!]
  assignWidget: AssignWidget
  returnWidget: ReturnWidget
  validators: [Validator!]
  descriptors: [Descriptor!]
}

"""The kind of port."""
enum PortKind {
  INT
  STRING
  STRUCTURE
  LIST
  BOOL
  DICT
  FLOAT
  DATE
  UNION
  ENUM
  MODEL
  MEMORY_STRUCTURE
  INTERFACE
}

"""
The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
"""
scalar Identifier

interface Effect {
  kind: EffectKind!
  function: ValidatorFunction!
  dependencies: [String!]!
}

"""The kind of effect."""
enum EffectKind {
  MESSAGE
  HIDE
  CUSTOM
}

"\n    The `Validator` scalar represents a javascript function that should execute on the client side (inside a shadow realm)\n      to validate a value (or a set of values) before it is sent to the server.  The function has two parameters (value, otherValues) and should return a string if the value is invalid and undefined if the value is valid.\n        The otherValues parameter is an object with the other values in the form {fieldName: value}."
scalar ValidatorFunction

"""
The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
"""
scalar AnyDefault

interface ReturnWidget {
  kind: ReturnWidgetKind!
}

"""The kind of return widget."""
enum ReturnWidgetKind {
  CHOICE
  CUSTOM
}

type Validator {
  function: ValidatorFunction!
  dependencies: [String!]
  label: String
  errorMessage: String
}

type Descriptor {
  key: String!
  value: Arg!
}

"""The `Arg` scalar type represents a an Argument in a Action assignment"""
scalar Arg

type StateChoiceAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  stateChoices: String!
}

type CustomReturnWidget implements ReturnWidget {
  kind: ReturnWidgetKind!
  hook: String!
  ward: String!
}

type ChoiceReturnWidget implements ReturnWidget {
  kind: ReturnWidgetKind!
  choices: [Choice!]
}

type StringAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  placeholder: String!
  asParagraph: Boolean!
}

type CustomAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  hook: String!
  ward: String!
}

type CustomEffect implements Effect {
  kind: EffectKind!
  function: ValidatorFunction!
  dependencies: [String!]!
  hook: String!
  ward: String!
}

type MessageEffect implements Effect {
  kind: EffectKind!
  function: ValidatorFunction!
  dependencies: [String!]!
  message: String!
}

type HideEffect implements Effect {
  kind: EffectKind!
  function: ValidatorFunction!
  dependencies: [String!]!
  fade: Boolean!
}

interface UIChild {
  kind: UIChildKind!
}

enum UIChildKind {
  GRID
  SPLIT
  RESERVATION
  STATE
}

type UIGrid implements UIChild {
  kind: UIChildKind!
  rowHeight: Int!
  columns: Int!
  children: [UIGridItem!]!
}

type UIGridItem {
  x: Int!
  y: Int!
  w: Int!
  h: Int!
  minW: Int!
  maxW: Int!
  child: UIChild!
}

type UISplit implements UIChild {
  kind: UIChildKind!
  left: UIChild!
  right: UIChild!
}

type UIState implements UIChild {
  kind: UIChildKind!
  state: String!
}

"""Root query type for fetching entities in the system."""
type Query {
  """List all registered clients."""
  clients(filters: ClientFilter, order: ClientOrder, pagination: OffsetPaginationInput): [Client!]!

  """List of all hardware records."""
  hardwareRecords(filters: HardwareRecordFilter, pagination: OffsetPaginationInput): [HardwareRecord!]!

  """Retrieve all compute agents."""
  agents(filters: AgentFilter, order: AgentOrder, pagination: OffsetPaginationInput): [Agent!]!

  """List of all available actions."""
  actions(filters: ActionFilter, order: ActionOrder, pagination: OffsetPaginationInput): [Action!]!

  """Retrieve protocols grouping actions."""
  protocols(filters: ProtocolFilter, order: ProtocolOrder, pagination: OffsetPaginationInput): [Protocol!]!

  """All registered implementations."""
  implementations(filters: ImplementationFilter, pagination: OffsetPaginationInput): [Implementation!]!

  """Test results associated with test cases."""
  testResults(filters: TestResultFilter, pagination: OffsetPaginationInput): [TestResult!]!

  """All test cases."""
  testCases(filters: TestCaseFilter, pagination: OffsetPaginationInput): [TestCase!]!

  """List of all reservations."""
  reservations(instanceId: InstanceId = null): [Reservation!]!

  """Reservations made by the current user."""
  myreservations(instanceId: InstanceId = null): [Reservation!]!

  """List of shortcuts."""
  shortcuts(filters: ShortcutFilter, order: ShortcutOrder, pagination: OffsetPaginationInput): [Shortcut!]!

  """List of toolboxes containing shortcuts."""
  toolboxes(filters: ToolboxFilter, order: ToolboxOrder, pagination: OffsetPaginationInput): [Toolbox!]!

  """All dashboards."""
  dashboards: [Dashboard!]!

  """All states from agents."""
  states: [State!]!

  """List of UI Blok."""
  bloks: [Blok!]!

  """List of UI Blok."""
  materializedBloks: [MaterializedBlok!]!

  """Available state schemas."""
  stateSchemas: [StateSchema!]!

  """All memory shelves."""
  memoryShelves(filters: MemoryShelveFilter, order: MemoryShelveOrder, pagination: OffsetPaginationInput): [MemoryShelve!]!

  """All memory drawers."""
  memoryDrawers(filters: MemoryDrawerFilter, pagination: OffsetPaginationInput): [MemoryDrawer!]!

  """Fetch a specific action."""
  action(id: ID = null, reservation: ID = null, assignation: ID = null, implementation: ID = null, agent: ID = null, interface: String = null, hash: ActionHash = null): Action!

  """Fetch assignations."""
  assignations(instanceId: InstanceId = null): [Assignation!]!

  """Fetch a specific event."""
  event(id: ID = null): [AssignationEvent!]!

  """Find implementation at given interface."""
  implementationAt(agent: ID!, extension: String = null, interface: String = null, actionHash: String = null, demand: ActionDemandInput = null): Implementation!

  """Find your implementation at a specific interface."""
  myImplementationAt(instanceId: String!, actionId: ID = null, interface: String = null): Implementation!

  """Retrieve state for a specific context."""
  stateFor(agent: ID!, stateHash: String = null, demand: SchemaDemandInput = null): State!

  """Get a specific state by ID."""
  state(id: ID!): State!

  """Fetch a memory shelve by ID."""
  memoryShelve(id: ID!): MemoryShelve!

  """Get a blok by ID."""
  blok(id: ID!): Blok!

  """Get a materialized blok by ID."""
  materializedBlok(id: ID!): MaterializedBlok!

  """Retrieve a state schema by ID."""
  stateSchema(id: ID!): StateSchema!

  """Get toolbox by ID."""
  toolbox(id: ID!): Toolbox!

  """Retrieve shortcut by ID."""
  shortcut(id: ID!): Shortcut!

  """Get hardware record by ID."""
  hardwareRecord(id: ID!): HardwareRecord!

  """Retrieve an agent by ID."""
  agent(id: ID!): Agent!

  """Get dashboard by ID."""
  dashboard(id: ID!): Dashboard!

  """Fetch a dependency by ID."""
  dependency(id: ID!): Dependency!

  """Retrieve test case by ID."""
  testCase(id: ID!): TestCase!

  """Get test result by ID."""
  testResult(id: ID!): TestResult!

  """Retrieve reservation by ID."""
  reservation(id: ID!): Reservation!

  """Get implementation by ID."""
  implementation(id: ID!): Implementation!

  """Fetch assignation by ID."""
  assignation(id: ID!): Assignation!
}

"""Represents a registered OAuth2 client."""
type Client {
  """Unique ID of the client."""
  id: ID!

  """Name of the client."""
  name: String!

  """OAuth2 client ID."""
  clientId: String!
}

"""A way to filter apps"""
input ClientFilter {
  interface: StrFilterLookup
  ids: [ID!]
  hasImplementationsFor: [ActionHash!]
  mine: Boolean
  AND: ClientFilter
  OR: ClientFilter
  NOT: ClientFilter
  DISTINCT: Boolean
}

input StrFilterLookup {
  exact: String
  iExact: String
  contains: String
  iContains: String
  inList: [String!]
  gt: String
  gte: String
  lt: String
  lte: String
  startsWith: String
  iStartsWith: String
  endsWith: String
  iEndsWith: String
  range: [String!]
  isNull: Boolean
  regex: String
  iRegex: String
}

"""
The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
"""
scalar ActionHash

"""A way to order apps"""
input ClientOrder {
  definedAt: Ordering
}

enum Ordering {
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
}

input OffsetPaginationInput {
  offset: Int! = 0
  limit: Int
}

"""Represents a record of an agent's hardware configuration."""
type HardwareRecord {
  """Unique ID of the hardware record."""
  id: ID!

  """Number of CPU cores available."""
  cpuCount: Int!

  """Vendor of the CPU."""
  cpuVendorName: String!

  """Clock speed of the CPU in GHz."""
  cpuFrequency: Float!

  """Timestamp when this record was created."""
  createdAt: DateTime!

  """The agent to which this hardware belongs."""
  agent: Agent!
}

"""Date with time (isoformat)"""
scalar DateTime

"""Represents a compute agent that can execute implementations."""
type Agent {
  """Unique ID of the agent."""
  id: ID!

  """Unique instance identifier on the agent."""
  instanceId: InstanceId!

  """Registry entry this agent belongs to."""
  registry: Registry!

  """Historical records of agent's hardware."""
  hardwareRecords(filters: HardwareRecordFilter, pagination: OffsetPaginationInput): [HardwareRecord!]!

  """Implementations the agent can run."""
  implementations(filters: ImplementationFilter, pagination: OffsetPaginationInput): [Implementation!]!

  """Agent's associated memory shelve."""
  memoryShelve: MemoryShelve

  """Filesystem shelves available on the agent."""
  fileSystemShelves(filters: FilesystemShelveFilter, pagination: OffsetPaginationInput): [FilesystemShelve!]!

  """Last timestamp this agent was seen."""
  lastSeen: DateTime

  """Is the agent currently connected."""
  connected: Boolean!

  """List of installed agent extensions."""
  extensions: [String!]!

  """Agent name."""
  name: String!

  """Current and historical states associated with the agent."""
  states: [State!]!

  """Kind of the agent."""
  kind: AgentKind!

  """Webhook URL for this Agent (only if webhook)"""
  hookUrl: String

  """Webhook URL secret for this Agent (only if webhook)"""
  hookUrlSecret: String

  """Fetch a specific implementation by interface."""
  implementation(interface: String!): Implementation

  """
  Determine if the agent is currently active based on last seen timestamp.
  """
  active: Boolean!

  """Retrieve the latest hardware record for this agent."""
  latestHardwareRecord: HardwareRecord

  """Check if this agent is pinned by the current user."""
  pinned: Boolean!
}

"""The `InstanceID` scalar type represents a unique instance identifier"""
scalar InstanceId

"""Links a user and a client for registry tracking."""
type Registry {
  """Unique identifier for the registry."""
  id: ID!

  """The associated client."""
  client: Client!

  """The associated user."""
  user: User!

  """The organization this registry belongs to."""
  organization: Organization!

  """Agents registered under this registry."""
  agents(filters: AgentFilter, order: AgentOrder, pagination: OffsetPaginationInput): [Agent!]!
}

"""Represents an authenticated user."""
type User {
  """The subject identifier of the user."""
  sub: ID!
}

"""Represents an organization in the system."""
type Organization {
  """Slug of the organization."""
  slug: String!
}

"""A way to filter agents"""
input AgentFilter {
  scope: ScopeFilter = null

  """Filter by client ID of the app the agent is registered to"""
  clientId: String = null

  """Filter by instance ID of the agent"""
  instanceId: String = null

  """Filter by IDs of the agents"""
  ids: [ID!] = null

  """Filter by extensions of the agents"""
  extensions: [String!] = null

  """Filter by implementations of the agents"""
  hasImplementations: [String!] = null

  """Filter by states of the agents"""
  hasStates: [String!] = null

  """Filter by pinned agents"""
  pinned: Boolean = null

  """Filter by name of the agents"""
  search: String = null
  distinct: Boolean
  actionDemands: [ActionDemandInput!]
  stateDemands: [SchemaDemandInput!]
  AND: AgentFilter
  OR: AgentFilter
  NOT: AgentFilter
  DISTINCT: Boolean
}

"""A way to filter by scope"""
input ScopeFilter {
  public: Boolean = null
  org: Boolean = null
  shared: Boolean = null
  me: Boolean = null
}

"""The input for creating a action demand."""
input ActionDemandInput {
  """
  The key of the action. This is used to identify the action in the system.
  """
  key: String!

  """
  The hash of the action. This is used to identify the action in the system.
  """
  hash: ActionHash = null

  """
  The name of the action. This is used to identify the action in the system.
  """
  name: String = null

  """
  The description of the action. This can described the action and its purpose.
  """
  description: String = null

  """
  The demands for the action args and returns. This is used to identify the demand in the system.
  """
  argMatches: [PortMatchInput!] = null

  """
  The demands for the action args and returns. This is used to identify the demand in the system.
  """
  returnMatches: [PortMatchInput!] = null

  """
  The protocols that the action has to implement. This is used to identify the demand in the system.
  """
  protocols: [ID!] = null

  """
  Require that the action has a specific number of args. This is used to identify the demand in the system.
  """
  forceArgLength: Int = null

  """
  Require that the action has a specific number of returns. This is used to identify the demand in the system.
  """
  forceReturnLength: Int = null
}

"""
A dependency for a implementation. By defining dependencies, you can
    create a dependency graph for your implementations and actions
"""
input PortMatchInput {
  at: Int = null
  key: String = null
  kind: PortKind = null
  identifier: String = null
  nullable: Boolean = null
  children: [PortMatchInput!] = null
}

"""The input for creating a action demand."""
input SchemaDemandInput {
  """
  The key of the action. This is used to identify the action in the system.
  """
  key: String!

  """The hash of the state."""
  hash: ActionHash = null

  """
  The demands for the action args and returns. This is used to identify the demand in the system.
  """
  matches: [PortMatchInput!] = null

  """
  The protocols that the action has to implement. This is used to identify the demand in the system.
  """
  protocols: [ID!] = null
}

input AgentOrder {
  lastSeen: Ordering
}

input HardwareRecordFilter {
  ids: [ID!]
  cpuVendorName: String
  AND: HardwareRecordFilter
  OR: HardwareRecordFilter
  NOT: HardwareRecordFilter
  DISTINCT: Boolean
}

"""Represents a concrete implementation of an action."""
type Implementation {
  """Unique ID of the implementation."""
  id: ID!

  """Interface string representing the implementation entrypoint."""
  interface: String!

  """Extension or module name."""
  extension: String!

  """Agent running this implementation."""
  agent: Agent!

  """The action this implements."""
  action: Action!

  """Arbitrary parameters for the implementation."""
  params: AnyDefault!

  """Dependencies required by this implementation."""
  dependencies(filters: DependencyFilter, pagination: OffsetPaginationInput): [Dependency!]!

  """Constructed name for display, combining interface and agent name."""
  name: String!

  """Check if this implementation is pinned by the current user."""
  pinned: Boolean!

  """Get the latest completed assignation created by the current user."""
  myLatestAssignation: Assignation
}

"""Represents an executable action in the system."""
type Action {
  """Unique ID of the action."""
  id: ID!

  """Unique hash identifying the action definition."""
  hash: ActionHash!

  """Name of the action."""
  name: String!

  """The kind or category of the action."""
  kind: ActionKind!

  """Indicates whether the action maintains state."""
  stateful: Boolean!

  """Optional description of the action."""
  description: String

  """Collections to which this action belongs."""
  collections: [Collection!]!

  """List of implementations for this action."""
  implementations(filters: ImplementationFilter, pagination: OffsetPaginationInput): [Implementation!]!

  """Scope of the action, e.g., user or system."""
  scope: ActionScope!

  """Actions for which this is a test."""
  isTestFor(filters: ActionFilter, order: ActionOrder, pagination: OffsetPaginationInput): [Action!]!

  """Marks whether the action is in development."""
  isDev: Boolean!

  """List of tests associated with the action."""
  tests(filters: ActionFilter, order: ActionOrder, pagination: OffsetPaginationInput): [Action!]!

  """Interfaces implemented by the action."""
  interfaces: [String!]!

  """Protocols associated with the action."""
  protocols(filters: ProtocolFilter, order: ProtocolOrder, pagination: OffsetPaginationInput): [Protocol!]!

  """Timestamp when the action was defined."""
  definedAt: DateTime!

  """Reservations related to this action."""
  reservations(filters: ReservationFilter, pagination: OffsetPaginationInput): [Reservation!]

  """Test cases for this action."""
  testCases(filters: TestCaseFilter, pagination: OffsetPaginationInput): [TestCase!]

  """Retrieve assignations where this action has run."""
  runs: [Assignation!]

  """Input arguments (ports) for the action."""
  args: [Port!]!

  """Output values (ports) returned by the action."""
  returns: [Port!]!

  """Port groups used in the action for organizing ports."""
  portGroups: [PortGroup!]!

  """Check if the current user has pinned this action."""
  pinned: Boolean!
}

"""The kind of action."""
enum ActionKind {
  FUNCTION
  GENERATOR
}

"""A grouping of actions."""
type Collection {
  """Collection ID."""
  id: ID!

  """Name of the collection."""
  name: String!

  """Actions included in this collection."""
  actions(filters: ActionFilter, order: ActionOrder, pagination: OffsetPaginationInput): [Action!]!
}

input ActionFilter {
  search: String
  name: StrFilterLookup
  ids: [ID!]
  demands: [PortDemandInput!]
  protocols: [String!]
  kind: ActionKind
  inCollection: String
  AND: ActionFilter
  OR: ActionFilter
  NOT: ActionFilter
  DISTINCT: Boolean
}

"""The input for creating a port demand."""
input PortDemandInput {
  """The kind of the demand. You can ask for args or returns"""
  kind: DemandKind!

  """The matches of the demand. """
  matches: [PortMatchInput!] = null

  """
  Require that the action has a specific number of ports. This is used to identify the demand in the system.
  """
  forceLength: Int = null

  """
  Require that the action has a specific number of non-nullable ports. This is used to identify the demand in the system.
  """
  forceNonNullableLength: Int = null

  """
  Require that the action has a specific number of structure ports. This is used to identify the demand in the system.
  """
  forceStructureLength: Int = null
}

enum DemandKind {
  ARGS
  RETURNS
}

input ActionOrder {
  definedAt: Ordering
}

input ImplementationFilter {
  interface: StrFilterLookup
  ids: [ID!]
  actionHash: ActionHash
  action: ImplementationActionFilter
  extension: String
  agent: ImplementationAgentFilter
  parameters: [ParamPair!]
  AND: ImplementationFilter
  OR: ImplementationFilter
  NOT: ImplementationFilter
  DISTINCT: Boolean
}

input ImplementationActionFilter {
  search: String
  name: String
  ids: [ID!]
  demands: [PortDemandInput!]
  protocols: [String!]
  kind: ActionKind
  AND: ImplementationActionFilter
  OR: ImplementationActionFilter
  NOT: ImplementationActionFilter
  DISTINCT: Boolean
}

input ImplementationAgentFilter {
  clientId: String
  instanceId: String
  ids: [ID!]
  extensions: [String!]
  hasImplementations: [String!]
  hasStates: [String!]
  AND: ImplementationAgentFilter
  OR: ImplementationAgentFilter
  NOT: ImplementationAgentFilter
  DISTINCT: Boolean
}

input ParamPair {
  key: String!
  value: String!
}

enum ActionScope {
  GLOBAL
  LOCAL
  BRIDGE_GLOBAL_TO_LOCAL
  BRIDGE_LOCAL_TO_GLOBAL
}

"""A set of related actions forming a protocol."""
type Protocol {
  """Protocol ID."""
  id: ID!

  """Name of the protocol."""
  name: String!

  """Associated actions."""
  actions(filters: ActionFilter, order: ActionOrder, pagination: OffsetPaginationInput): [Action!]!
}

input ProtocolFilter {
  search: String
  name: StrFilterLookup
  ids: [ID!]
  AND: ProtocolFilter
  OR: ProtocolFilter
  NOT: ProtocolFilter
  DISTINCT: Boolean
}

input ProtocolOrder {
  name: Ordering
}

"""Reservation for planned assignment of implementations."""
type Reservation {
  """ID of the reservation."""
  id: ID!

  """Name of the reservation."""
  name: String!

  """Waiter associated with the reservation."""
  waiter: Waiter!

  """Optional title."""
  title: String

  """Action this reservation is for."""
  action: Action!

  """Last update timestamp."""
  updatedAt: DateTime!

  """Reference string for identification."""
  reference: String!

  """Available implementations for the reservation."""
  implementations(filters: ImplementationFilter, pagination: OffsetPaginationInput): [Implementation!]!

  """Bind configuration for the reservation."""
  binds: Binds

  """Dependency that triggered the reservation."""
  causingDependency: Dependency

  """Reservation strategy applied."""
  strategy: ReservationStrategy!

  """Is the reservation currently viable."""
  viable: Boolean!

  """Did the reservation succeed."""
  happy: Boolean!

  """Chosen implementation."""
  implementation: Implementation
}

"""Entity that waits for the completion of assignations."""
type Waiter {
  """Unique ID of the waiter."""
  id: ID!

  """Instance ID associated with the waiter."""
  instanceId: InstanceId!

  """Registry the waiter belongs to."""
  registry: Registry!
}

type Binds {
  implementations: [ID!]!
  clients: [ID!]!
  desiredInstances: Int!
}

"""Represents a dependency between implementations and actions."""
type Dependency {
  """Unique ID of the dependency."""
  id: ID!

  """Implementation this dependency belongs to."""
  implementation: Implementation!

  """Original hash when the dependency was created."""
  actionHash: ActionHash

  """Optional string identifier or tag for reference."""
  key: String!

  """Indicates if the dependency is optional."""
  optional: Boolean!

  """Protocols that this dependency needs to match."""
  returnMatches: [PortMatch!]

  """Protocols that this dependency needs to match."""
  argMatches: [PortMatch!]

  """Check if this dependency can be resolved by a connected agent."""
  resolvable: Boolean!
}

type PortMatch {
  at: Int
  key: String
  kind: PortKind
  identifier: String
  children: [PortMatch!]
  nullable: Boolean
  descriptors: [DescriptorMatch!]
}

type DescriptorMatch {
  key: String
  operator: DescriptorOperator
  value: String
}

"""The operator for matching descriptors."""
enum DescriptorOperator {
  LTE
  GTE
  EQUALS
  CONTAINS
  NOT_EQUALS
  IN
  NOT_IN
  EXISTS
}

"""The pattern of assignment of the reservation"""
enum ReservationStrategy {
  RANDOM
  ROUND_ROBIN
  LEAST_BUSY
  LEAST_TIME
  LEAST_LOAD
  DIRECT
}

"""A way to filter reservations"""
input ReservationFilter {
  waiter: WaiterFilter
  ids: [ID!]
  status: [ReservationStatus!]
  AND: ReservationFilter
  OR: ReservationFilter
  NOT: ReservationFilter
  DISTINCT: Boolean
}

"""A way to filter waiters"""
input WaiterFilter {
  instanceId: InstanceId!
  ids: [ID!]
  AND: WaiterFilter
  OR: WaiterFilter
  NOT: WaiterFilter
  DISTINCT: Boolean
}

enum ReservationStatus {
  ACTIVE
  INACTIVE
  UNHAPPY
  HAPPY
  UNCONNECTED
  ENDED
}

"""Defines a test case comparing expected behavior for actions."""
type TestCase {
  """Unique ID of the test case."""
  id: ID!

  """Action used to perform the test."""
  tester: Action!

  """Target action under test."""
  action: Action!

  """If true, measures performance rather than correctness."""
  isBenchmark: Boolean!

  """Details of what this test case covers."""
  description: String!

  """Short name for the test case."""
  name: String!

  """Results from running this test case."""
  results(filters: TestResultFilter, pagination: OffsetPaginationInput): [TestResult!]!
}

"""Result from executing a test case with specific implementations."""
type TestResult {
  """ID of the test result."""
  id: ID!

  """Implementation under test."""
  implementation: Implementation!

  """Implementation running the test."""
  tester: Implementation!

  """Associated test case."""
  case: TestCase!

  """True if test passed."""
  passed: Boolean!

  """When the test was executed."""
  createdAt: DateTime!

  """When the test result was last updated."""
  updatedAt: DateTime!
}

"""A way to filter test results"""
input TestResultFilter {
  name: StrFilterLookup
  ids: [ID!]
  AND: TestResultFilter
  OR: TestResultFilter
  NOT: TestResultFilter
  DISTINCT: Boolean
}

"""A way to filter test cases"""
input TestCaseFilter {
  name: StrFilterLookup
  ids: [ID!]
  AND: TestCaseFilter
  OR: TestCaseFilter
  NOT: TestCaseFilter
  DISTINCT: Boolean
}

"""Tracks the assignment of an implementation to a specific task."""
type Assignation {
  """Unique ID of the assignation."""
  id: ID!

  """Optional external reference for tracking."""
  reference: String

  """Indicates if the assignation is completed."""
  isDone: Boolean!

  """Arguments used in the assignation."""
  args: AnyDefault!

  """Root assignation in the creation chain."""
  root: Assignation

  """Parent assignation that triggered this one."""
  parent: Assignation

  """Reservation that caused this assignation."""
  reservation: Reservation

  """Action assigned."""
  action: Action!

  """Implementation assigned to execute."""
  implementation: Implementation!

  """Type of the latest event."""
  latestEventKind: AssignationEventKind!

  """Last instruction type."""
  latestInstructKind: AssignationInstructKind!

  """Current status message."""
  statusMessage: String

  """Waiter responsible for this assignation."""
  waiter: Waiter!

  """Creation timestamp."""
  createdAt: DateTime!

  """Last update timestamp."""
  updatedAt: DateTime!

  """Indicates if the assignation should be deleted after completion."""
  ephemeral: Boolean!

  """Child assignations spawned from this one."""
  children(filters: AssignationFilter, pagination: OffsetPaginationInput): [Assignation!]!

  """List of recent events for this assignation."""
  events: [AssignationEvent!]!

  """List of recent instructions for this assignation."""
  instructs: [AssignationInstruct!]!

  """Get a specific argument by key."""
  arg(key: String!): Args
}

"""The event kind of the assignationevent"""
enum AssignationEventKind {
  BOUND
  QUEUED
  ASSIGN
  PROGRESS
  DELEGATE
  DISCONNECTED
  YIELD
  DONE
  LOG
  CANCELING
  CANCELLED
  INTERUPTING
  INTERUPTED
  ERROR
  CRITICAL
}

"""The event kind of the assignationevent"""
enum AssignationInstructKind {
  ASSIGN
  CANCEL
  STEP
  RESUME
  PAUSE
  INTERRUPT
  COLLECT
}

input AssignationFilter {
  reservation: ReservationFilter
  ids: [ID!]
  status: [AssignationStatus!]
  instanceId: InstanceId
  AND: AssignationFilter
  OR: AssignationFilter
  NOT: AssignationFilter
  DISTINCT: Boolean
}

"""The event kind of the assignationevent"""
enum AssignationStatus {
  ASSIGNING
  ONGOING
  CRITICAL
  CANCELLED
  DONE
}

"""An event that occurred during an assignation."""
type AssignationEvent {
  """Unique ID of the event."""
  id: ID!

  """Name of the event."""
  name: String!

  """Optional return values."""
  returns: AnyDefault

  """Associated assignation."""
  assignation: Assignation!

  """Kind of assignation event."""
  kind: AssignationEventKind!

  """Optional message associated with the event."""
  message: String

  """Progress percentage."""
  progress: Int

  """Time when event was created."""
  createdAt: DateTime!

  """If this event was delegated, the assignation it was delegated to."""
  delegatedTo: Assignation

  """Default log level."""
  level: LogLevel!

  """Reference string for the event."""
  reference: String!
}

enum LogLevel {
  DEBUG
  INFO
  ERROR
  WARN
  CRITICAL
}

"""An instruct event for a specific assignation."""
type AssignationInstruct {
  """Unique ID of the instruct event."""
  id: ID!

  """Assignation the instruction relates to."""
  assignation: Assignation!

  """Type of instruction."""
  kind: AssignationInstructKind!

  """Time when instruction was issued."""
  createdAt: DateTime!
}

"""The `Args` scalar type represents a Dictionary of arguments"""
scalar Args

type PortGroup {
  key: String!
  title: String
  description: String
  effects: [Effect!]
  ports: [String!]!
}

input DependencyFilter {
  ids: [ID!]
  AND: DependencyFilter
  OR: DependencyFilter
  NOT: DependencyFilter
  DISTINCT: Boolean
}

"""A shelve for storing memory-based resources on an agent."""
type MemoryShelve {
  """ID of the memory shelve."""
  id: ID!

  """Agent that owns this memory shelve."""
  agent: Agent!

  """Name of the shelve."""
  name: String!

  """Optional description of the shelve."""
  description: String

  """List of memory drawers within the shelve."""
  drawers(filters: MemoryDrawerFilter, pagination: OffsetPaginationInput): [MemoryDrawer!]!
}

type MemoryDrawer {
  id: ID!
  resourceId: String!
  shelve: MemoryShelve!
  identifier: String!
  description: String
  createdAt: DateTime!

  """Get the latest value stored in this drawer."""
  label: String!
}

"""A way to filter shelved items"""
input MemoryDrawerFilter {
  shelve: ID
  agent: ID
  implementation: ID
  identifier: String
  ids: [ID!]
  search: String
  AND: MemoryDrawerFilter
  OR: MemoryDrawerFilter
  NOT: MemoryDrawerFilter
  DISTINCT: Boolean
}

"""Shelve on an agent for filesystem-based resources."""
type FilesystemShelve {
  """ID of the filesystem shelve."""
  id: ID!

  """List of file drawers in the shelve."""
  drawers(filters: FileDrawerFilter, pagination: OffsetPaginationInput): [FileDrawer!]!
}

"""Represents a file-based drawer within a filesystem shelve."""
type FileDrawer {
  """ID of the file drawer."""
  id: ID!

  """External resource identifier."""
  resourceId: String!

  """Agent owning the drawer."""
  agent: Agent!

  """Unique string identifying the drawer."""
  identifier: String!

  """Creation timestamp of the drawer."""
  createdAt: DateTime!
}

"""A way to filter shelved items"""
input FileDrawerFilter {
  shelve: ID
  agent: ID
  identifier: String
  ids: [ID!]
  AND: FileDrawerFilter
  OR: FileDrawerFilter
  NOT: FileDrawerFilter
  DISTINCT: Boolean
}

"""A way to filter shelved items"""
input FilesystemShelveFilter {
  ids: [ID!]
  AND: FilesystemShelveFilter
  OR: FilesystemShelveFilter
  NOT: FilesystemShelveFilter
  DISTINCT: Boolean
}

type State {
  id: ID!
  stateSchema: StateSchema! @deprecated(reason: "Use schema instead")
  value: Args!
  agent: Agent!
  interface: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  historicalStates: [HistoricalState!]!
  schema: StateSchema! @deprecated(reason: "Use schema instead")
}

type StateSchema {
  id: ID!
  hash: String!
  name: String!
  ports: [Port!]!
}

type HistoricalState {
  id: ID!
  state: State!
  value: Args!
  archivedAt: DateTime!
}

enum AgentKind {
  WEBSOCKET
  WEBHOOK
}

"""Shortcut to an action with preset arguments."""
type Shortcut {
  """Shortcut ID."""
  id: ID!

  """Name of the shortcut."""
  name: String!

  """Optional description."""
  description: String

  """The associated action."""
  action: Action!

  """Implementation of the action."""
  implementation: Implementation

  """Toolboxes that contain this shortcut."""
  toolboxes(filters: ToolboxFilter, order: ToolboxOrder, pagination: OffsetPaginationInput): [Toolbox!]!

  """Saved arguments for the shortcut."""
  savedArgs: AnyDefault!

  """Allow quick execution without modification."""
  allowQuick: Boolean!

  """If true, shortcut uses return values."""
  useReturns: Boolean!

  """
  Which shortcut should be bound to this Action by default. 0 means no binding.
  """
  bindNumber: Int

  """Input ports for the shortcut's action.dd"""
  args: [Port!]!

  """Return ports from the shortcut's action."""
  returns: [Port!]!
}

"""A collection of shortcuts grouped as a toolbox."""
type Toolbox {
  """Toolbox ID."""
  id: ID!

  """Name of the toolbox."""
  name: String!

  """Description of the toolbox."""
  description: String!

  """List of shortcuts in this toolbox."""
  shortcuts(filters: ShortcutFilter, order: ShortcutOrder, pagination: OffsetPaginationInput): [Shortcut!]!
}

input ShortcutFilter {
  search: String
  ids: [ID!]
  demands: [PortDemandInput!]
  toolbox: ID
  AND: ShortcutFilter
  OR: ShortcutFilter
  NOT: ShortcutFilter
  DISTINCT: Boolean
}

input ShortcutOrder {
  name: Ordering
}

input ToolboxFilter {
  search: String
  name: StrFilterLookup
  ids: [ID!]
  AND: ToolboxFilter
  OR: ToolboxFilter
  NOT: ToolboxFilter
  DISTINCT: Boolean
}

input ToolboxOrder {
  name: Ordering
}

type Dashboard {
  id: ID!
  name: String
  materializedBloks: [MaterializedBlok!]!
  uiTree: UITree
}

type MaterializedBlok {
  id: ID!
  dashboard: Dashboard!
  blok: Blok!
  agent: Agent!
  name: String
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!

  """Mappings of states to this materialized blok."""
  stateMappings: [StateMapping!]!

  """Mappings of actions to this materialized blok."""
  actionMappings: [ActionMapping!]!
}

type Blok {
  id: ID!
  name: String!
  description: String
  creator: User!
  url: String!

  """Materialized bloks that are instances of this blok."""
  materializedBloks: [MaterializedBlok!]!

  """Get the actions that this blok can run."""
  actionDemands: [ActionDemand!]!

  """Get the actions that this blok can run."""
  stateDemands: [StateDemand!]!

  """Get the agents that this blok can be implemented against."""
  possibleAgents: [Agent!]!
}

"""Input model for action demand."""
type ActionDemand {
  key: String!
  hash: ActionHash
  name: String
  description: String
  argMatches: [PortMatch!]
  returnMatches: [PortMatch!]
  protocols: [ID!]
  forceArgLength: Int
  forceReturnLength: Int
}

"""The input for creating a action demand."""
type StateDemand {
  key: String!
  hash: ActionHash
  matches: [PortMatch!]
  protocols: [ID!]
}

type StateMapping {
  id: ID!
  key: String!
  implementation: Implementation!
  state: State!
  crreatedAt: DateTime!
  updatedAt: DateTime!
}

type ActionMapping {
  id: ID!
  key: String!
  implementation: Implementation!
  materializedBlok: MaterializedBlok!
  crreatedAt: DateTime!
  updatedAt: DateTime!
}

type UITree {
  child: UIChild!
}

"""A way to filter shelved items"""
input MemoryShelveFilter {
  agent: ID
  ids: [ID!]
  AND: MemoryShelveFilter
  OR: MemoryShelveFilter
  NOT: MemoryShelveFilter
  DISTINCT: Boolean
}

input MemoryShelveOrder {
  name: Ordering
}

"""Root mutation type for executing write operations on the API."""
type Mutation {
  """Create a new implementation entry."""
  createImplementation(input: CreateImplementationInput!): Implementation!

  """Register an external implementation."""
  createForeignImplementation(input: CreateForeignImplementationInput!): Implementation!

  """Set implementations provided by an extension."""
  setExtensionImplementations(input: SetExtensionImplementationsInput!): [Implementation!]!

  """Acknowledge an assignation."""
  ack(input: AckInput!): Assignation!

  """Assign a task to an agent."""
  assign(input: AssignInput!): Assignation!

  """Cancel an active assignation."""
  cancel(input: CancelInput!): Assignation!

  """Advance an assignation one step."""
  step(input: StepInput!): Assignation!

  """Pause an ongoing assignation."""
  pause(input: PauseInput!): Assignation!

  """Resume a paused assignation."""
  resume(input: ResumeInput!): Assignation!

  """Collect results from an assignation."""
  collect(input: CollectInput!): [String!]!

  """Interrupt the execution of an assignation."""
  interrupt(input: InterruptInput!): Assignation!

  """Reinitialize the assignation or agent."""
  reinit(input: ReInitInput!): String!

  """Reserve an implementation for future use."""
  reserve(input: ReserveInput!): Reservation!

  """Release a reserved implementation."""
  unreserve(input: UnreserveInput!): String!

  """Delete a registered implementation."""
  deleteImplementation(input: DeleteImplementationInput!): String!

  """Ensure agent record exists or is up to date."""
  ensureAgent(input: AgentInput!): Agent!

  """Create a new test case."""
  createTestCase(input: CreateTestCaseInput!): TestCase!

  """Create a test result record."""
  createTestResult(input: CreateTestResultInput!): TestResult!

  """Shelve data into a memory drawer."""
  shelveInMemoryDrawer(input: ShelveInMemoryDrawerInput!): MemoryDrawer!

  """Unshelve data from a memory drawer."""
  unshelveMemoryDrawer(input: UnshelveMemoryDrawerInput!): ID!

  """Create a dashboard layout."""
  createDashboard(input: CreateDashboardInput!): Dashboard!

  """Define a new state schema."""
  createStateSchema(input: CreateStateSchemaInput!): StateSchema!

  """Create a user interface panel."""
  createBlok(input: CreateBlokInput!): Blok!

  """Set the value of a state object."""
  setState(input: SetStateInput!): State!

  """Materialize a UI blok into a concrete instance on a dashboard."""
  materializeBlok(input: MaterializeBlokInput!): MaterializedBlok!

  """Update fields in a state object."""
  updateState(input: UpdateStateInput!): State!

  """Archive a state schema."""
  archiveState(input: ArchiveStateInput!): State!

  """Pin an agent to the user."""
  pinAgent(input: PinInput!): Agent!

  """Pin an implementation to the user."""
  pinImplementation(input: PinInput!): Implementation!

  """Delete an agent record."""
  deleteAgent(input: DeleteAgentInput!): ID!

  """Create a shortcut to an action."""
  createShortcut(input: CreateShortcutInput!): Shortcut!

  """Delete a shortcut."""
  deleteShortcut(input: DeleteShortcutInput!): ID!

  """Create a new toolbox with shortcuts."""
  createToolbox(input: CreateToolboxInput!): Toolbox!

  """Set states for an agent."""
  setAgentStates(input: SetAgentStatesInput!): [State!]!
}

"""The input for creating a implementation."""
input CreateImplementationInput {
  implementation: ImplementationInput!
  instanceId: InstanceId!
  extension: String!
}

"""
A implementation is a blueprint for a action. It is composed of a definition, a list of dependencies, and a list of params.
"""
input ImplementationInput {
  definition: DefinitionInput!
  dependencies: [ActionDependencyInput!]!
  interface: String
  params: AnyDefault = null
  dynamic: Boolean! = false
  logo: String = null
}

"A definition\n\n    Definitions are the building implementation for Actions and provide the\n    information needed to create a action. They are primarly composed of a name,\n    a description, and a list of ports.\n\n    Definitions provide a protocol of input and output, and do not contain\n    any information about the actual implementation of the action ( this is handled\n    by a implementation that implements a action).\n\n\n\n\n    "
input DefinitionInput {
  """
  The description of the definition. This is the text that is displayed in the UI
  """
  description: String = null

  """
  The collections of the definition. This is used to group definitions together in the UI
  """
  collections: [String!]! = []

  """
  The name of the actions. This is used to uniquely identify the definition
  """
  name: String!

  """
  Whether the definition is stateful or not. If the definition is stateful, it can be used to create a stateful action. If the definition is not stateful, it cannot be used to create a stateful action
  """
  stateful: Boolean! = false

  """
  The port groups of the definition. This is used to group ports together in the UI
  """
  portGroups: [PortGroupInput!]! = []

  """The args of the definition. This is the input ports of the definition"""
  args: [PortInput!]! = []

  """
  The returns of the definition. This is the output ports of the definition
  """
  returns: [PortInput!]! = []

  """
  The kind of the definition. This is the type of the definition. Can be either a function or a generator
  """
  kind: ActionKind!

  """
  The tests for the definition. This is used to group definitions together in the UI
  """
  isTestFor: [String!]! = []

  """
  The interfaces of the definition. This is used to group definitions together in the UI
  """
  interfaces: [String!]! = []

  """
  Whether the definition is a dev definition or not. If the definition is a dev definition, it can be used to create a dev action. If the definition is not a dev definition, it cannot be used to create a dev action
  """
  isDev: Boolean! = false

  """The logo of the definition. This is used to display the logo in the UI"""
  logo: String = null
}

"""
A Port Group is a group of ports that are related to each other. It is used to group ports together in the UI and provide a better user experience.
"""
input PortGroupInput {
  """
  The key of the port group. This is used to uniquely identify the port group
  """
  key: String!
  title: String
  description: String
  effects: [EffectInput!] = []
  ports: [String!] = []
}

"\n                 An effect is a way to modify a port based on a condition. For example,\n    you could have an effect that sets a port to null if another port is null.\n\n    Or, you could have an effect that hides the port if another port meets a condition.\n    E.g when the user selects a certain option in a dropdown, another port is hidden.\n\n\n    "
input EffectInput {
  function: ValidatorFunction!
  dependencies: [String!] = []
  message: String = null
  kind: EffectKind!
  fade: Boolean = true
  hook: String = null
  ward: String = null
}

"Port\n\n    A Port is a single input or output of a action. It is composed of a key and a kind\n    which are used to uniquely identify the port.\n\n    If the Port is a structure, we need to define a identifier and scope,\n    Identifiers uniquely identify a specific type of model for the scopes (e.g\n    all the ports that have the identifier \"@mikro/image\" are of the same type, and\n    are hence compatible with each other). Scopes are used to define in which context\n    the identifier is valid (e.g. a port with the identifier \"@mikro/image\" and the\n    scope \"local\", can only be wired to other ports that have the same identifier and\n    are running in the same app). Global ports are ports that have the scope \"global\",\n    and can be wired to any other port that has the same identifier, as there exists a\n    mechanism to resolve and retrieve the object for each app. Please check the rekuest\n    documentation for more information on how this works.\n\n\n    "
input PortInput {
  validators: [ValidatorInput!] = null
  key: String!
  label: String = null
  kind: PortKind!
  description: String = null
  identifier: String = null
  nullable: Boolean! = false
  effects: [EffectInput!] = null
  default: AnyDefault = null
  children: [PortInput!] = null
  choices: [ChoiceInput!] = null
  assignWidget: AssignWidgetInput = null
  returnWidget: ReturnWidgetInput = null
  descriptors: [DescriptorInput!] = null
}

" \nA validating function for a port. Can specify a function that will run when validating values of the port.\nIf outside dependencies are needed they need to be specified in the dependencies field. With the .. syntax\nwhen transversing the tree of ports. \n\n"
input ValidatorInput {
  function: ValidatorFunction!
  dependencies: [String!] = []
  label: String = null
  errorMessage: String = null
}

"\nA choice is a value that can be selected in a dropdown.\n\nIt is composed of a value, a label, and a description. The value is the\nvalue that is returned when the choice is selected. The label is the\ntext that is displayed in the dropdown. The description is the text\nthat is displayed when the user hovers over the choice.\n\n    "
input ChoiceInput {
  value: AnyDefault!
  label: String!
  image: String = null
  description: String = null
}

input AssignWidgetInput {
  """
  Whether to display the input as a paragraph or not. This is used for text inputs and dropdowns
  """
  asParagraph: Boolean = null
  kind: AssignWidgetKind!
  query: SearchQuery = null
  choices: [ChoiceInput!] = null
  min: Float = null
  max: Float = null
  step: Float = null
  placeholder: String = null
  hook: String = null
  ward: String = null
  fallback: AssignWidgetInput = null
  filters: [PortInput!] = null
  dependencies: [String!] = []
}

"""
The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
"""
scalar SearchQuery

"A Return Widget is a UI element that is used to display the value of a port.\n\n    Return Widgets get displayed both if we show the return values of an assignment,\n    but also when we inspect the given arguments of a previous run task. Their primary\n    usecase is to adequately display the value of a port, in a user readable way.\n\n    Return Widgets are often overwriten by the underlying UI framework (e.g. Orkestrator)\n    to provide a better user experience. For example, a return widget that displays a\n    date could be overwriten to display a calendar widget.\n\n    Return Widgets provide more a way to customize this overwriten behavior.\n\n    "
input ReturnWidgetInput {
  kind: ReturnWidgetKind!
  query: SearchQuery = null
  choices: [ChoiceInput!] = null
  min: Int = null
  max: Int = null
  step: Int = null
  placeholder: String = null
  hook: String = null
  ward: String = null
}

input DescriptorInput {
  key: String!
  value: Arg!
}

"""
A dependency for a implementation. By defining dependencies, you can
    create a dependency graph for your implementations and actions
"""
input ActionDependencyInput {
  key: String!
  hash: ActionHash = null
  name: String = null
  description: String = null
  argMatches: [PortMatchInput!] = null
  returnMatches: [PortMatchInput!] = null
  protocols: [ID!] = null
  forceArgLength: Int = null
  forceReturnLength: Int = null
  optional: Boolean! = false
}

"""The input for creating a implementation in another agents extension."""
input CreateForeignImplementationInput {
  """
  The agent ID to create the implementation in. This is used to identify the agent in the system.
  """
  agent: ID!
  implementation: ImplementationInput!
  extension: String!
}

"""The input for setting extension implementations."""
input SetExtensionImplementationsInput {
  """
  The implementations to set. This is used to identify the implementations in the system.
  """
  implementations: [ImplementationInput!]!
  instanceId: InstanceId!
  extension: String!
  runCleanup: Boolean! = false
}

input AckInput {
  assignation: ID!
}

"""The input for assigning args to a action."""
input AssignInput {
  instanceId: InstanceId!
  action: ID = null
  implementation: ID = null
  agent: ID = null
  actionHash: ActionHash = null
  reservation: ID = null
  interface: String = null
  hooks: [HookInput!] = null
  args: Args!
  reference: String = "8e26c078-4e3b-4810-9bff-bb1461392fed"
  parent: ID = null
  cached: Boolean! = false
  log: Boolean! = false
  ephemeral: Boolean! = false
  isHook: Boolean = false
  step: Boolean = false
}

"""
A hook is a function that is called when a action has reached a specific lifecycle point. Hooks are jsut actions that take an assignation as input and return a value.
"""
input HookInput {
  kind: HookKind!
  hash: ActionHash!
}

enum HookKind {
  CLEANUP
  INIT
}

"""The input for canceling an assignation."""
input CancelInput {
  assignation: ID!
}

"""
The input for stepping an assignation. Stepping is used to go from one breakpoint to another.
"""
input StepInput {
  assignation: ID!
}

"""The input for pausing an assignation."""
input PauseInput {
  assignation: ID!
}

"""The input for resuming an assignation."""
input ResumeInput {
  assignation: ID!
}

"""The input for collecting a shelved item in a drawer."""
input CollectInput {
  drawers: [ID!]!
}

"""The input for interrupting an assignation."""
input InterruptInput {
  assignation: ID!
}

input ReInitInput {
  agent: ID = null
}

"""The input for reserving a action."""
input ReserveInput {
  reference: String = "3ef48101-7bb5-4ed8-be50-c431b8418c4c"
  instanceId: InstanceId! = "default"
  action: ID = null
  implementation: ID = null
  title: String = null
  hash: ActionHash = null
  binds: BindsInput = null
  assignationId: ID = null
}

input BindsInput {
  implementations: [String!]
  clients: [String!]
  desiredInstances: Int! = 1
}

input UnreserveInput {
  reservation: ID!
}

"""The input for deleting a implementation."""
input DeleteImplementationInput {
  implementation: ID!
}

input AgentInput {
  """
  The instance ID of the agent. This is used to identify the agent in the system.
  """
  instanceId: InstanceId!

  """
  The name of the agent. This is used to identify the agent in the system.
  """
  name: String = null

  """
  The extensions of the agent. This is used to identify the agent in the system.
  """
  extensions: [String!] = null
}

input CreateTestCaseInput {
  action: ID!
  tester: ID!
  description: String = null
  name: String = null
}

input CreateTestResultInput {
  case: ID!
  tester: ID!
  implementation: ID!
  passed: Boolean!
  result: String = null
}

input ShelveInMemoryDrawerInput {
  """
  The instance ID of the agent. This is used to identify the agent in the system.
  """
  instanceId: InstanceId!

  """
  The identifier of the drawer. This is used to identify the drawer in the system.
  """
  identifier: Identifier!

  """The resource ID of the drawer."""
  resourceId: String!

  """
  The label of the drawer. This is used to identify the drawer in the system.
  """
  label: String = null

  """
  The description of the drawer. This is used to identify the drawer in the system.
  """
  description: String = null
}

input UnshelveMemoryDrawerInput {
  """
  The instance ID of the agent. This is used to identify the agent in the system.
  """
  instanceId: InstanceId!

  """The resource ID of the drawer."""
  id: String!
}

"""The input for creating a dashboard."""
input CreateDashboardInput {
  name: String = null
  panels: [ID!] = null
  tree: UITreeInput = null
}

input UITreeInput {
  child: UIChildInput!
}

input UIChildInput {
  state: String = null
  kind: UIChildKind!
  hidden: Boolean
  children: [UIChildInput!]
  left: UIChildInput
  right: UIChildInput
}

"""The input for creating a state schema."""
input CreateStateSchemaInput {
  stateSchema: StateSchemaInput!
}

"""The input for creating a state schema."""
input StateSchemaInput {
  ports: [PortInput!]!
  name: String!
}

"""The input for creating a blok."""
input CreateBlokInput {
  name: String!

  """
  The action demands of the blok. This is used to identify the blok in the system.
  """
  actionDemands: [ActionDemandInput!] = null

  """
  The state demands of the blok. This is used to identify the blok in the system.
  """
  stateDemands: [SchemaDemandInput!] = null

  """
  The description of the blok. This can described the blok and its purpose.
  """
  description: String = null

  """
  The URL of the blok. This can be used to link to the blok in the system.
  """
  url: String!
}

"""The input for setting a state schema."""
input SetStateInput {
  interface: String!
  instanceId: InstanceId!
  value: Args!
}

"""The input for creating a blok."""
input MaterializeBlokInput {
  blok: ID!

  """
  The dashboard ID to materialize the blok in. If not provided, the blok will be materialized in the default dashboard.
  """
  dashboard: ID = null

  """
  The agent ID to materialize the blok in. If not provided, the blok will be materialized in the default agent
  """
  agent: ID = null
}

"""The input for updating a state schema."""
input UpdateStateInput {
  interface: String!
  instanceId: InstanceId!
  patches: [Args!]!
}

"""The input for archiving a state schema."""
input ArchiveStateInput {
  stateSchema: ID!
}

"""The input for pinning an model."""
input PinInput {
  id: ID!
  pin: Boolean!
}

input DeleteAgentInput {
  """
  The ID of the agent to delete. This is used to identify the agent in the system.
  """
  id: ID!
}

"""The input for creating a shortcut."""
input CreateShortcutInput {
  """
  The toolbox ID to create the shortcut in. If not provided, the shortcut will be created in the default toolbox.
  """
  toolbox: ID = null
  name: String!
  description: String = null
  action: ID!
  implementation: ID = null
  args: Args!
  allowQuick: Boolean! = false
  useReturns: Boolean! = false
  bindNumber: Int = null
}

"""The input for deleting a shortcut."""
input DeleteShortcutInput {
  id: ID!
}

"""The input for creating a toolbox."""
input CreateToolboxInput {
  name: String!
  description: String
}

"""The input for setting a state schema to an agent."""
input SetAgentStatesInput {
  implementations: [StateImplementationInput!]!
  instanceId: InstanceId!
}

"""The input for initializing a state schema."""
input StateImplementationInput {
  interface: String!
  stateSchema: StateSchemaInput!
  initial: Args!
}

"""Root subscription type for real-time event streams from the system."""
type Subscription {
  """Subscribe to notifications when new actions are created."""
  newActions(cage: ID!): Action!

  """Subscribe to updates on assignations."""
  assignations(instanceId: InstanceId!): AssignationChangeEvent!

  """Subscribe to updates on reservations."""
  reservations(instanceId: InstanceId!): Reservation!

  """Subscribe to events related to assignations."""
  assignationEvents(instanceId: InstanceId!): AssignationEvent!

  """Subscribe to updates on agent connections and statuses."""
  agents: AgentChangeEvent!

  """Subscribe to changes in implementations."""
  implementationChange(implementation: ID!): Implementation!

  """Subscribe to creation or updates of implementations."""
  implementations(agent: ID!): ImplementationUpdate!

  """Subscribe to updates of state values and patches."""
  stateUpdateEvents(stateId: ID!): State!
}

type AssignationChangeEvent {
  event: AssignationEvent
  create: Assignation
}

type AgentChangeEvent {
  update: Agent
  create: Agent
  delete: ID
}

type ImplementationUpdate {
  create: Implementation!
  update: Implementation!
  delete: ID!
}