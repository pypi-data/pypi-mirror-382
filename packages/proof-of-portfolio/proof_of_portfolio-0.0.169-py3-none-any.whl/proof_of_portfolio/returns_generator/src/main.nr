use dep::std;
use std::ops::WrappingAdd;

pub global MAX_CHECKPOINTS: u32 = 200;
pub global MAX_DAYS: u32 = 256;
pub global MERKLE_DEPTH: u32 = 8;
pub global MAX_RETURNS: u32 = 256;
global DAILY_CHECKPOINTS: u32 = 2;
global SECONDS_PER_DAY: u64 = 86400;

// Hashes a single 64-bit log return into a Field element.
pub fn hash_return(log_return: i64) -> Field {
    let unsigned_value = if log_return < 0 {
        (log_return as u64).wrapping_add(0x8000000000000000)
    } else {
        log_return as u64
    };
    std::hash::pedersen_hash([unsigned_value as Field])
}

// Exact same build_merkle_root from components/core/merkle.nr for consistency
pub fn build_merkle_root(leaves: [Field; MAX_RETURNS], num_leaves: u32) -> Field {
    let mut nodes = leaves;
    let mut current_num_leaves = num_leaves;

    for _ in 0..8 {
        let mut next_level_nodes = [0; MAX_RETURNS];

        for i in 0..(MAX_RETURNS / 2) {
            if (i * 2) < current_num_leaves {
                let left = nodes[i * 2];
                let right = if (i * 2 + 1) < current_num_leaves {
                    nodes[i * 2 + 1]
                } else {
                    left
                };

                next_level_nodes[i] = std::hash::pedersen_hash([left, right]);
            }
        }

        nodes = next_level_nodes;
        current_num_leaves = (current_num_leaves + 1) / 2;
    }

    nodes[0]
}

// Use the same day-grouping logic as main circuit for alignment
pub fn calculate_daily_returns(
    gains: [i64; MAX_CHECKPOINTS],
    losses: [i64; MAX_CHECKPOINTS],
    last_update_times: [u64; MAX_CHECKPOINTS],
    accum_times: [u64; MAX_CHECKPOINTS],
    checkpoint_count: u32,
    target_duration: u64,
) -> ([i64; MAX_DAYS], u32) {
    let mut daily_returns: [i64; MAX_DAYS] = [0; MAX_DAYS];
    let mut daily_sums: [i64; MAX_DAYS] = [0; MAX_DAYS];
    let mut daily_counts: [u32; MAX_DAYS] = [0; MAX_DAYS];
    let mut unique_days: [u64; MAX_DAYS] = [0; MAX_DAYS];
    let mut num_days: u32 = 0;

    // Group checkpoints by day timestamp (matching main circuit logic)
    for i in 0..MAX_CHECKPOINTS {
        if (i as u32) < checkpoint_count {
            if accum_times[i] == target_duration {
                let start_time = last_update_times[i] - accum_times[i];
                let day_timestamp = start_time / (SECONDS_PER_DAY * 1000);

                let mut day_index: u32 = MAX_DAYS as u32;
                let mut found = false;

                // Find existing day or create new one
                for j in 0..MAX_DAYS {
                    if !found {
                        if unique_days[j] == day_timestamp {
                            day_index = j as u32;
                            found = true;
                        } else {
                            if unique_days[j] == 0 {
                                if day_index == (MAX_DAYS as u32) {
                                    unique_days[j] = day_timestamp;
                                    day_index = j as u32;
                                    if (j as u32) >= num_days {
                                        num_days = (j as u32) + 1;
                                    }
                                    found = true;
                                }
                            }
                        }
                    }
                }

                // Add to daily sum
                if day_index < (MAX_DAYS as u32) {
                    daily_sums[day_index] += gains[i] + losses[i];
                    daily_counts[day_index] += 1;
                }
            }
        }
    }

    // Compact non-zero days into final array (matching main circuit)
    let mut valid_days: u32 = 0;
    for i in 0..MAX_DAYS {
        if daily_counts[i] > 0 {
            if valid_days < (MAX_DAYS as u32) {
                daily_returns[valid_days] = daily_sums[i];
                valid_days += 1;
            }
        }
    }

    (daily_returns, valid_days)
}

pub fn cps_to_log_returns(
    gains: [i64; MAX_CHECKPOINTS],
    losses: [i64; MAX_CHECKPOINTS],
    last_update_times: [u64; MAX_CHECKPOINTS],
    accum_times: [u64; MAX_CHECKPOINTS],
    checkpoint_count: u32,
    target_duration: u64,
) -> ([i64; MAX_DAYS], u32) {
    calculate_daily_returns(
        gains,
        losses,
        last_update_times,
        accum_times,
        checkpoint_count,
        target_duration,
    )
}

// Main logic
struct ReturnsData {
    returns_merkle_root: Field,
    log_returns: [i64; MAX_DAYS],
    valid_days: u32,
}

fn main(
    gains: [i64; MAX_CHECKPOINTS],
    losses: [i64; MAX_CHECKPOINTS],
    last_update_times: [u64; MAX_CHECKPOINTS],
    accum_times: [u64; MAX_CHECKPOINTS],
    checkpoint_count: u32,
    target_duration: u64,
) -> pub ReturnsData {
    let (log_returns, valid_days) = cps_to_log_returns(
        gains,
        losses,
        last_update_times,
        accum_times,
        checkpoint_count,
        target_duration,
    );
    let mut leaves = [0; MAX_RETURNS];
    for i in 0..MAX_RETURNS {
        if (i as u32) < valid_days {
            leaves[i] = hash_return(log_returns[i]);
        }
    }
    let computed_returns_root = build_merkle_root(leaves, valid_days);
    ReturnsData {
        returns_merkle_root: computed_returns_root,
        log_returns: log_returns,
        valid_days: valid_days,
    }
}
