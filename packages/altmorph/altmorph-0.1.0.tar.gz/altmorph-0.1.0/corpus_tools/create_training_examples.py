#!/usr/bin/env python3
"""Generate training examples by sampling unnormalized variants from AltMorph output.

This script reads a JSONL file (produced by process_jsonl.py) that contains at
least an "alt" field with AltMorph's alternative representation. For each line it
creates an "unnorm" field by selecting one option from every set of alternatives
wrapped in square brackets, and writes the augmented objects to a new JSONL file.
"""

import argparse
import json
import logging
import random
import re
from pathlib import Path
from typing import Any, Iterable, Optional

ALT_PATTERN = re.compile(r"\[([^\[\]]+)\]")


def load_jsonl_lines(path: Path) -> Iterable[str]:
    """Yield non-empty lines from a JSONL file."""
    with path.open("r", encoding="utf-8") as handle:
        for line in handle:
            stripped = line.strip()
            if stripped:
                yield stripped


def select_variants(alt_text: Any, rng: random.Random) -> str:
    """Return a string where each AltMorph alternative block is resolved once."""
    if not isinstance(alt_text, str):
        return str(alt_text)

    text = alt_text.strip()
    if len(text) >= 2 and text[0] == text[-1] and text[0] in {'"', "'"}:
        text = text[1:-1]

    def replace(match: re.Match) -> str:
        options = [candidate.strip() for candidate in match.group(1).split('|')]
        viable = [candidate for candidate in options if candidate]
        pool = viable if viable else options
        return rng.choice(pool) if pool else ''

    return ALT_PATTERN.sub(replace, text)


def process_file(
    input_path: Path,
    output_path: Path,
    seed: Optional[int],
    verbosity: int,
    max_rows: Optional[int],
) -> None:
    """Augment each JSON object with an "unnorm" field and write the result."""
    if not input_path.exists():
        raise FileNotFoundError(f"Input file not found: {input_path}")

    rng = random.Random(seed)
    processed = 0
    skipped = 0
    max_rows_reached = False

    with input_path.open("r", encoding="utf-8") as infile, \
            output_path.open("w", encoding="utf-8") as outfile:
        for raw_line in infile:
            if max_rows is not None and processed >= max_rows:
                max_rows_reached = True
                break
            stripped = raw_line.strip()
            if not stripped:
                continue
            try:
                data = json.loads(stripped)
            except json.JSONDecodeError:
                skipped += 1
                if verbosity >= 1:
                    logging.warning("Skipping invalid JSON line: %s", stripped[:120])
                continue

            alt_field = data.get("alt")
            if alt_field is None:
                skipped += 1
                if verbosity >= 1:
                    logging.warning("Skipping line without 'alt' field: %s", stripped[:120])
                continue

            data["unnorm"] = select_variants(alt_field, rng)
            outfile.write(json.dumps(data, ensure_ascii=False) + "\n")
            processed += 1

    if max_rows is not None and verbosity >= 1:
        if max_rows_reached:
            logging.info("Stopped after reaching max_rows=%d", max_rows)
        elif processed < max_rows:
            logging.info("Completed early: reached end of file before max_rows=%d", max_rows)

    if verbosity >= 1:
        logging.info("Completed: %d lines processed, %d lines skipped", processed, skipped)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Create unnormalized variants from AltMorph JSONL output")
    parser.add_argument("--input_file", required=True, help="JSONL file generated by process_jsonl.py")
    parser.add_argument("--output_file", required=True, help="Destination JSONL file with 'unnorm' field")
    parser.add_argument("--random_seed", type=int, default=None, help="Seed for deterministic variant sampling")
    parser.add_argument("--max-rows", type=int, default=None,
                        help="Maximum number of records to emit (processes all by default)")
    parser.add_argument("--verbosity", type=int, default=1, choices=[0, 1, 2], help="Verbosity level (default: 1)")
    return parser.parse_args()


def configure_logging(verbosity: int) -> None:
    level = logging.WARNING
    if verbosity == 1:
        level = logging.INFO
    elif verbosity >= 2:
        level = logging.DEBUG
    logging.basicConfig(level=level, format="%(levelname)s %(message)s")


def main() -> None:
    args = parse_args()
    configure_logging(args.verbosity)
    process_file(
        Path(args.input_file),
        Path(args.output_file),
        args.random_seed,
        args.verbosity,
        args.max_rows if args.max_rows and args.max_rows > 0 else None,
    )


if __name__ == "__main__":
    main()
