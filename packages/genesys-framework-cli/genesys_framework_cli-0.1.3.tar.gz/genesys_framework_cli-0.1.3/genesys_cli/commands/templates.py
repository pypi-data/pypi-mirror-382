def get_python_node_template(node_type, node_name, class_name):
    """Returns the boilerplate for a Python node of a given type."""
    
    node_type_lower = node_type.lower()
    template = ""

    if node_type_lower == 'publisher':
        template = f"""
from genesys.decorators import node, timer, publisher
from genesys.helpers import spin_node
from std_msgs.msg import String

@node("{node_name}")
class {class_name}:
    \"\"\"
    A simple publisher node that publishes a message every second.
    This node is auto-generated by the Genesys framework.
    \"\"\"
    def __init__(self):
        # The logger is automatically injected by the @node decorator.
        self.counter = 0

    @timer(period_sec=1.0)
    @publisher(topic="chatter", msg_type=String)
    def publish_message(self):
        \"\"\"
        This method is executed every second by the timer.
        The String object it returns is automatically published to the 'chatter' topic.
        \"\"\"
        msg = String()
        msg.data = f"Hello from Genesys! Message #{{self.counter}}"
        
        self.logger.info(f'Publishing: "{{msg.data}}"')
        self.counter += 1
        
        return msg
"""
    elif node_type_lower == 'subscriber':
        template = f"""
from genesys.decorators import node, subscriber
from genesys.helpers import spin_node
from std_msgs.msg import String

@node("{node_name}")
class {class_name}:
    \"\"\"
    A simple subscriber node that listens to a topic.
    This node is auto-generated by the Genesys framework.
    \"\"\"
    def __init__(self):
        self.logger.info("Subscriber node is ready to receive messages.")

    @subscriber(topic="chatter", msg_type=String)
    def message_callback(self, msg):
        \"\"\"
        This method is executed whenever a message is received on the 'chatter' topic.
        \"\"\"
        self.logger.info(f'I heard: "{{msg.data}}"')
"""
    elif node_type_lower == 'service':
        template = f"""
from genesys.decorators import node, service
from genesys.helpers import spin_node
from example_interfaces.srv import AddTwoInts

@node("{node_name}")
class {class_name}:
    \"\"\"
    A simple service server node.
    This node is auto-generated by the Genesys framework.
    \"\"\"
    def __init__(self):
        self.logger.info("Service server is ready to handle requests.")

    @service(service_name="add_two_ints", service_type=AddTwoInts)
    def add_two_ints_callback(self, request, response):
        \"\"\"
        This method is executed whenever the 'add_two_ints' service is called.
        \"\"\"
        response.sum = request.a + request.b
        self.logger.info(f"Incoming request: a={{request.a}}, b={{request.b}}. Sending response: {{response.sum}}")
        return response
"""
    elif node_type_lower == 'actionserver':
        template = f"""
import asyncio
from genesys.decorators import node, action_server
from genesys.helpers import spin_node
from action_tutorials_interfaces.action import Fibonacci

@node("{node_name}")
class {class_name}:
    \"\"\"
    A simple action server node.
    This node is auto-generated by the Genesys framework.
    \"\"\"
    def __init__(self):
        self.logger.info("Action server is ready to handle goals.")

    @action_server(action_name="fibonacci", action_type=Fibonacci)
    async def fibonacci_execute_callback(self, goal_handle):
        \"\"\"Executes the Fibonacci action goal.\"\"\"
        self.logger.info('Executing goal...')

        feedback_msg = Fibonacci.Feedback()
        sequence = [0, 1]
        
        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.logger.info('Goal canceled')
                return Fibonacci.Result()

            sequence.append(sequence[i] + sequence[i-1])
            feedback_msg.partial_sequence = sequence
            self.logger.info(f'Feedback: {{feedback_msg.partial_sequence}}')
            goal_handle.publish_feedback(feedback_msg)
            await asyncio.sleep(1)

        goal_handle.succeed()

        result = Fibonacci.Result()
        result.sequence = sequence
        self.logger.info(f'Returning result: {{result.sequence}}')
        return result
"""
    elif node_type_lower == 'lifecycle':
        template = f"""
from genesys.decorators import node, lifecycle_node, timer, publisher
from genesys.helpers import spin_node
from rclpy.lifecycle import TransitionCallbackReturn
from std_msgs.msg import String

@lifecycle_node
@node("{node_name}")
class {class_name}:
    \"\"\"
    A simple lifecycle node.
    This node is auto-generated by the Genesys framework.
    It must be managed by a lifecycle manager to transition through its states.
    \"\"\"
    def __init__(self):
        self.counter = 0
        self.logger.info("Lifecycle node created. In 'unconfigured' state.")

    # --- Lifecycle Hooks ---
    def on_configure(self, state):
        self.logger.info("on_configure() is called. Setting up resources.")
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state):
        self.logger.info("on_activate() is called. Activating the node.")
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state):
        self.logger.info("on_deactivate() is called. Deactivating the node.")
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state):
        self.logger.info("on_cleanup() is called. Cleaning up resources.")
        return TransitionCallbackReturn.SUCCESS
    
    def on_shutdown(self, state):
        self.logger.info("on_shutdown() is called. Shutting down.")
        return TransitionCallbackReturn.SUCCESS

    # --- Business Logic ---
    @timer(period_sec=1.0)
    @publisher(topic="lifecycle_chatter", msg_type=String)
    def publish_message(self):
        \"\"\"
        This timer and publisher will only be active when the node is in the 'active' state.
        \"\"\"
        msg = String()
        msg.data = f"Hello from Lifecycle Node! Message #{{self.counter}}"
        
        self.logger.info(f'Publishing: "{{msg.data}}"')
        self.counter += 1
        
        return msg
"""

    # Add the main function boilerplate to all templates
    main_boilerplate = f"""
def main(args=None):
    \"\"\"The main entry point for the node, using the spin_node helper.\"\"\"
    spin_node({class_name}, args)

if __name__ == '__main__':
    main()
"""
    return template + main_boilerplate

def get_cpp_node_template(node_name, class_name):
    """Returns the boilerplate for a C++ node."""
    return f"""
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"
#include <chrono>
#include <functional>
#include <string>

// This is a standard C++ node. Once Genesys C++ macros are implemented,
// this boilerplate will be updated to use them for a cleaner developer experience.

using namespace std::chrono_literals;

class {class_name} : public rclcpp::Node
{{
public:
    {class_name}()
    : Node("{node_name}"), count_(0)
    {{
        publisher_ = this->create_publisher<std_msgs::msg::String>("chatter", 10);
        timer_ = this->create_timer(
            1s, std::bind(&{class_name}::timer_callback, this));
        RCLCPP_INFO(this->get_logger(), "{class_name} has been constructed.");
    }}

private:
    void timer_callback()
    {{
        auto message = std_msgs::msg::String();
        message.data = "Hello from Genesys C++! #" + std::to_string(count_++);
        RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
        publisher_->publish(message);
    }}
    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
    size_t count_;
}};

int main(int argc, char * argv[])
{{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<{class_name}>());
    rclcpp::shutdown();
    return 0;
}}
"""
