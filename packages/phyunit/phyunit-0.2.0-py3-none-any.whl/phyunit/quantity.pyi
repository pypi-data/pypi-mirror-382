from fractions import Fraction
from typing import Generic, Literal, Self, TypeVar, overload

from .dimension import Dimension

try:
    import numpy as np  # type: ignore
except ImportError:
    from .utils import numpy_phony as np



__all__ = ['Unit', 'UNITLESS', 'Quantity', 'Constant']


T = TypeVar('T')


class Unit:
    def __init__(self, symbol: str): ...
        # '''construct from unit symbol (str). 

        # Rules for unit symbol
        # ---
        # - unit should be linked from basic units, which are called elements,
        # like `'kg'`, `'s'`, `'meV'`...
        # - the linker should be one of: `'/'`, `'.'`, `'·'`, where `'/'` 
        # represents division, while `'.'` and `'·'` represent multiplication.
        # - the exponents of the elements should be written after the elements,
        # like `'m2'`, `'m-1'`, `'m³'`, `'m^+114514'` are all acceptable.
        # - The standard form has only one `'/'`, and all subsequent elements 
        # are represented as denominators, which does not cause any ambiguity.
        # Therefore, `Unit('kg/m/s') == Unit('kg/m.s')`.
        # - following these basic rules you can easily get used to it, and 
        # properly using it will give you proper result.

        # Example
        # ---
        # - legal expression example:

        # >>> Unit('kg.m/s2')
        # >>> Unit('MeV/c2')
        # >>> Unit('T.W/m2.K4')

        # - illegal expression example: 

        # >>> Unit('x')   # UnitSymbolError: 'x' is not a valid unit.
        # >>> Unit('m+m') # UnitSymbolError: 'm+m' is not a valid element unit.
        # '''
    @classmethod
    def as_unit(cls, unit: str | Self) -> Self: ...
    @property
    def dimension(self) -> Dimension: ...
    @property
    def factor(self) -> float: ...
    @property
    def symbol(self) -> str: ...
    @property
    def name(self) -> str: ...
    def __str__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def sameas(self, other: Self) -> bool: ...
    def isdimensionless(self) -> bool: ...
    def deprefix(self) -> Self: ...
    def toSIbase(self) -> Self: ...
    def simplify(self) -> Self: ...
    def inverse(self) -> Self: ...
    def __mul__(self, other: Self) -> Self: ...
    def __truediv__(self, other: Self) -> Self: ...
    def __imul__(self, other: Self) -> Self: ...
    def __itruediv__(self, other: Self) -> Self: ...
    def __pow__(self, n: int | Fraction) -> Self: ...
    def __ipow__(self, n: int | Fraction) -> Self: ...
    def root(self, n: int | Fraction) -> Self: ...
    def __rmul__(self, other: T) -> Quantity[T]: ...
    def __rtruediv__(self, other: T) -> Quantity[T]: ...
    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs) -> Quantity: ...


UNITLESS: Unit


class Constant(Generic[T]):
    '''Constant objects are just immutable Quantity objects.'''
    @overload
    def __new__(cls, value: float, /, unit: str | Unit) -> Constant[float]: ...
    @overload
    def __new__(cls, value: T, /, unit: str | Unit) -> Constant[T]: ...
    @property
    def value(self) -> T: ...
    @property
    def unit(self) -> Unit: ...
    @property
    def dimension(self) -> Dimension: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __format__(self, format_spec: str) -> str: ...
    def __getitem__(self, i) -> Quantity[T]: ...
    def is_dimensionless(self) -> bool: ...
    def copy(self) -> Constant: ...
    def to(self, new_unit: str | Unit, *, strict=True) -> Constant[T]: ...
    def deprefix_unit(self) -> Quantity[T]: ...
    def toSIbase(self) -> Quantity[T]: ...
    def simplify_unit(self) -> Quantity[T]: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: Constant[T]) -> bool: ...
    def __lt__(self, other: Constant[T]) -> bool: ...
    def __ge__(self, other: Constant[T]) -> bool: ...
    def __le__(self, other: Constant[T]) -> bool: ...
    def __pos__(self) -> Constant[T]: ...
    def __neg__(self) -> Constant[T]: ...
    def __add__(self, other: T | Constant[T]) -> Quantity[T]: ...
    def __sub__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, unit: Unit) -> Quantity[T]: ...
    def __matmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, unit: Unit) -> Quantity[T]: ...
    def __pow__(self, other: int | Fraction) -> Quantity[T]: ...
    def __iadd__(self, other: T | Constant[T]) -> Constant[T]: ...
    def __isub__(self, other: T | Constant[T]) -> Constant[T]: ...
    @overload
    def __imul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __imul__(self, unit: Unit) -> Quantity[T]: ...
    def __imatmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __itruediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __itruediv__(self, unit: Unit) -> Quantity[T]: ...
    def __ipow__(self, other: int | Fraction) -> Quantity[T]: ...
    def __radd__(self, other: T) -> Quantity[T]: ...
    def __rsub__(self, other: T) -> Quantity[T]: ...
    def __rmul__(self, other: float | T) -> Quantity[T]: ...
    def __rmatmul__(self, other: T) -> Quantity[T]: ...
    def __rtruediv__(self, other: float | T) -> Quantity[T]: ...
    def __rpow__(self, other: int | Fraction) -> Quantity[T]: ...
    def root(self, n: int | Fraction) -> Quantity[T]: ...


class Quantity(Constant[T]):
    @overload
    def __new__(cls, value: float, /, unit: str | Unit) -> Quantity[float]: ...
    @overload
    def __new__(cls, value: T, /, unit: str | Unit) -> Quantity[T]: ...
    @property
    def value(self) -> T: ...
    @value.setter
    def value(self, value: T) -> None: ...
    @property
    def unit(self) -> Unit: ...
    @unit.setter
    def unit(self, unit: str | Unit) -> None: ...
    @property
    def dimension(self) -> Dimension: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __format__(self, format_spec: str) -> str: ...
    def isdimensionless(self) -> bool: ...
    def copy(self) -> Quantity[T]: ...
    def to(self, new_unit: str | Unit, *, inplace=False, strict=True) -> Quantity[T]: ...
    def ito(self, new_unit: str | Unit, *, strict=True) -> Quantity[T]: ...
    def deprefix_unit(self, *, inplace=False) -> Quantity[T]: ...
    def toSIbase(self, *, inplace=False) -> Quantity[T]: ...
    def simplify_unit(self, *, inplace=False) -> Quantity[T]: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: Constant[T]) -> bool: ...
    def __lt__(self, other: Constant[T]) -> bool: ...
    def __ge__(self, other: Constant[T]) -> bool: ...
    def __le__(self, other: Constant[T]) -> bool: ...
    def __pos__(self) -> Constant[T]: ...
    def __neg__(self) -> Constant[T]: ...
    def __add__(self, other: T | Constant[T]) -> Quantity[T]: ...
    def __sub__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, unit: Unit) -> Quantity[T]: ...
    def __matmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, unit: Unit) -> Quantity[T]: ...
    def __pow__(self, other: int | Fraction) -> Quantity[T]: ...
    def __iadd__(self, other: T | Constant[T]) -> Quantity[T]: ...
    def __isub__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __imul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __imul__(self, unit: Unit) -> Quantity[T]: ...
    def __imatmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __itruediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __itruediv__(self, unit: Unit) -> Quantity[T]: ...
    def __ipow__(self, other: int | Fraction) -> Quantity[T]: ...
    def __radd__(self, other: T) -> Quantity[T]: ...
    def __rsub__(self, other: T) -> Quantity[T]: ...
    def __rmul__(self, other: float | T) -> Quantity[T]: ...
    def __rmatmul__(self, other: T) -> Quantity[T]: ...
    def __rtruediv__(self, other: float | T) -> Quantity[T]: ...
    def __rpow__(self, other: int | Fraction) -> Quantity[T]: ...
    def root(self, n: int | Fraction) -> Quantity[T]: ...


@overload
def constant(quantity: Quantity[T], /, *, simplify=False) -> Constant[T]: ...
@overload
def constant(quantity: Quantity[T], /, unit: str | Unit) -> Constant[T]: ...

