# ---------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ---------------------------------------------------------

# pylint: disable=protected-access, redefined-builtin

from os import PathLike
from pathlib import Path
from typing import Union

from mldesigner._component_executor import ComponentExecutor, ExecutorBase
from mldesigner._constants import ComponentSource, ExecutorTypes
from mldesigner._exceptions import MldesignerExecutionError
from mldesigner._logger_factory import _LoggerFactory
from mldesigner._utils import _is_instance_of

execute_logger = _LoggerFactory.get_logger("execute", target_stdout=True)


def execute(source: Union[ExecutorBase, "Command", "Parallel"]):
    """Execute a mldesigner component node.

    A mldesigner component node can be generated by calling the @command_component decorated function. The necessary
    inputs and outputs are passed during the calling process. Returned result will be a dictionary that contains
    function execution result, output file/folder paths if defined.

    .. note::

        The following code shows a component function definition.

        .. code-block:: python

            @command_component()
            def train_model(
                input_data : Input(type="uri_folder"),
                lr: int,
                max_epocs = 10,
                my_output_file: Output(type="uri_file") = None,
                my_output_folder: Output(type="uri_folder") = None,
            ):
                pass

        Now let's see how to execute above component

        .. code-block:: python

            from mldesigner import execute
            from xxx import train_model

            node = train_model(input_data="path0", lr=0.5)
            res = execute(node)

        The returned result will be a dict:
            res -> {
                "my_output_file" : "{working_directory}/train_model_{timestamp}/my_output_file",
                "my_output_folder": "{working_directory}/train_model_{timestamp}/my_output_folder",
            }


    :param source: The component source file or an executable component node.
    :type source: Union[str, PathLike, ExecutorBase, "Command", "Parallel"]
    :return: The return dict that contains function execution result, output file/folder paths
    """
    return _execute(source)


def _execute(
    source: Union[str, PathLike, ExecutorBase, "Command", "Parallel"],
    name: str = None,
    inputs: dict = None,
    outputs: dict = None,
):
    """Execute a mldesigner component with inputs.

    :param source: The component source file or an executable component node.
    :type source: Union[str, PathLike, ExecutorBase, "Command", "Parallel"]
    :param name: The name of the component to be executed. This parameter is only meaningful when source is a file path.
                 If not specified, the first component of source file will be executed.
    :type name: str
    :param inputs: The input dictionary of the target component to be executed.
    :type inputs: dict
    :param outputs: The customizable output path for component execution results. This is only meaningful when the
                    component has 'uri_folder' or 'uri_file' output parameters. If not specified, output path will
                    be the parameter name.
    :type outputs: dict
    :return: The return dict that contains function execution result, output file/folder paths
    """
    inputs = inputs or {}
    outputs = outputs or {}
    execute_logger.info("Mldesigner parsing input parameters...")
    source_type = type(source)
    # check if current execution environment has azure-ai.ml package
    EXECUTOR_CLASS = ExecutorBase._get_executor_class()
    is_standalone_mode = EXECUTOR_CLASS == ComponentExecutor

    # 1. when source is a node from azure.ai.ml package, get source file, component name and parameters
    if not is_standalone_mode:
        # alternative of "isinstance(source, BaseNode)" without actually importing the BaseNode class
        if _is_instance_of(source, "BaseNode"):
            source, name, inputs, outputs = _get_source_file_from_base_node(source)

    # 2. when source is a file path, get Executor from file
    if isinstance(source, (str, PathLike)):
        source = _get_executor_from_source_file(source, name)

    # 3. execute function through executor
    if isinstance(source, ExecutorBase):
        res = _execute_component_from_executor(source, inputs, outputs)
        return res
    raise MldesignerExecutionError(f"Unsupported source type '{source_type}'.")


def _get_source_file_from_base_node(node):
    """Get source file and inputs from the azure.ai.ml node"""
    # currently does not support executing node from loading yaml file and node from builder function
    if node.component._source != ComponentSource.MLDESIGNER:
        raise MldesignerExecutionError(
            "Unsupported component source. Only component defined with @command_component "
            "decorator can be executed through mldesigner."
        )
    node_inputs = {}
    node_outputs = {}
    # get arguments when calling the component function
    for input_name, input in node.inputs.items():
        if not hasattr(input, "_meta") or input._meta is None:
            raise MldesignerExecutionError(f"Invalid node input type {type(input)!r}.")
        meta = input._meta
        if meta._is_primitive_type:
            # warning: input._data can be False or empty string
            value = input._data if input._data is not None else meta.default
        else:
            value = input._data.path if input._data is not None else None

        if value is not None or meta.optional is True:
            node_inputs[input_name] = value
    name = node.component.name
    file_name = _get_file_name_from_component_command(node.component.command)
    source_file = Path(node.component.code) / file_name

    return source_file, name, node_inputs, node_outputs


def _get_executor_from_source_file(source, name):
    """Get executor from source file"""
    file = Path(source)
    abs_file_path = file.resolve().absolute()
    execute_logger.info("Looking for target component file: '%s'", abs_file_path)
    if not file.exists():
        raise MldesignerExecutionError(f"Source file does not exist: {abs_file_path}")
    execute_logger.info("Fetching target component: '%s'", name)
    if name is None:
        execute_logger.info("Component name is not specified, will execute the component if only one exists.")

    executor = ComponentExecutor._collect_component_from_file(
        py_file=file, component_name=name, from_executor=True, force_reload=True
    )
    return executor


def _execute_component_from_executor(executor, inputs, outputs):
    """Execute target component"""
    execute_logger.info("Mldesigner starts executing target component: '%s'...", executor._name)
    if executor._type == ExecutorTypes.DYNAMIC:
        # TODO: outputs will be dropped since it won't get processed in dynamic executor
        args = {**inputs}
    else:
        # TODO: handle case when there are overlap parameters
        args = {**inputs, **outputs}
    res = executor.execute(args)
    if res is not None:
        execute_logger.info("Component execution outputs:")
        execute_logger.info("\t  '%s'", res)

    # warning about the user input args that did not get used.
    additional_args = executor._additional_args
    if isinstance(additional_args, dict) and len(additional_args) > 0:
        execute_logger.warning("Additional args found and ignored: %s", list(additional_args.items()))
    return res


def _get_file_name_from_component_command(command_str):
    """Return source file name from component command string"""
    # component command string should be like 'mldesigner execute --source xxx.py'
    if not isinstance(command_str, str):
        raise MldesignerExecutionError(f"Component command must be a string, got {type(command_str)!r} instead.")
    items = command_str.split()
    if not command_str.startswith("mldesigner execute --source") or len(items) < 4 or not items[3].endswith(".py"):
        raise MldesignerExecutionError(
            "Invalid component command string, please make it start with 'mldesigner execute --source xxx.py' "
        )
    return items[3]
