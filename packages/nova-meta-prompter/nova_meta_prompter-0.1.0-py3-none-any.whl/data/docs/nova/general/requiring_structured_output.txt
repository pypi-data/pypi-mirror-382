<requiring_structured_output>
<overview>
To ensure consistent and structured output formats, you can use structured outputs, including formats like XML, JSON, or markdown. This approach allows downstream use cases to more effectively consume and process the outputs generated by the model. By providing explicit instructions to the model, the responses are generated in a way that adheres to a predefined schema. We recommend that you provide an output schema for the model to follow.

For example, if the downstream parser expects specific naming conventions for keys in a JSON object, you should specify this in an Output Schema field of the query. Additionally, if you prefer responses to be in JSON format without any preamble text, instruct the model accordingly. That is, explicitly state "Please generate only the JSON output. DO NOT provide any preamble."
</overview>

<prefilling_technique>
An efficient alternative is to nudge the model's response by prefilling the assistant content. This technique allows you to direct the model's actions, bypass preambles, and enforce specific output formats like JSON and XML. For example, if you prefill the assistant content with "{" or "```json", that input can guide the model to generate the JSON object without providing additional information.

Tip: If you are explicitly looking for extracting JSON, one common observed pattern is to prefill it with ```json and add a stop sequence on ```. This ensures that the model outputs a JSON object that can be programmatically parsed.
</prefilling_technique>

<examples>
<example name="output_schema">
Adding the Output Schema section with the appropriate schema makes the model only stick to that schema.

User: "Provide details about the best selling full-frame cameras in past three years. You MUST answer in JSON format only. Please follow the output schema below.

Output Schema:
[{
    "name": "name goes here",
    "brand": "brand goes here",
    "price": "price goes here",
    "summary": "summary goes here"
}]"
</example>

<example name="prefill_response">
Another approach is to prefill the model's response by including the desired initial text within the assistant's message. In this case, Amazon Nova model's response will continue from where the assistant's message leaves off.

User: "Provide details about the best selling full-frame cameras in past three years. Your response should be in JSON format, with the following keys: name, brand, year, price, summary."

Assistant (Prefilling): "```json"
</example>

<example name="tool_specification">
A third approach is to use tool use to force a specific schema for the model's response by including the pydantic JSON schema in the tool use schema section. In this case, Amazon Nova's response will be structured based on the tool use selection.

Sample tool configuration:
{
    "name": "extract_ner",
    "description": "Extract all the named entities based on provided input",
    "inputSchema": {
        "type": "object",
        "properties": {
            "entities": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string", "description": "The extracted entity name"},
                        "location": {"type": "string", "description": "The extracted location name"},
                        "product": {"type": "string", "description": "The extracted product code"}
                    },
                    "required": ["name", "location", "product"]
                }
            }
        },
        "required": ["entities"]
    }
}
</example>
</examples>
</requiring_structured_output>