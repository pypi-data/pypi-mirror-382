# Copyright Â© 2025 Oracle and/or its affiliates.
#
# This software is under the Universal Permissive License
# (UPL) 1.0 (LICENSE-UPL or https://oss.oracle.com/licenses/upl) or Apache License
# 2.0 (LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0), at your option.

import logging
import re
from copy import deepcopy
from dataclasses import dataclass
from enum import Enum
from typing import List, Optional

logger = logging.getLogger(__name__)


class TaskStatus(Enum):
    """Status of a task"""

    PENDING = "PENDING"  # Planned and pending execution.
    IN_PROGRESS = "IN_PROGRESS"  # Task is currently being executed.  Only one task can be IN_PROGRESS at a time.
    # A task can be in this state for multiple rounds if (for example) the Assistant requires more information to fill a tool execution template.

    SUCCESS = "SUCCESS"  # Completed successfully.
    CANCELLED = "CANCELLED"  # The task is no longer relevant and should not be executed.
    ERROR = "ERROR"  # The task ran but encountered an error.
    NEEDS_REFINEMENT = "NEEDS_REFINEMENT"  # Task is high-level and needs to be refined into an actionable task (see note under code block, below).


# regex to parse a line that contains a task in the form
# - (id: <ID>, status: <STATUS>): <DESCRIPTION>
# or with a tool
# - (id: <ID>, status: <STATUS>, tool: <TOOL>): <DESCRIPTION>
# it requires proper spacing and <ID>/<STATUS>/<TOOL> need to be a single word with underscores.
_plan_line_pattern = re.compile(
    r"^-[ ]+\(id:([\w_]+),[ ]+status:([\w]+)(?:,[ ]tool:([\w\._]+))?\): ([\w\W]+)"
)


@dataclass
class Task:
    id: str  # Unique id within the execution plan
    description: str  # Short (1-sentence) description of what this Task entails.
    status: TaskStatus = TaskStatus.PENDING  # Status of the task
    tool: Optional[str] = (
        None  # If the task involves execution of a tool, this will contain the id for the tool
    )

    @staticmethod
    def from_str(line: str) -> Optional["Task"]:
        match = _plan_line_pattern.match(line)
        if match is None:
            return None
        (id, status, tool, description) = match.group(1, 2, 3, 4)
        return Task(
            id=id,
            status=TaskStatus(status),
            description=description,
            tool=tool,
        )

    def to_str(self) -> str:
        tool_str = f", tool:{self.tool}" if self.tool is not None else ""
        return f"- (id:{self.id}, status:{self.status.value}{tool_str}): {self.description}"


class ExecutionPlan:
    def __init__(self, plan: Optional[List[Task]] = None) -> None:
        self.plan: list[Task] = deepcopy(plan) if plan else []

    @staticmethod
    def from_str(plan_text: str) -> "ExecutionPlan":
        tasks = []
        logger.debug(f"Processing plan generated by LLM:")
        for line in plan_text.split("\n"):
            result = Task.from_str(line)
            if result is not None:
                tasks.append(result)
                logger.debug(f"Line produced plan entry: {result}")
            else:
                logger.debug(f"Line produced no plan, skipping: {line}")
        return ExecutionPlan(tasks)

    def to_str(self) -> str:
        return "\n".join(task.to_str() for task in self.plan)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, ExecutionPlan):
            return False
        return self.plan == other.plan

    def __repr__(self) -> str:
        return str(self.plan)
