# Copyright Â© 2025 Oracle and/or its affiliates.
#
# This software is under the Universal Permissive License
# (UPL) 1.0 (LICENSE-UPL or https://oss.oracle.com/licenses/upl) or Apache License
# 2.0 (LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0), at your option.

from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, Dict, Union, cast

from wayflowcore.component import FrozenDataclassComponent
from wayflowcore.property import _property_can_be_casted_into_property
from wayflowcore.serialization.context import DeserializationContext, SerializationContext
from wayflowcore.serialization.serializer import (
    SerializableObject,
    autodeserialize_from_dict,
    deserialize_from_dict,
    serialize_to_dict,
)

if TYPE_CHECKING:
    from wayflowcore.contextproviders import ContextProvider
    from wayflowcore.steps.step import Step


@dataclass(frozen=True)
class DataFlowEdge(FrozenDataclassComponent):
    """
    A data flow edge specifies how the output of a step or context provider propagates as input of another step.

    Note: An output can be propagated as input of several steps.

    Parameters
    ----------
    source_step:
        The source step or context provider where the data is outputted from.
        This can be an instance of either ``Step`` or ``ContextProvider``.
    source_output:
        The name of the output generated by the ``source_step``.
        This is used to identify the specific output data being propagated.
    destination_step:
        The destination step where the data is directed to.
    destination_input:
        The name of the input in the ``destination_step`` where the data is propagated to.
        This is used to specify how the output data is used as input in the destination step.

    Example
    -------
    >>> from wayflowcore.dataconnection import DataFlowEdge
    >>> from wayflowcore.flow import Flow
    >>> from wayflowcore.steps import OutputMessageStep
    >>>
    >>> FAKE_PROCESSING_STEP = "processing_step"
    >>> OUTPUT_STEP = "output_step"
    >>> fake_processing_step = OutputMessageStep("Successfully processed username {{username}}")
    >>> output_step = OutputMessageStep('{{session_id}}: Received message "{{processing_message}}"')
    >>> flow = Flow(
    ...     begin_step_name=FAKE_PROCESSING_STEP,
    ...     steps={
    ...         FAKE_PROCESSING_STEP: fake_processing_step,
    ...         OUTPUT_STEP: output_step,
    ...     },
    ...     transitions={FAKE_PROCESSING_STEP: [OUTPUT_STEP], OUTPUT_STEP: [None]},
    ...     data_flow_edges=[
    ...         DataFlowEdge(fake_processing_step, OutputMessageStep.OUTPUT, output_step, "processing_message")
    ...     ]
    ... )
    >>> conversation = flow.start_conversation(inputs={
    ...     "username": "Username#123",
    ...     "session_id": "Session#456"
    ... })
    >>> status = conversation.execute()
    >>> last_message = conversation.get_last_message()
    >>> # last_message.content
    >>> # Session#456: Received message "Successfully processed username Username#123"

    """

    source_step: Union["Step", "ContextProvider"]
    source_output: str
    destination_step: "Step"
    destination_input: str

    def __post_init__(self) -> None:
        from wayflowcore.contextproviders import ContextProvider
        from wayflowcore.steps.step import Step

        if not isinstance(self.source_step, (Step, ContextProvider)):
            raise TypeError(
                f"The `source_step` of a data flow edge must be a `Step` or a `ContextProvider`, is {type(self.source_step)}"
            )
        if not isinstance(self.destination_step, Step):
            raise TypeError(
                f"The `destination_step` of a data flow edge must be a `Step`, is {type(self.destination_step)}"
            )

        # It is forbidden to use I/O mapping when using DataFlowEdge
        if isinstance(self.source_step, Step) and not any(
            self.source_output == output_descriptor.name
            for output_descriptor in self.source_step.output_descriptors
        ):
            raise ValueError(
                f"Source output `{self.source_output}` is not in the list of output descriptors of step {self.source_step}. "
            )
        elif isinstance(self.source_step, ContextProvider) and not any(
            self.source_output == output_descriptor.name
            for output_descriptor in self.source_step.get_output_descriptors()
        ):
            raise ValueError(
                f"Source output `{self.source_output}` is not in the list of output descriptors of context provider {self.source_step}."
            )

        if not any(
            self.destination_input == input_descriptor.name
            for input_descriptor in self.destination_step.input_descriptors
        ):
            raise ValueError(
                f"Destination input `{self.destination_input}` is not in the list of input descriptors of step {self.destination_step}. "
            )

        # check casting rules
        output_descriptor = next(
            iter(
                descriptor
                for descriptor in self.source_step.output_descriptors
                if descriptor.name == self.source_output
            )
        )
        input_descriptor = next(
            iter(
                descriptor
                for descriptor in self.destination_step.input_descriptors
                if descriptor.name == self.destination_input
            )
        )
        if not _property_can_be_casted_into_property(output_descriptor, input_descriptor):
            raise TypeError(
                "Descriptor types are not compatible:\n"
                f"- Output descriptor of step `{self.source_step.__class__.__name__}` is:\t{output_descriptor}\n"
                f"- Input descriptor of step `{self.destination_step.__class__.__name__}` is:\t{input_descriptor}"
            )

    def _serialize_to_dict(self, serialization_context: "SerializationContext") -> Dict[str, Any]:
        return {
            "source_step": serialize_to_dict(self.source_step, serialization_context),
            "destination_step": serialize_to_dict(self.destination_step, serialization_context),
            "source_output": self.source_output,
            "destination_input": self.destination_input,
            "id": self.id,
        }

    @classmethod
    def _deserialize_from_dict(
        cls, input_dict: Dict[str, Any], deserialization_context: "DeserializationContext"
    ) -> "SerializableObject":
        from wayflowcore.contextproviders import ContextProvider
        from wayflowcore.steps.step import Step

        data_edge_args = dict(
            source_step=cast(
                Union[Step, ContextProvider],
                autodeserialize_from_dict(input_dict["source_step"], deserialization_context),
            ),
            destination_step=deserialize_from_dict(
                Step, input_dict["destination_step"], deserialization_context
            ),
            source_output=input_dict["source_output"],
            destination_input=input_dict["destination_input"],
            __metadata_info__=input_dict.get("__metadata_info__", {}),
        )
        if "id" in input_dict:
            data_edge_args["id"] = input_dict["id"]
        return DataFlowEdge(**data_edge_args)
