# Copyright Â© 2025 Oracle and/or its affiliates.
#
# This software is under the Universal Permissive License
# (UPL) 1.0 (LICENSE-UPL or https://oss.oracle.com/licenses/upl) or Apache License
# 2.0 (LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0), at your option.

from typing import TYPE_CHECKING, Any, Dict, List, Optional

from wayflowcore._metadata import MetadataType
from wayflowcore._utils._templating_helpers import check_template_validity, render_template
from wayflowcore.messagelist import Message, MessageType
from wayflowcore.models.llmmodel import LlmModel
from wayflowcore.property import Property, StringProperty
from wayflowcore.steps.step import Step, StepResult

from .inputmessagestep import _rephrase_message_and_stream_if_possible
from .templaterenderingstep import TemplateRenderingStep

if TYPE_CHECKING:
    from wayflowcore.executors._flowconversation import FlowConversation

# prevent assistant developers from using message types that are for core developers
EXCLUDED_VALUES = {
    MessageType.USER,
    MessageType.TOOL_RESULT,
    MessageType.TOOL_REQUEST,
    MessageType.INTERNAL,
    MessageType.ERROR,
}


_DEFAULT_MESSAGE_TEMPLATE = "{{ message }}"


class OutputMessageStep(Step):
    """Step to output a message to the chat history."""

    OUTPUT = "output_message"
    """str: Output key for the output message generated by the ``OutputMessageStep``."""

    def __init__(
        self,
        message_template: str = _DEFAULT_MESSAGE_TEMPLATE,
        message_type: MessageType = MessageType.AGENT,
        rephrase: bool = False,
        llm: Optional[LlmModel] = None,
        expose_message_as_output: bool = True,
        input_descriptors: Optional[List[Property]] = None,
        output_descriptors: Optional[List[Property]] = None,
        input_mapping: Optional[Dict[str, str]] = None,
        output_mapping: Optional[Dict[str, str]] = None,
        name: Optional[str] = None,
        __metadata_info__: Optional[MetadataType] = None,
    ):
        """
        Note
        ----

        A step has input and output descriptors, describing what values the step requires to run and what values it produces.

        **Input descriptors**

        By default, when ``input_descriptors`` is set to ``None``, the input_descriptors will be automatically inferred
        from the ``message_template``, with one input descriptor per variable in the template,
        trying to detect the type of the variable based on how it is used in the template.
        See :ref:`TemplateRenderingStep <TemplateRenderingStep>` for concrete examples on how descriptors are
        extracted from text prompts.

        If you provide a list of input descriptors, each provided descriptor will automatically override the detected one,
        in particular using the new type instead of the detected one.
        If some of them are missing, an error will be thrown at instantiation of the step.

        If you provide input descriptors for non-autodetected variables, a warning will be emitted, and
        they won't be used during the execution of the step.

        **Output descriptors**

        By default, this step has one single output descriptor named ``OutputMessageStep.OUTPUT``, of type
        ``StringProperty()``, which will be the message generated by the step.

        Parameters
        ----------
        message_template:
            Jinja str prompt template to use to output a message. See docstring/documentation of
            the ``TemplateRenderingStep`` for concrete examples of how to work with jinja prompts
            in WayFlow. By default the template is ``{{ message }}``.
        message_type:
            Message type of the message added to the message history.
        rephrase:
            Whether to rephrase the message. Requires ``llm`` to be set.
        llm:
            LLM to use to rephrase the message. Only required if ``rephrase=True``.
            Whether to rephrase the message. Requires ``llms`` to be set.
        expose_message_as_output:
            Whether the message generated by this step should appear among the output descriptors
        input_descriptors:
            Input descriptors of the step. ``None`` means the step will resolve the input descriptors automatically using its static configuration in a best effort manner.

        output_descriptors:
            Output descriptors of the step. ``None`` means the step will resolve them automatically using its static
            configuration in a best effort manner.

        name:
            Name of the step.

        input_mapping:
            Mapping between the name of the inputs this step expects and the name to get it from in the conversation input/output dictionary.

        output_mapping:
            Mapping between the name of the outputs this step expects and the name to get it from in the conversation input/output dictionary.

        See Also
        --------
        :class:`~wayflowcore.steps.InputMessageStep` : Step to get an input from the conversation with the user.

        Examples
        --------
        >>> from wayflowcore.flowhelpers import create_single_step_flow
        >>> from wayflowcore.steps import OutputMessageStep
        >>> step = OutputMessageStep(message_template="The user message is `{{user_message}}`")
        >>> assistant = create_single_step_flow(step)
        >>> conversation = assistant.start_conversation(inputs={"user_message": "Hello world!"})
        >>> status = conversation.execute()
        >>> status.output_values
        {'output_message': 'The user message is `Hello world!`'}

        """
        super().__init__(
            llm=llm,
            input_mapping=input_mapping,
            output_mapping=output_mapping,
            step_static_configuration=dict(
                message_template=message_template,
                message_type=message_type,
                rephrase=rephrase,
                llm=llm,
                expose_message_as_output=expose_message_as_output,
            ),
            input_descriptors=input_descriptors,
            output_descriptors=output_descriptors,
            name=name,
            __metadata_info__=__metadata_info__,
        )
        self.rephrase = rephrase
        self.expose_message_as_output = expose_message_as_output
        if message_type in EXCLUDED_VALUES:
            raise ValueError(f"message_type cannot be in {EXCLUDED_VALUES}")
        self.message_type = message_type
        self.message_template = message_template
        check_template_validity(self.message_template)

    @classmethod
    def _get_step_specific_static_configuration_descriptors(
        cls,
    ) -> Dict[str, type]:
        """
        Returns a dictionary in which the keys are the names of the configuration items
        and the values are a descriptor for the expected type
        """
        return {
            "message_template": str,
            "message_type": MessageType,
            "rephrase": bool,
            "llm": Optional[LlmModel],  # type: ignore
            "expose_message_as_output": bool,
        }

    @classmethod
    def _compute_step_specific_input_descriptors_from_static_config(
        cls,
        message_template: str,
        message_type: MessageType,
        rephrase: bool,
        llm: Optional[LlmModel],
        expose_message_as_output: bool,
    ) -> List[Property]:
        return TemplateRenderingStep._compute_step_specific_input_descriptors_from_static_config(
            template=message_template
        )

    @classmethod
    def _compute_step_specific_output_descriptors_from_static_config(
        cls,
        message_template: str,
        message_type: MessageType,
        rephrase: bool,
        llm: Optional[LlmModel],
        expose_message_as_output: bool,
    ) -> List[Property]:
        return (
            [
                StringProperty(
                    name=OutputMessageStep.OUTPUT,
                    description="the message added to the messages list",
                )
            ]
            if expose_message_as_output
            else []
        )

    async def _invoke_step_async(
        self,
        inputs: Dict[str, Any],
        conversation: "FlowConversation",
    ) -> StepResult:
        message_txt = render_template(template=self.message_template, inputs=inputs)
        if self.rephrase and self.llm is not None:
            await _rephrase_message_and_stream_if_possible(message_txt, conversation, self.llm)
        else:
            conversation.append_message(
                Message(content=message_txt, message_type=self.message_type)
            )

        return StepResult(
            outputs={self.OUTPUT: message_txt} if self.expose_message_as_output else {},
        )
