from abc import abstractmethod
from collections import defaultdict
from operator import add
from typing import Dict, List, Optional, Sequence, Type

import numpy as np
from physrisk.kernel.assets import Asset

from physrisk.vulnerability_models.config_based_impact_curves import (
    DowntimeConfigItem,
    ImpactCurveKey,
)
from physrisk.vulnerability_models.vulnerability import get_asset_type


class DowntimeModelBase:
    @abstractmethod
    def get_impact(self, asset: Asset, frac_damage: np.ndarray) -> np.ndarray: ...


class ConfigBasedDowntimeModel(DowntimeModelBase):
    def __init__(
        self,
        *,
        asset_class: str,  # type of the asset class
        config_items: Sequence[DowntimeConfigItem],
    ):
        super().__init__()
        self.asset_class_type = asset_class
        self.curves = {
            ImpactCurveKey(item.asset_identifier): item for item in config_items
        }
        self.asset_attributes = set(
            key for curve in self.curves for key in curve.identifier.keys()
        )

    def get_impact(self, asset: Asset, frac_damage: np.ndarray) -> np.ndarray:
        curve = self.curves[
            ImpactCurveKey.get(asset, self.asset_attributes, self.curves.keys())
        ]
        return np.interp(frac_damage, curve.points_x, curve.points_y)


class DowntimeModels:
    def __init__(self, config: Sequence[DowntimeConfigItem] = []):
        self.models: Dict[Type[Asset], Sequence[DowntimeModelBase]] = (
            self.programmatic_models()
        )
        if any(config):
            config_base_models = self.config_based_models(config)
            for k, v in config_base_models.items():
                self.models[k] = add(v, self.models[k]) if k in self.models else v

    def downtime_model_for_asset_of_type(
        self, type: type
    ) -> Optional[Sequence[DowntimeModelBase]]:
        for asset_class_type in type.mro():
            if asset_class_type is not object and asset_class_type in self.models:
                return self.models[asset_class_type]
        return self.models.get(Asset)

    def config_based_models(self, config: Sequence[DowntimeConfigItem]):
        items_by_asset_class: Dict[Type[Asset], List[DowntimeConfigItem]] = defaultdict(
            list
        )
        for item in config:
            items_by_asset_class[get_asset_type(item.asset_class)].append(item)

        ancestors = dict(
            sorted(
                dict({key: key.mro() for key in items_by_asset_class}).items(),
                key=lambda item: len(item[1]),
            )
        )
        for k, v in ancestors.items():
            keys = [item.asset_identifier for item in items_by_asset_class[k]]
            for asset_class in v:
                if (
                    asset_class not in [k, object]
                    and asset_class in items_by_asset_class
                ):
                    items_by_asset_class[k] = add(
                        items_by_asset_class[k],
                        [
                            item
                            for item in items_by_asset_class[asset_class]
                            if item.asset_identifier not in keys
                        ],
                    )
                    keys = [item.asset_identifier for item in items_by_asset_class[k]]

        models: Dict[Type[Asset], List[DowntimeModelBase]] = defaultdict(list)
        for asset_class, items in items_by_asset_class.items():
            try:
                models[asset_class].append(
                    ConfigBasedDowntimeModel(
                        asset_class=asset_class.__name__,
                        config_items=items,
                    )
                )
            except Exception:
                raise ValueError(
                    f"Could not convert config item with asset {asset_class.__name__}."
                )
        return models

    def programmatic_models(self) -> Dict[Type[Asset], Sequence[DowntimeModelBase]]:
        return {}
